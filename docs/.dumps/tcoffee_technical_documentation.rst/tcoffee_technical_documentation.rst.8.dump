<DumpIO>
<nature>standard dump</nature>
<program>T-COFFEE</program>
<version>Version_13.39.0.d675aed</version>
<build>Version_13.39.0.d675aed</build>
<cl>t_coffee -other_pg unpack_all </cl>
<stack>
</stack>
<warning>
</warning>
<file>
<stream>output</stream>
<name>stdout</name>
<content></content>
</file>
<file>
<stream>output</stream>
<name>stderr</name>
<content>
Unpack Script rec_sum.pl

Unpack Script count.pl

Unpack Script process_list.pl

Unpack Script make_license.pl

Unpack Script CCsed.script

Unpack Script msa2bootstrap.pl

Unpack Script tc_generic_method.pl

Unpack Script rnapdb2protpdb.pl

Unpack Script generic_method.tc_method

Unpack Script clustalw_method.tc_method

Unpack Script extract_from_pdb

Unpack Script install.pl

Unpack Script clean_cache.pl

Unpack Script nature_protocol.pl

Unpack Script mocca

Unpack Script dalilite.pl

Unpack Script wublast.pl

Unpack Script blastpgp.pl

Unpack Script ncbiblast_lwp.pl

Unpack Script wublast_lwp.pl

Unpack Script RNAplfold2tclib.pl

Unpack Script fasta_seq2RNAplfold_templatefile.pl

Unpack Script fasta_seq2hmmtop_fasta.pl

Unpack Script fasta_seq2consan_aln.pl

Unpack Script clustalw_aln2fasta_aln.pl

Unpack Script seq2name_seq.pl

Unpack Script seq2intersection.pl

Unpack Script msf_aln2fasta_aln.pl

Unpack Script msa.pl

Unpack Script upp.pl

Unpack Script clustalo.pl

Unpack Script dca.pl

Unpack Script blast_aln2fasta_aln.pl

Unpack Script blast_xml2fasta_aln.pl

Unpack Script fasta_aln2fasta_aln_unique_name.pl

Unpack Script newick2name_list.pl

Unpack Script excel2fasta.pl

Unpack Script nameseq2fasta.pl

Unpack Script any_file2unix_file.pl
</content>
</file>
<file>
<stream>output</stream>
<name>rec_sum.pl</name>
<content>#!/usr/bin/env perl
use File::Copy;
use Env qw(HOST);
use Env qw(HOME);
use Env qw(USER);
$x_field=0;
$y_field=1;
$y_field_set=1;
$nyf=1;

$interval=0;
$file="stdin";

$print_avg=1;
$print_sd=0;
$print_sum=0;
$print_n=0;
foreach $value ( @ARGV)
    {
	if ($value ne $ARGV[$np]) 
	    {
	    ;
	    }
	elsif($value eq "-s")
	     {
	       $step=$ARGV[++$np];
	       $np++;
	     }
	elsif($value eq "-print_all")
	    {
	    $print_sd=$print_avg=$print_n=$print_sum=1;
	    $np++;
	    }
	elsif($value eq "-print_sum")
	    {
	    $print_sum=1;
	    $print_avg=0;
	    $np++;
	    }
	elsif($value eq "-print_n")
	    {
	    $print_n=1;
	    $print_avg=0;
	    $np++;
	    }
	elsif($value eq "-print_avg")
	    {
	    $print_avg=1;
	    $print_avg=0;
	    $np++;
	    }
	elsif($value eq "-sd")
	    {
	    $print_sd=1;
	    $print_avg=0;
	    $np++;
	    }
	elsif($value eq "-h")
	    {
	    $header=1;
	    $np++;
	    }
	elsif ($value eq "-i")
	    {
	    $interval= $ARGV[++$np];
	    $np++;
    	    }
	elsif ($value eq "-r2")
	    {
	      $r2=1;
	      
	      $np  = $ARGV[++$np];
	      $nsim= $ARGV[++$np];
	      $np++;
    	    }
	elsif ($value eq "-r")
	    {
	    $min= $ARGV[++$np];
	    $max= $ARGV[++$np];
	    $np++;
    	    }
	
	elsif ($value eq "-x")
	    {
	    $x_field= $ARGV[++$np]-1;
	    $np++;
    	    }
	elsif ($value eq "-y")
	    {
	    $nyf=0;  
	    while ($ARGV[$np+1] && !($ARGV[$np+1]=~/\-/))
	      {
		$y_field[$nyf++]=$ARGV[++$np]-1;
		$y_field_set=1;
	      }

	    $np++;
    	    }
	elsif ($value eq "-file")
	    {
	    $file= $ARGV[++$np];
	    $file_set=1;
	    $np++;
    	    }       
	elsif ( $value eq "h" ||  $value eq "-h" || $value eq "-H" || $value eq "-help" || $value eq "help")
	  {
	    print STDOUT "data_analyse: Analyse and discretization of data\n";
	    print STDOUT "       -file:    <file containing the data to analyze>,.<def=STDIN>\n";
	    print STDOUT "       -x: <field containing the X>,...............<Def=0>\n";
	    print STDOUT "       -y: <field containing the Y>,...............<Def=1>\n";
	    print STDOUT "       -i:<Interval size on the X>,...............<Def=0>\n";
	    print STDOUT "       -i:<0:only one interval>\n";
	    print STDOUT "       -r:<Range of the X>\n";
	    print STDOUT "       -s:<Step on the  X, 0 means non sliding bins>\n";
	    print STDOUT "       -sd: print standard deviation on the Y";
	    print STDOUT "       -h  : print column header \n";
	    exit (0);
	  }
	elsif ($value=~/-/)
	  {
	    print "$value is not a valid FLAG[FATAL]\n";
	    exit (0);
	   } 
	elsif ($list eq "") 
	    {
	    $file=$ARGV[$np];
	    $np++;
	    }
	
	
      }





if ($file eq "stdin")
	{
	$remove_file=1;
	$file="tmp$$";
	open (F, ">$file");
	while (<STDIN>)
		{
		print F $_;
		}
	close (F);
	 
	;}



if ($interval && $step)
  {
    my $nl;
    open(F,$file);
    while (<F>)
      {
	$line=$_;
	
	if (!/\S/){next;}
	@list=($line=~/(\S+)/g);
	$val{$nl}{x}=$list[$x_field];
	$val{$nl}{y}=$list[$y_field[0]];
	$nl++
      }
    close (F);
    
    for (my $a=$min; $a<($max+$interval); $a+=$step)
      {
	my ($avgx, $avgy, $cn);
	
	my $rmin=$a-$interval;
	my $rmax=$a;
	$cn=0;
	for (my $b=0; $b<$nl; $b++)
	  {
	    my $x=$val{$b}{x};
	    my $y=$val{$b}{y};
	    if ($x<=$rmax && $x>=$rmin)
	      {
		$avgx+=$x;
		$avgy+=$y;
		$cn++;
		$tcn++;
		$val{$b}{used}=1;
	      }
	  }
	if ($cn)
	  {
	    $avgx/=$cn;
	    $avgy/=$cn;
	  }
	printf "%.3f %.3f %.3f\n", $avgx, $avgy, $avgx-$avgy;
      }
    for (my $a=0; $a<$nl; $a++)
      {
	if ( !$val{$a}{used})
	  {
	    print "---$val{$a}{x}; $val{$a}{y}\n";
	  }
      }
  }
else
  {
    if ($interval && $max)
      {
	$interval_size=($max-$min)/$interval;
      }
    elsif ($interval)
      {
	open(F,$file);  
	my $set_max=0;
	my $set_min=0;
	while (<F>)
	  {
	    my $v=$_;
	    chomp($v);
	    print "--$v--";
	    
	    if ($v<$min ||!$set_min){$set_min=1;$min=$v;}
	    if ($v>$max ||!$set_max){$set_max=1;$max=$v;}
	  }
	close (F);
	print "$min $max uuuu";
	$interval_size=($max-$min)/$interval;
      }
    open(F,$file);  
    while (<F>)
      {
	$line=$_;
	if (!/\S/){next;}
	@list=($line=~/(\S+)/g);
	
	if ($interval==0){$bin=0;}
	else{$bin=int (($list[$x_field]-$min)/($interval_size));}
	
	
	if ($bin && $bin==$interval){$bin--;}
	for ( $a=0; $a<$nyf; $a++)
	  {
	    $sum{$a}{$bin}+=$list[$y_field[$a]];
	    $sum2{$a}{$bin}+=$list[$y_field[$a]]*$list[$y_field[$a]];
	    $n{$a}{$bin}++;
	  }
      }
    
    if (!$interval){$interval=1;}
    for ( $a=0; $a<$interval; $a++)
      {
	printf ( "%4d %4d ", $interval_size*$a, $interval_size*($a+1));
	for ( $b=0; $b<$nyf; $b++)	
	  {
	    $i=$interval*$a;
	    if ( $n{$b}{$a}==0)
	      {
		$avg=0;
		$sd=0;
	      }
	    else
	      {
		$avg=$sum{$b}{$a}/$n{$b}{$a};
		$sd=sqrt($sum2{$b}{$a}*$n{$b}{$a}-$sum{$b}{$a}*$sum{$b}{$a})/($n{$b}{$a}*$n{$b}{$a});
	      }
	    if ($print_n) {printf "%15.4f ", $n{$b}{$a};}
	    if ($print_sum){printf "%15.4f ", $sum{$b}{$a};}
	    if ($print_avg){printf "%15.4f ", $avg}
	    if ($print_sd) {printf "%15.4f ", $sd;}
	  }
	printf ("\n");
      }
  }

if ( $remove_file){unlink $file;}

</content>
</file>
<file>
<stream>output</stream>
<name>count.pl</name>
<content>#!/usr/bin/env perl
use File::Copy;
use Env qw(HOST);
use Env qw(HOME);
use Env qw(USER);

foreach $v (@ARGV){$cl.=$v;}


if ( $cl=~/-k(\d+)/){$k=$1;}
else {$k=1;}
if ( $cl=~/-w(\d+)/){$w=$1;}
else {$w=-1;}
if ( $cl=~/-p(\d+)/){$p=$1;}
else {$p=-1;}

while (<STDIN>)
  {
    @l=($_=~/(\S+)/g);
    $v=$l[$k-1];
    if ( !$h{$v}){@ll=($v, @ll);}
    
    if ( $w==-1)
      {$h{$v}++;}
    else
      {$h{$v}+=$l[$w-1];}

    if ($p!=-1){$print{$v}=$l[$p-1];}

  }
foreach $v (@ll)
  {
    print "$v $print{$v} $h{$v}\n";
  }

</content>
</file>
<file>
<stream>output</stream>
<name>process_list.pl</name>
<content>#!/usr/bin/env perl

use Env qw(HOST);
use Env qw(HOME);
use Env qw(USER);
$random_tag=int (rand 10000)+1;
$unique_prefix="$$.$HOST.$random_tag";
$queue="distillery.and.mid";
$monitor=0;
$stderr_file="/dev/null";
$stdio_file="/dev/null";
$log_file="/dev/null";
$pause_time=0;
$max_sub_jobs=60;
$min_sub_jobs=30;
$output_all=0;
$var='\$';

foreach $value ( @ARGV)
    {
	if ($value ne $ARGV[$np]) 
	    {
	    ;
	    }
	elsif ($value eq "-max_sub_jobs")
	    {
	    $max_sub_jobs= $ARGV[++$np];
	    $np++;
    	    }	
	elsif ($value eq "-min_sub_jobs" )
	    {
	    $min_sub_jobs= $ARGV[++$np];
	    $np++;
    	    }
	elsif ($value eq "-para")
	    {
	    $para=1;
	    $monitor=1;
	    $np++;
    	    }
	elsif ($value eq "-monitor") 
	    {
	    $monitor=1;
	    $np++;
	    }
	elsif ($value eq "-no_monitor") 
	    {
	    $monitor=0;
	    $np++;
	    }
	elsif ($value eq "-queue")
	    {
	    $queue=$ARGV[++$np];
	    $np++;
	    }	
	elsif ($value eq "-stderr_file")
	    {
	    $stderr_file=$ARGV[++$np];
	    $np++;
	    }
	elsif ($value eq "-stdio_file")
	    {
	    $stdio_file=$ARGV[++$np];
	    $np++;
	    }
	elsif ($value eq "-output_all")
	    {
	    $output_all=1;
	    $np++;
	    }
	elsif ($value eq "-pause") 
	    {
	    $pause_time=$ARGV[++$np];
	    $np++;
	    }
	elsif ($value eq "-log")
	      {
	       $log=1;
	       
	       if ($ARGV[$np+1]=~/\-\S+/) 
	          {
		  $log_file="stderr";
	          }
	       else 
	          {
		  $log_file=$ARGV[++$np]; 
		  ++$np;
		 
	          }
	      }
	elsif ( $value eq "-com")
	    {
		
		if (!$ARGV[$np+1]=~/^\'/) { $com=$ARGV[++$np];}
		else {$com=$ARGV[++$np];}

	     $np++;
	    }
	elsif ( $value eq "-check")
	  {
	    
	    if (!$ARGV[$np+1]=~/^\'/) { $check=$ARGV[++$np];}
	    else {$check=$ARGV[++$np];}
	    $np++;
	  }
	elsif ($com eq "") 
	    {
	    $com_set=1;
	    $com=$ARGV[$np];
	    
	    $np++;
	    }
	elsif ($list eq "") 
	    {
	    $list_set=1;
	    $list=$ARGV[$np];
	    $np++;
	    }
	elsif ( $var_set eq "")
	    {
	    $var_set=1;
	    $var=$ARGV[$np];
	    $np++;
	    }
	}




if ( $com eq ""){print "You Need to Provide a Command [FATAL]\n";
	      die;
	     }



if ($list_set==0) 
    {
    $x= int (rand 100000)+1;
    $tmp_file_name="tmp_file_$x";
    open ( TMP, ">$tmp_file_name");
    while (<STDIN>)
      {
	print TMP $_;
      }
    close (TMP);
    open (F, $tmp_file_name);
    }
else 
    {
    open (F, $list);
    }

if ($para==0) 
    {

     @tc_list= <F>;
     close (F); 
     
     foreach $val(@tc_list) 
	    {
	      
	      
	      
	      $loc_com=$com;
	      if ($check){$loc_check=$check;}
	      
	      @i_val=($val=~/([^\s]+)/g);
	      
	      if ( $#i_val==0)
		{
		  if ($check){$loc_check=~s/$var/$i_val[0]/g;}
		  $loc_com=~s/$var/$i_val[0]/g;
		}
	      else
		{
		  for ($n=1; $n<=$#i_val+1;$n++ )
		    {
		      
		      $sub="$var$n";
		      
		      $loc_com=~s/$sub/$i_val[$n-1]/g;
		      if ($check){$loc_check=~s/$var/$i_val[0]/g;}
		    }
		}
	      if ( $check && -e $loc_check)
		{
		  print STDERR "skipping $loc_com...\n";
		  }
	      else
		{
		  system "$loc_com";
		}
	    }
    exit;
    }

elsif ($para==1) 
    {
    print STDERR "do parallel execution of: \"$com $list\"\n";
    
    if ($log==1) 
	{
	if ($log_file eq "stdout" || $log_file eq "stderr" ) 
		{
		$log_file="";
	        }

        else 
		{
		system "echo LOG FILE> $log_file";
		
	        }
	}
    else	
	{
	open ( OUT, ">/dev/null");
	}
	
    
    $id=0;
    $n_sub=0;
    while ($val=<F>) 
	    {	    	    
	    $job_log[$id]="$HOME/tmp/$unique_prefix.$id.log_file";
	    
	    $job=$unique_prefix."_$id";
	    open (JOB, ">$job");
	    
	    $loc_com=$com;
	    chop $val;

	    $loc_com=~s/\$/$val/g;
	 
	    print JOB "#!/bin/csh\n";
	    print JOB "#\$ -cwd\n";
	    print JOB "#\$ -N $unique_prefix\n";
	    if ($queue && !($queue eq " ")) {print JOB "#\$ -l $queue\n";}
	    print JOB "#\n";	    
            print JOB "$loc_com\n";
	    print JOB "echo FINISHED  >> $job_log[$id]\n";
	    print JOB "pwd\n";
	    
	    close (JOB);
	    if ( $output_all==1)
		{
		system "qsub $job >  $unique_prefix";		
	        }
	    else
		{system "qsub $job -e $stderr_file -o $stdio_file >$unique_prefix";	        
	        } 



	    print STDERR "$id: $output_all\n";
	    $n_sub++;
	    if ( $max_sub_jobs && $n_sub==$max_sub_jobs) 
		{
		$n_sub=monitor_process($min_sub_jobs,@job_log); 		 
		
	        }	
	   
            unlink $unique_prefix;
	    sleep $pause_time;
	    $id++;
	    }

    close (OUT);
    close (F);

    print STDERR "Your $id Jobs Have Been Submited (NAME=$unique_prefix)\n";
    monitor_process (0, @job_log);
    foreach $file(@job_log) {if (-e $file) {unlink($file);}}
    
    }

sub monitor_process ( @job_list)
    {
    my (@job_list)=@_;
    my $min_sub_jobs=shift (@job_list);
    my $n_sub_jobs;
    my $finished;
    my $n=0;

    $n_sub_jobs=-1;
    $finished=0;
    print STDERR "\nMonitor Batch: [$min_sub_jobs]";
       
    while (!$finished && (($n_sub_jobs>$min_sub_jobs)|| $n_sub_jobs==-1) ) 
	{
	$finished=1;
	$n_sub_jobs=0;
	$n=0;
	foreach $file (@job_list)
	        {
	
		if (-e $file){;}
		else 
		    {
		    $finished=0; $n_sub_jobs++;
	            }
	        }
	system "sleep 1";
        }
    
    return $n_sub_jobs;
    }
    
    
if ($tmp_file_name){unlink($tmp_file_name);}

</content>
</file>
<file>
<stream>output</stream>
<name>make_license.pl</name>
<content>#!/usr/bin/env perl


foreach ($np=0; $np<=$#ARGV; $np++)
    {
    $value=$ARGV[$np];

    if ($value eq "-file")
      {
      $file= $ARGV[++$np];
      }
    elsif ($value eq "-type")
      {
        $type= $ARGV[++$np];
      }
    elsif ($value eq "-institute")
      {
        $institute= $ARGV[++$np];
      }
    elsif ($value eq "-author")
      {
        $author= $ARGV[++$np];
      }
    elsif ($value eq "-date")
      {
        $date= $ARGV[++$np];
      }
     elsif ($value eq "-program")
      {
        $program= $ARGV[++$np];
      }
    elsif ($value eq "-email")
      {
        $email= $ARGV[++$np];
      }
    else
      {
	print "$value is an unkown argument[FATAL]\n";
	exit (1);
      }
  }



open F, $file || die;
print $INSTITUTE;
if ( $type eq "c"){print "/******************************COPYRIGHT NOTICE*******************************/\n";}
if ( $type eq "perl"){print "##############################COPYRIGHT NOTICE##############################/\n";}
if ( $type eq "txt"){print "-------------------------------COPYRIGHT NOTICE------------------------------/\n";}


while (<F>)
  {
  s/\$INSTITUTE/$institute/g;
  s/\$AUTHOR/$author/g;
  s/\$DATE/$date/g;
  s/\$PROGRAM/$program/g;  
  s/\$EMAIL/$email/g;  
  if ( $type eq "txt"){print $_;}
  elsif ($type eq "c"){chop $_; print "\/*$_*\/\n";}
  elsif ($type eq "perl"){print "\#$_";}
}
close (F);
if ( $type eq "c"){print "/******************************COPYRIGHT NOTICE*******************************/\n";}
if ( $type eq "perl"){print "##############################COPYRIGHT NOTICE##############################/\n";}
if ( $type eq "txt"){print "-------------------------------COPYRIGHT NOTICE------------------------------/\n";}


</content>
</file>
<file>
<stream>output</stream>
<name>CCsed.script</name>
<content>#!/usr/bin/env perl

while (<>)	
	{
	s/\=cc/123456789/g;
	s/\bcc/\$\(CC\)/g;
	s/123456789/\=cc/g;
	print $_;
	}


</content>
</file>
<file>
<stream>output</stream>
<name>msa2bootstrap.pl</name>
<content>#!/usr/bin/env perl
$version="1.00";
$rseed= int(rand(100000))+1;


if ( $#ARGV==-1)
  {
    print "msa2bootstrap -i <input_file> -input <seq|msa|matrix|tree> -n <N-Boostrap> -o <outtree> -tmode <nj|upgma|parsimony|ml> -dmode <kimura> -alignpg <t_coffee | muscle | clustalw> -rtree <file> -stype <prot|cdna|dna> -recompute -system <cygwin|unix>";
    print "\n\t-i: input file, can be sequneces, msa, matrix, trees, type is specified via -input";
    print "\n\t-input: Type of input data";
    print "\n\t\tmsa: msa in fasta format";
    print "\n\t\tseq: compute an msa with -alignpg";
    print "\n\t\tmatrix: phylipp distance matrix fed directly to method -tmode [caveat: tmode=nj or upgma]";
    print "\n\t\ttree: list of newick trees directly fed to consence in order to generate a bootstraped tree";
    
    print "\n\t-n: number of bootstrap replicates";
    print "\n\t-o: name of the output tree. Files are not overwritten. Use -recompute to overwrite existing file";
    print "\n\t-tmode: tree mode: nj|upgma|parsimony|ml";
    print "\n\t-dmode: distance mode";
    print "\n\t-alignpg: program for aligning sequences (t_coffee=default)";
    print "\n\t-rtree: replicate tree file (default: no file)";
    print "\n\t-rmsa: replicate msa file (default: no file)";
    print "\n\t-rmat: replicate matrix file (default: no file)";
    print "\n\t-stype: sequence type: protein, dna or cdna";
    print "\n\t-recompute: force files to be overwritten";
    print "\n\t-system: cygwin|unix";
      

    
    &my_exit (EXIT_FAILURE);
  }
foreach $arg (@ARGV){$command.="$arg ";}

print "CLINE: $command\n";
$threshold=100;
$trim_msa=0;
$stype="prot";
print "msa2bootstrap ";

$system="cygwin";
if(($command=~/\-system (\S+)/))
  {
    $system=$1;
    if ( $system eq "cygwin")
      {
	$exec_extension=".exe";
      }
    elsif ( $system eq "unix")
      {
	$exec_extension="";
	print "system=Unix";die;
      }
    else
      {
	print "msa2boostrap: -system=$system is an unknown mode [FATAL]\n"; die;
      }
    
    print "-system $system ";
  }
if(($command=~/\-stype (\S+)/))
  {
    $stype=$1;
  }
print "-stype=$stype ";



if(($command=~/\-i (\S+)/))
  {
    $msa=$1;
    print "-i $msa ";
  }

if(($command=~/\-rtree (\S+)/))
  {
    $rtree=$1;
    print "-rtree=$rtree ";
  }

if(($command=~/\-rmsa (\S+)/))
  {
    $rmsa=$1;
  }
if(($command=~/\-rmat (\S+)/))
  {
    $rmat=$1;
  }
$input="seq";
if(($command=~/\-input (\S+)/))
  {
    $input=$1;
  }
print "-input=$input ";

$dmode="kimura";
if(($command=~/\-dmode (\S+)/))
  {
    $dmode=$1;
  }
print "-dmode=$dmode ";
$alignpg="muscle";
if(($command=~/\-alignpg (\S+)/))
  {
    $alignpg=$1;
  }
print "-alignpg=$dmode ";

$tmode="nj";
if(($command=~/\-tmode (\S+)/))
  {
    $tmode=$1;
  }
print "-tmode=$tmode ";
$recompute=0;
if(($command=~/\-recompute/))
  {
    $recompute=1;
    print "-recompute ";
  }

$out=$msa;
$out=~s/\..*//;
$out.=".bph";
if(($command=~/\-o (\S+)/))
  {
    $out=$1;
    
  }
print "-out=$out ";
if (-e $out && !$recompute)
  {
    print "\nNo Computation Required $out already exists\n";
    &my_exit (EXIT_SUCCESS);
    
  }

$n=100;
if(($command=~/\-n (\d+)/))
  {
    $n=$1;
  }
print "-n=$n ";
$seed=3;
if(($command=~/\-s (\d+)/))
  {
    $seed=$1;
  }
print "-s=$seed ";

if(($command=~/\-run_name (\d+)/))
  {
    $suffix=$1;
  }
else
  {
    $msa=~/([^.]+)/;
    $suffix=$1;
  }
print "-run_name=$suffix\n";


if ( $input eq "seq")
  {
    $seq=$msa;
    $msa="$suffix.prot_msa";
    
    if ($stype eq "cdna")
      {
	$cdna_seq=$seq;
	$clean_cdna_seq=&vtmpnam();
	$seq=&vtmpnam();
	`t_coffee -other_pg seq_reformat -in $cdna_seq -action +clean_cdna >$clean_cdna_seq`;
	`t_coffee -other_pg seq_reformat -in $clean_cdna_seq -action +translate >$seq`;
	
      }

    if (!-e $msa || $recompute)
      {
	print "\n#####   Compute an MSA With $alignpg\n";
	
	if ( $alignpg eq "t_coffee")
	  {`$alignpg $seq -outfile=$msa >/dev/null 2>/dev/null`;}
	elsif ( $alignpg eq "muscle")
	  {
	    `$alignpg -in $seq > $msa 2>/dev/null`;
	  }
	elsif ( $alignpg eq "clustalw")
	  {
	    `$alignpg -infile=$seq -outfile=$msa -quicktree >/dev/null 2>/dev/null`;
	  }
	elsif ( $align eq "mafft")
	  {
	    `$alignpg $seq > $msa >/dev/null 2>/dev/null`;
	  }
	else
	  {
	    `$alignpg -in=$seq -outfile=$msa`;
	  }
      }
    if (!-e $msa)
      {
	print "\nError: $alignpg Could Not produce the MSA $msa [FATAL]\n";
      }

    if ($stype eq "cdna")
      {
	$msa2="$suffix.cdna_msa";
	`t_coffee -other_pg seq_reformat -in $clean_cdna_seq -in2 $msa -action +thread_dna_on_prot_aln -output fasta_aln  >$msa2`;
	$msa=$msa2;
      }
    
    $input="msa";
  }



$seqboot_o=&vtmpnam();
$seqboot_c=&vtmpnam();

$protdist_o=&vtmpnam();
$protdist_c=&vtmpnam();
if ( $input eq "msa")
  {
    if ($tmode eq "nj" || $tmode eq "upgma"){$input="matrix";}
    
    $lmsa= &vtmpnam ();
    `t_coffee -other_pg seq_reformat -in $msa -output phylip_aln > $lmsa`;
    
    if ( -e "outfile"){unlink ("outfile");}
    # run seqboot
  
    if ( $n>1)
      {
	print "Run SeqBoot .....";
	open (F, ">$seqboot_c");
	print F "$lmsa\nR\n$n\nY\n$seed\n";
	close (F);
	`seqboot$exec_extension  < $seqboot_c`;
	if ( -e "outfile"){ print "[OK]\n";}
	else { print "[FAILED]\n";&my_exit (EXIT_FAILURE);}
	`mv outfile $seqboot_o`;
      }
    else
      {
	`cp $lmsa $seqboot_o`;
      }

    if ($rmsa){`cp $seqboot_o $rmsa`;}
    
    if ($tmode eq "nj" || $tmode eq "upgma")
      {
	if ( $stype eq "prot")
	  {
	    # run protdist
	    print "Run Protdist [dmode=$dmode]";
	    if ($dmode eq "kimura")
	      {
		$dmode="P\nP\nP";
	      }
	    else
	      {
		print "\n$dmode is an unknown mode for Protdist [FATAL:msa2bootstrap.pl]\n";
		&my_exit (EXIT_FAILURE);
	      }
	    open (F, ">$protdist_c");
	    if ($n>1){print F "$seqboot_o\n$dmode\nM\nD\n$n\nY\n";}
	    else {printf F "$seqboot_o\n$dmode\nY\n";}
	    close (F);
	    `protdist$exec_extension  < $protdist_c`;
	    if ( -e "outfile"){ print "[OK]\n";}
	    else { print "[FAILED]\n";&my_exit (EXIT_FAILURE);}
	    `mv outfile $protdist_o`;
	 
	  }
	elsif ( $stype eq "cdna" || $stype eq "dna")
	  {
	    print "Run dnadist [dmode=default";
	    open (F, ">$protdist_c");
	    if ($n>1){print F "$seqboot_o\nM\nD\n$n\nY\n";}
	    else {printf F "$seqboot_o\nY\n";}
	    close (F);
	    `protdist$exec_extension  < $protdist_c`;
	    if ( -e "outfile"){ print "[OK]\n";}
	    else { print "[FAILED]\n";&my_exit (EXIT_FAILURE);}
	    `mv outfile $protdist_o`;
	  }
      }
  }
elsif ( $input eq "matrix")
  {
    $protdist_o=&vtmpnam();
    print "MSA: $msa\n";
    `cp $msa $protdist_o`;
    $n=1;
  }





$nb_o=&vtmpnam();
$nb_c=&vtmpnam();
if ($input eq "matrix" && $tmode ne "parsimony" && $tmode ne "ml")
  {
    print "Run neighbor [tmode=$tmode]";

    if ($tmode eq "nj")
      {
	$tmode="\nN\nN";
      }
    elsif ( $tmode eq "upgma")
      {
	$tmode = "\nN";
      }
    else
      {
	print "\n ERROR: $tmode is an unknown tree computation mode\n";
	&my_exit (EXIT_FAILURE);
      }

    open (F, ">$nb_c");
    if ($n>1){print F "$protdist_o$tmode\nM\n$n\n$seed\nY\n";}
    else {print F "$protdist_o$tmode\nY\n";}
    close (F);

    `neighbor$exec_extension  < $nb_c`;
    if ( -e "outtree"){ print "[Neighbor OK]\n";}
    else { print "[FAILED]\n";&my_exit (EXIT_FAILURE);}
    `mv outtree $nb_o`;
    unlink ("outfile");
  }
elsif ($input eq "msa" && $tmode eq "parsimony")
  {
    if ( -e "outfile"){unlink ("outfile");}
    if ( -e "outtree"){unlink ("outtree");}
    
    if ($stype eq "prot")
      {
	print "Run protpars [tmode=$tmode]";
	open (F, ">$nb_c");
	if ($n>1){print F "$seqboot_o\nM\nD\n$n\n$seed\n10\nY\n";}
	else {print F "$seqboot_o\nY\n";}
	close (F);
	`protpars$exec_extension  < $nb_c`;
      }
    elsif ( $stype eq "dna" || $stype eq "cdna")
      {
	print "Run dnapars [tmode=$tmode]";
	open (F, ">$nb_c");
	if ($n>1){print F "$seqboot_o\nM\nD\n$n\n$seed\n10\nY\n";}
	else {print F "$seqboot_o\nY\n";}
	close (F);
	`dnapars$exec_extension  < $nb_c`;
      }
    if ( -e "outtree"){ print "[OK]\n";}
    else { print "[FAILED]\n";&my_exit (EXIT_FAILURE);}
    `mv outtree $nb_o`;
   unlink ("outfile");
  }
elsif ($input eq "msa" && $tmode eq "ml")
  {
    if ( -e "outfile"){unlink ("outfile");}
    if ( -e "outtree"){unlink ("outtree");}
    
    if ($stype eq "prot")
      {
	print "Error: ML impossible with Protein Sequences [ERROR]";
	&my_exit (EXIT_FAILURE);
      }
    elsif ( $stype eq "dna" || $stype eq "cdna")
      {
	print "Run dnaml [tmode=$tmode]";
	open (F, ">$nb_c");
	if ($n>1){print F "$seqboot_o\nM\nD\n$n\n$seed\n10\nY\n";}
	else {print F "$seqboot_o\nY\n";}
	close (F);
	`dnaml$exec_extension  < $nb_c`;
      }
    if ( -e "outtree"){ print "[OK]\n";}
    else { print "[FAILED]\n";&my_exit (EXIT_FAILURE);}
    `mv outtree $nb_o`;
   unlink ("outfile");
  }


else
  {
    `cp $msa $nb_o`;
    $n=2;
  }

if ($rmsa && -e $seqboot_o){print "\nOutput List of $n Replicate MSA: $rmsa\n";`cp $seqboot_o $rmsa`;}
if ($rmat && -e $protdist_o){print "\nOutput List of $n Replicate MATRICES: $rmat\n";`cp $protdist_o $rmat`;}
if ($rtree && -e $nb_o){print "\nOutput List of $n Replicate TREES: $rtree\n";`cp $nb_o $rtree`;}



$con_o=&vtmpnam();
$con_c=&vtmpnam();
if ($n >1)
  {
    print "Run Consense.....";
    open (F, ">$con_c");
    print F "$nb_o\nY\n";
    close (F);
    `consense$exec_extension  < $con_c`;
    if ( -s "outtree"  > 0) { print "[OK]\n";}
    else { print "[FAILED]\n";&my_exit (EXIT_FAILURE);}
    `mv outtree $con_o`;
    unlink ("outfile");
  }
else
  {
    `cp $nb_o $con_o`;
  }


`cp $con_o $out`;
if ( !-e $out)
  {
    print "Tree Computation failed [FAILED]\n";
    &my_exit (EXIT_FAILURE);
  }
elsif ($n>1)
  {
    print "\nOutput Bootstrapped Tree: $out\n";
    $avg=`t_coffee -other_pg seq_reformat -in $out -action +avg_bootstrap`;
    $avg=~s/\n//g;
    print "$avg\n";
  }
else
  {
    print "\nOutput Tree: $out\n";
  }

open (F, "$out");
while (<F>)
  {
    
    $tree.=$_;
  }
close (F);
$tree=~s/\n//g;
print "BPH: $tree\n";


&my_exit (EXIT_SUCCESS);

sub my_exit 
  {
    my $m=@_[0];
    &clean_vtmpnam();
    exit ($m);
  }
sub vtmpnam 
  {
    my $file;


    $ntmp++;
    $file="tmp4msa2bootstrap.$rseed.$$.$ntmp";
    
    push (@tmpfile, $file);
    return $file;
  }
sub clean_vtmpnam 
  {
    my $t;
    foreach $t (@tmpfile)
      {
	if ( -e $t){unlink ($t)};
      }
  }

</content>
</file>
<file>
<stream>output</stream>
<name>tc_generic_method.pl</name>
<content>#!/usr/bin/env perl
use Env;
use FileHandle;
use Cwd;
use File::Path;
use Sys::Hostname;


our $PIDCHILD;
our $ERROR_DONE;
our @TMPFILE_LIST;
our $EXIT_FAILURE=1;
our $EXIT_SUCCESS=0;

our $REFDIR=getcwd;
our $EXIT_SUCCESS=0;
our $EXIT_FAILURE=1;

our $PROGRAM="tc_generic_method.pl";
our $CL=$PROGRAM;

our $CLEAN_EXIT_STARTED;
our $debug_lock=$ENV{"DEBUG_LOCK"};
our $debug_generic_method=$ENV{"DEBUG_GENERIC_METHOD"};
our $LOCKDIR=$ENV{"LOCKDIR_4_TCOFFEE"};
if (!$LOCKDIR){$LOCKDIR=getcwd();}
our $ERRORDIR=$ENV{"ERRORDIR_4_TCOFFEE"};
our $ERRORFILE=$ENV{"ERRORFILE_4_TCOFFEE"};
&set_lock ($$);
if (isshellpid(getppid())){lock4tc(getppid(), "LLOCK", "LSET", "$$\n");}
our %RECODE;
our $RECODE_N;




our $BLAST_MAX_NRUNS=2;
our $COMMAND;
our $PIDCHILD;

$REF_EMAIL="";
$tmp_dir="";
$init_dir="";


$test=0;
if ($test==1)
  {
    $SERVER="NCBI";
    $query=$ARGV[0];
    $hitf=$ARGV[1];
    %s=read_fasta_seq($query);
    @sl=keys(%s);
    &blast_xml2profile ("xx", $s{$sl[0]}{seq},$maxid,$minid,$mincov, $hitf);
    myexit ($EXIT_FAILURE);
  }

foreach $v(@ARGV){$cl.="$v ";}
$COMMAND=$cl;
($mode)=&my_get_opt ( $cl, "-mode=",1,0);

($A)=(&my_get_opt ( $cl, "-name1=",0,0));
($B)=(&my_get_opt ( $cl, "-name2=",0,0));
($TMPDIR)=(&my_get_opt ( $cl, "-tmpdir=",0,0));
($CACHE)=(&my_get_opt ( $cl, "-cache=",0,0));
($SERVER)=((&my_get_opt ( $cl, "-server=",0,0)));
($EMAIL)=((&my_get_opt ( $cl, "-email=",0,0)));

if (!$A){$A="A";}
if (!$B){$B="B";}


if (!$TMPDIR)
  {
    $HOME=$ENV{HOME};
    if ($ENV{TMP_4_TCOFFEE}){$TMPDIR=$ENV{TMP_4_TCOFFEE};}
    else{$TMPDIR="$HOME/.t_coffee/tmp/";}
  }
if ( ! -d $TMPDIR)
  {
    mkdir $TMPDIR;
  }
if ( ! -d $TMPDIR)
  {
    print "ERROR: Could not create temporary dir: $TMPDIR\n";
    myexit ($EXIT_FAILURE);
  }

$EMAIL=~s/XEMAILX/\@/g;
if (!$EMAIL)
  {
    if ($ENV{EMAIL_4_TCOFFEE}){$EMAIL=$ENV{EMAIL_4_TCOFFEE};}
    elsif ($ENV{EMAIL}){$EMAIL=$ENV{EMAIL};}
    else {$EMAIL=$REF_EMAIL;}
  }

($maxid,$minid,$mincov,$trim)=(&my_get_opt ( $cl, "-maxid=",0,0, "-minid=",0,0,"-mincov=",0,0, "-trim=",0,0));
if (!$cl=~/\-maxid\=/){$maxid=95;}
if (!$cl=~/\-minid\=/){$minid=35;}
if (!$cl=~/\-mincov\=/){$mincov=80;}
if (!$cl=~/\-trim\=/){$trim;}




if ($mode eq "seq_msa")
  {
    &seq2msa($mode,&my_get_opt ( $cl, "-infile=",1,1, "-method=",1,2, "-param=",0,0,"-outfile=",1,0, "-database=",0,0));
  }
elsif ( $mode eq "tblastx_msa")
  {
    &seq2tblastx_lib ($mode,&my_get_opt ( $cl, "-infile=",1,1, "-outfile=",1,0));
  }
elsif ( $mode eq "tblastpx_msa")
  {
    &seq2tblastpx_lib ($mode,&my_get_opt ( $cl, "-infile=",1,1, "-outfile=",1,0));
  }
elsif ( $mode eq "thread_pair")
  {
    &seq2thread_pair($mode,&my_get_opt ( $cl, "-infile=",1,1, "-pdbfile1=",1,1, "-method=",1,2,"-param=",0,0, "-outfile=",1,0, ));
  }
elsif ( $mode eq "pdbid_pair")
  {
    &seq2pdbid_pair($mode,&my_get_opt ( $cl, "-pdbfile1=",1,0, "-pdbfile2=",1,0, "-method=",1,2,"-param=",0,0, "-outfile=",1,0, ));
  }
elsif ( $mode eq "pdb_pair")
  {
    &seq2pdb_pair($mode,&my_get_opt ( $cl, "-pdbfile1=",1,1, "-pdbfile2=",1,1, "-method=",1,2,"-param=",0,0, "-outfile=",1,0, ));
  }
elsif ( $mode eq "rnapdb_pair")
{
    &seq2rnapdb_pair($mode,&my_get_opt ( $cl, "-pdbfile1=",1,1, "-pdbfile2=",1,1, "-method=",1,2,"-param=",0,0, "-outfile=",1,0, ));
}
elsif ( $mode eq "profile_pair")
  {
     &seq2profile_pair($mode,&my_get_opt ( $cl, "-profile1=",1,1, "-profile2=",1,1, "-method=",1,2,"-param=",0,0, "-outfile=",1,0 ));
  }
elsif ($mode eq "pdb_template_test")
  {
    &blast2pdb_template_test ($mode,&my_get_opt ( $cl, "-infile=",1,1));

  }
elsif ($mode eq "psi_template_test")
  {
    &psiblast2profile_template_test ($mode,&my_get_opt ( $cl, "-seq=",1,1,"-blast=",1,1));

  }

elsif ( $mode eq "pdb_template")
  {
    &blast2pdb_template ($mode,&my_get_opt ( $cl, "-infile=",1,1, "-database=",1,0, "-method=",1,0, "-outfile=",1,0,"-pdb_type=",1,0));
  }

elsif ( $mode eq "profile_template")
  {

    &seq2profile_template ($mode,&my_get_opt ( $cl, "-infile=",1,1, "-database=",1,0, "-method=",1,0, "-outfile=",1,0));
  }
elsif ( $mode eq "psiprofile_template")
  {
    &seq2profile_template ($mode,&my_get_opt ( $cl, "-infile=",1,1, "-database=",1,0, "-method=",1,0, "-outfile=",1,0));
  }
elsif ( $mode eq "RNA_template")
  {
    &seq2RNA_template ($mode,&my_get_opt ( $cl, "-infile=",1,1,"-pdbfile=",1,1,"-outfile=",1,0));
  }
elsif ( $mode eq "tm_template")
  {
    &seq2tm_template ($mode,&my_get_opt ( $cl, "-infile=",1,1,"-arch=",1,1,"-psv=",1,1, "-outfile=",1,0));
  }
elsif ( $mode eq "psitm_template")
  {
    &seq2tm_template ($mode,&my_get_opt ( $cl, "-infile=",1,1, "-arch=",1,1,"-psv=",1,1, "-outfile=",1,0,"-database=",1,0));
  }
elsif ( $mode eq "ssp_template")
  {
    &seq2ssp_template ($mode,&my_get_opt ( $cl, "-infile=",1,1,"-seq=",1,1,"-obs=",1,1, "-outfile=",1,0));
  }
elsif ( $mode eq "psissp_template")
  {
    &seq2ssp_template ($mode,&my_get_opt ( $cl, "-infile=",1,1,"-seq=",1,1,"-obs=",1,1, "-outfile=",1,0));
  }



else
  {
    myexit(flush_error( "$mode is an unknown mode of tc_generic_method.pl"));
  }
myexit ($EXIT_SUCCESS);


sub seq2ssp_template
  {
  my ($mode, $infile,$gor_seq,$gor_obs,$outfile)=@_;
  my %s, %h;
  my $result;
  my (@profiles);
  &set_temporary_dir ("set",$infile,"seq.pep");
  %s=read_fasta_seq ("seq.pep");


  open (R, ">result.aln");

  #print stdout "\n";
  foreach $seq (keys(%s))
    {

      open (F, ">seqfile");
      $s{$seq}{seq}=uc$s{$seq}{seq};
      print (F ">$s{$seq}{name}\n$s{$seq}{seq}\n");
      close (F);
      $lib_name="$s{$seq}{name}.ssp";
      $lib_name=&clean_file_name ($lib_name);

      if ($mode eq "ssp_template"){&seq2gor_prediction ($s{$seq}{name},$s{$seq}{seq}, "seqfile", $lib_name,$gor_seq, $gor_obs);}
      elsif ($mode eq "psissp_template")
	{
	  &seq2msa_gor_prediction ($s{$seq}{name},$s{$seq}{seq},"seqfile", $lib_name,$gor_seq, $gor_obs);
	}

      if ( !-e $lib_name)
	{
	  myexit(flush_error("GORIV failed to compute the secondary structure of $s{$seq}{name}"));
	  myexit ($EXIT_FAILURE);
	}
      else
	{
	  print stdout "!\tProcess: >$s{$seq}{name} _E_ $lib_name \n";
	  print R ">$s{$seq}{name} _E_ $lib_name\n";
	}
      unshift (@profiles, $lib_name);
    }
  close (R);
  &set_temporary_dir ("unset",$mode, $method,"result.aln",$outfile, @profiles);
}

sub seq2tm_template
  {
  my ($mode,$infile,$arch,$psv,$outfile,$db)=@_;
  my %s, %h;
  my $result;
  my (@profiles);
  &set_temporary_dir ("set",$infile,"seq.pep");
  %s=read_fasta_seq ("seq.pep");


  open (R, ">result.aln");

  #print stdout "\n";
  foreach $seq (keys(%s))
    {
      open (F, ">seqfile");
      print (F ">$s{$seq}{name}\n$s{$seq}{seq}\n");
      close (F);
      $lib_name="$s{$seq}{name}.tmp";
      $lib_name=&clean_file_name ($lib_name);

      if ($mode eq "tm_template")
	{
	  &safe_system ("t_coffee -other_pg fasta_seq2hmmtop_fasta.pl -in=seqfile -out=$lib_name -arch=$arch -psv=$psv");
	}
      elsif ( $mode eq "psitm_template")
	{
	  &seq2msa_tm_prediction ($s{$seq}{name},$s{$seq}{seq}, $db, "seqfile", $lib_name,$arch, $psv);
	}
      if ( !-e $lib_name)
	{
	  myexit(flush_error("hmmtop failed to compute the secondary structure of $s{$seq}{name}"));
	  myexit ($EXIT_FAILURE);
	}
      else
	{
	  print stdout "!\tProcess: >$s{$seq}{name} _T_ $lib_name\n";
	  print R ">$s{$seq}{name} _T_ $lib_name\n";
	}
      unshift (@profiles, $lib_name);
    }
  close (R);
  &set_temporary_dir ("unset",$mode, $method,"result.aln",$outfile, @profiles);
}



sub seq2RNA_template
  {
    
    my ($mode, $infile, $pdbfile, $outfile)=@_;
    my %s, %h ;
    my $result;
    my (@profiles);
    my ($seq_mode, $pdb_mode, $pwd);
    
    #use $seq_mode to estimate the template of sequences WITHOUT a PDB
    #use $pdb_mode to estimate the template of sequences WITH    a PDB

    $seq_mode=$ENV{"SEQ2TEMPLATE4_F_"};
    $pdb_mode=$ENV{"PDB2TEMPLATE4_F_"};
    
    if (!$pdb_mode){$pdb_mode="find_pair-p";}
    if (!$seq_mode){$seq_mode="RNAplfold";}
    
    my $cwd = cwd();
    &set_temporary_dir ("set",$infile,"seq.pep");
    %s=read_fasta_seq ("seq.pep");
    %pdb_template_h = &read_template_file($pdbfile);
    my $pdb_chain;
    
       
    open (R, ">result.aln");
    #print stdout "\n";
    foreach $seq (keys(%s))
      {
	
	open (F, ">seqfile");
	print (F ">$s{$seq}{name}\n$s{$seq}{seq}\n");
	close (F);
	$pdb_chain = $pdb_template_h{$seq};
	$lib_name="$s{$seq}{name}.rfold";
	$lib_name=&clean_file_name ($lib_name);
	if ($pdb_template_h{$seq} eq "")
	  {
	    if    ($seq_mode eq "RNAplfold"){RNAplfold2lib ("seqfile", "$lib_name");}
	    elsif ($seq_mode eq "no"){$lib_name=0;}
	    else
	      {
		myexit(add_error (EXIT_FAILURE,$$,$$,getppid(), "seq2RNA_template failure::method $seq_mode not available for sequences without PDB structures"));
	      }
	  }
	elsif ($pdb_template_h{$seq} ne "")
	  {
	    my $pdbf;
	    if (-e "$cwd/$pdb_chain"){$pdbf="$cwd/$pdb_chain";}
	    else {$pdbf="$CACHE$pdb_chain";}
	    

	    if($pdb_mode eq "x3dna-ssr")
	      {
		x3dnassr2lib ("seqfile", "$pdbf", "$lib_name");
	      }
	    elsif ($pdb_mode eq "find_pair-p")
	      {
		x3dna_find_pair2lib ("seqfile", "$pdbf", "$lib_name", "find_pair -p");
	      }
	    elsif ($pdb_mode eq "find_pair")
	      {
		x3dna_find_pair2lib ("seqfile", "$pdbf", "$lib_name", "find_pair");
	      }
	    elsif ($pdb_mode eq "RNAplfold")
	      {
		RNAplfold2lib ("seqfile", "$lib_name");
	      }
	    elsif ($pdb_mode eq "no"){$lib_name=0;}
	    else
	      {
		myexit(add_error (EXIT_FAILURE,$$,$$,getppid(), "seq2RNA_template failure::Could not find method $pdb_mode"));
	      }
	  }
	if ($lib_name)
	  {
	    print stdout "!\tProcess: >$s{$seq}{name} _F_ $lib_name\n";
	    print R ">$s{$seq}{name} _F_ $lib_name\n";
	    unshift (@profiles, $lib_name);
	  }
      }
    close (R);
    &set_temporary_dir ("unset",$mode, $method,"result.aln",$outfile, @profiles);
  }



sub psiblast2profile_template_test
  {
  my ($mode, $seq,$blast)=@_;
  my %s, %h, ;
  my ($result,$psiblast_output,$profile_name,@profiles);
  my $trim=0;
  my $maxid=100;
  my $minid=0;
  my $mincov=0;
  my $maxcov=100;

  %s=read_fasta_seq ($seq);
  open (R, ">result.aln");

  #print stdout "\n";
  foreach $seq (keys(%s))
    {

      open (F, ">seqfile");
      print (F ">$A\n$s{$seq}{seq}\n");
      close (F);
      $psiblast_output=$blast;
      if ( -e $psiblast_output)
	{
	  %profile=blast_xml2profile($s{$seq}{name}, $s{$seq}{seq},$maxid, $minid,$mincov,$psiblast_output);



	  $profile_name="$s{$seq}{name}.prf";
	  $profile_name=&clean_file_name ($profile_name);
	  unshift (@profiles, $profile_name);
	  output_profile ($profile_name, \%profile, $trim);
	  print stdout "!\tProcess: >$s{$seq}{name} _R_ $profile_name [$profile{n} Seq.] [$SERVER/blast/$db][$CACHE_STATUS]\n";
	  print R ">$s{$seq}{name} _R_ $profile_name\n";
	}
    }
  close (R);

  die;
}
sub seq2profile_template
    {
      my ($mode, $infile, $db, $method, $outfile)=@_;
      if    ($method eq "psiblast"){return psiblast2profile_template ($mode, $infile, $db, $method, $outfile);}
      elsif ($method eq "blastp")   {return psiblast2profile_template ($mode, $infile, $db, $method, $outfile);}
      elsif ($method eq "hh")      {return hh2profile_template ($mode, $infile, $db, $method, $outfile);}
    }

sub psiblast2profile_template
  {
  my ($mode, $infile, $db, $method, $outfile)=@_;
  my %s, %h, ;
  my ($result,$psiblast_output,$profile_name,@profiles);
  &set_temporary_dir ("set",$infile,"seq.pep");
  %s=read_fasta_seq ("seq.pep");
  open (R, ">result.aln");

  #print stdout "\n";
  foreach $seq (keys(%s))
    {
      open (F, ">seqfile");
      print (F ">$A\n$s{$seq}{seq}\n");
      close (F);
      $psiblast_output=&run_blast ($s{$seq}{name},$method, $db, "seqfile","outfile");

      if ( -e $psiblast_output)
	{
	  my %profile=blast_xml2profile($s{$seq}{name}, $s{$seq}{seq},$maxid, $minid,$mincov,$psiblast_output);
	  unlink ($psiblast_output);
	  
	  $profile_name="$s{$seq}{name}.prf";
	  $profile_name=&clean_file_name ($profile_name);
	  unshift (@profiles, $profile_name);
	  output_profile ($profile_name, \%profile, $trim);
	  
	  print stdout "!\tProcess: >$s{$seq}{name} _R_ $profile_name [$profile{n} Seq.] [$SERVER/blast/$db][$CACHE_STATUS]\n";
	  print R ">$s{$seq}{name} _R_ $profile_name\n";
	  
	  
	}
      
    }
  close (R);
  
  

  &set_temporary_dir ("unset",$mode, $method,"result.aln",$outfile, @profiles);
}

sub hh2profile_template
  {

  #for each sequence, build a profile, in FASTA, with ungapped querry on top  
  my ($mode, $infile, $db, $method, $outfile)=@_;
  my %s, %h, ;
  my ($result,$psiblast_output,$profile_name,@profiles);
  &set_temporary_dir ("set",$infile,"seq.pep");
  %s=read_fasta_seq ("seq.pep");
  open (R, ">result.aln");
  
  my $hh=$ENV{"HHSEARCH_4_TCOFFEE"};
  if (!$hh)
    {
      print "ERROR: HHSEARCH_4_TCOFFEE is not set\n";
      myexit ($EXIT_FAILURE);
    }
  
  #print stdout "\n";
  foreach $seq (keys(%s))
    {
      my ($profile_name, $nseq);
      open (F, ">seqfile");
      print (F ">$A\n$s{$seq}{seq}\n");
      close (F);
      
      #This function should input a querry and a database and return as output a fasta MSA with quesry on top
      $profile_name="$s{$seq}{name}.prf";
      $profile_name=&clean_file_name ($profile_name);
      unshift (@profiles, $profile_name);
      
      
      safe_system  ("$hh -name=$s{$seq}{name} -method=search -db=$db -seq=seqfile -outfile=$profile_name");
      if (-e $profile_name){$nseq=fasta2nseq($profile_name);}
      
      print stdout "!\tProcess: >$s{$seq}{name} _R_ $profile_name [$nseq Seq.] [$method/$db][$CACHE_STATUS]\n";
      print R ">$s{$seq}{name} _R_ $profile_name\n";
    }
  close (R);
  &set_temporary_dir ("unset",$mode, $method,"result.aln",$outfile, @profiles);
}

sub blast2pdb_template_test
    {
      my ($mode,$infile)=@_;
      my ($maxid,$minid,$mincov);
      $maxid=100;
      $minid=0;
      $mincov=0;

      print "$infile\n";

      %p=blast_xml2profile($s{$seq}{name}, $s{$seq}{seq},$maxid, $minid,$mincov,$infile);
      $c=1;
      print stdout "!\tProcess: >$s{$seq}{name} [$SERVER/blast/$db][$CACHE_STATUS]\n";
      while (!$found && $c<$p{n})
	{
	  $pdbid=&id2pdbid($p{$c}{identifyer});
	  if ( length ($pdbid)>5){$pdbid=id2pdbid($p{$c}{definition});}

	  if ( length ($pdbid)>5)
	    {
	      myexit(add_error (EXIT_FAILURE,$$,$$,getppid(), "BLAST_FAILURE::Could Not Parse PDBID ($p{$c}{identifyer},$p{$c}{definition})"));
	    }


	  if (!&pdb_is_released($pdbid))
	    {
	      print stdout "\t\t**$pdbid [WARNIG: PDB NOT RELEASED or WITHDRAWN]\n";
	      $c++;
	    }
	  elsif (!&pdb_has_right_type ($pdbid,$type))
	    {
	      my $ptype=&pdb2type ($pdbid);
	      my $etype=&type2etype($type);

	      print stdout "\t\t**$pdbid [$ptype cannot be used (expected: $etype)]\n";
	      $c++;
	    }
	  else
	    {
	      $found=1;
	    }
	}

      if ($found)
	{
	  print stdout "\t\t >$s{$seq}{name} _P_ $pdbid\n";
	}
      else
	{
	  print stdout "\t\t >$s{$seq}{name} No Template Selected\n";
	}
      die;
    }
sub blast2pdb_template
  {
  my ($mode, $infile, $db, $method, $outfile,$type)=@_;
  my %s, %h, ;
  my ($result,$blast_output);
  &set_temporary_dir ("set",$infile,"seq.pep");
  %s=read_fasta_seq ("seq.pep");
  open (R, ">result.aln");


  #print stdout "\n";
  foreach $seq (keys(%s))
    {
      my $c;
      my $found;

      open (F, ">seqfile");
      print (F ">$A\n$s{$seq}{seq}\n");
      close (F);

      $blast_output=&run_blast ($s{$seq}{name},$method, $db, "seqfile","outfile");

      %p=blast_xml2profile($s{$seq}{name}, $s{$seq}{seq},$maxid, $minid,$mincov,$blast_output);
      unlink ($blast_output);

      $c=1;
      print stdout "!\tProcess: >$s{$seq}{name} [$SERVER/blast/$db][$CACHE_STATUS]\n";
      while (!$found && $c<$p{n})
	{
	  $pdbid=&id2pdbid($p{$c}{identifyer});
	  if ( length ($pdbid)>5){$pdbid=id2pdbid($p{$c}{definition});}

	  if ( length ($pdbid)>5)
	    {
	      myexit(add_error (EXIT_FAILURE,$$,$$,getppid(), "BLAST_FAILURE::Could Not Parse PDBID ($p{$c}{identifyer},$p{$c}{definition})"));
	    }


	  if (!&pdb_is_released($pdbid))
	    {
	      print stdout "\t\t**$pdbid [PDB NOT RELEASED or WITHDRAWN]\n";
	      $c++;
	    }
	  elsif (!&pdb_has_right_type ($pdbid,$type))
	    {
	      my $ptype=&pdb2type ($pdbid);
	      my $etype=&type2etype($type);

	      print stdout "\t\t**$pdbid [$ptype cannot be used (expected: $etype)]\n";
	      $c++;
	    }
	  else
	    {
	      $found=1;
	    }
	}

      if ($found)
	{
	  print R ">$s{$seq}{name} _P_ $pdbid\n";
	  print stdout "\t\t >$s{$seq}{name} _P_ $pdbid\n";
	}
      else
	{
	  print R ">$s{$seq}{name}\n";
	  print stdout "\t\t >$s{$seq}{name} No Template Selected\n";
	}
    }
  close (R);
  &set_temporary_dir ("unset",$mode, $method,"result.aln",$outfile);
}
sub type2etype
  {
    my $type=shift;
    my $etype;

    if ( $type=~/n/){$etype.="NMR ";}
    if ( $type=~/d/){$etype.="diffraction ";}
    if ( $type=~/m/){$etype.="model ";}
    return $etype;
  }
sub pdb2type
  {
     my $pdb=shift;
     my $f=vtmpnam();

     my $value= &safe_system ("t_coffee -other_pg extract_from_pdb -model_type $pdb > $f");
     my $r=&file2string ($f);
     chomp($r);
     return $r;
   }
sub pdb_has_right_type
  {
    my $pdb=shift;
    my $type=shift;

    my $f=vtmpnam();

    my $value= &safe_system ("t_coffee -other_pg extract_from_pdb -model_type $pdb > $f");
    my $r=&file2string ($f);
    chomp($r);


    if ( $r eq "NMR" && $type=~/n/){return 1;}
    elsif ( $r eq "diffraction" && $type=~/d/){return 1;}
    elsif ( $r eq "model" && $type=~/m/){return 1;}
    else {return 0;}
  }
sub pdb_is_released
  {
    my $pdb=shift;
    my $f=vtmpnam();

    $value= &safe_system ("t_coffee -other_pg extract_from_pdb -is_released_pdb_name $pdb > $f");
    my $r=&file2string ($f);
    chomp($r);
    return $r;
  }
sub blast_msa
  {
    my ($blast,$infile,$db,$outfile)=@_;
    my ($a, %s1, %s, %qs, %qs1);
    my $seqfile;
    my $SEQ=new FileHandle;
    my $seqfile="seqfile";
    my @txt;


    %s1=&read_fasta_seq ($db);
    %s=&fasta_hash2index_hash(%s1);
    %qs1=&read_fasta_seq ($infile);
    %qs=&fasta_hash2index_hash(%qs1);


    #&safe_system ("formatdb -i $db");
    if ($blast eq "blastp"){&safe_system  ("blastall -i $infile -d $db -m7 -p blastp -o io");}
    elsif ($blast eq "blastn"){&safe_system  ("blastn -query $infile -db $db -outfmt 5 -word_size 4 -out io");}

    &set_blast_type ("io");


    my %FB=&xml2tag_list ("io", "Iteration");
    open (F, ">$outfile");
    print F "! TC_LIB_FORMAT_01\n";
    print F "$s{n}\n";
    for ( my $a=0; $a<$s{n}; $a++)
      {
	print F "$s{$a}{name} $s{$a}{len} $s{$a}{seq}\n";
      }


    for ( my $a=0; $a<$FB{n}; $a++)
      {
	my %p=blast_xml2profile ($qs{$a}{name}, $qs{$a}{seq},100, 0, 0, $FB{$a}{body});
	my $query=$p{0}{name};
	my $i= $s1{$query}{order}+1;
	for (my $b=1; $b<$p{n}; $b++)
	  {
	    my $l=length ($p{$b}{Qseq});
	    my $hit=$p{$b}{definition};
	    my $Qstart=$p{$b}{Qstart};
	    my $Hstart=$p{$b}{Hstart};
	    my $identity=$p{$b}{identity};
	    my @lrQ=split (//,$p{$b}{Qseq});
	    my @lrH=split (//,$p{$b}{Hseq});

	    my $j= $s1{$hit}{order}+1;
	    #if ( $j==$i){next;}
	    printf F "# %d %d\n", $i, $j;
	    #  print  F "\n$p{$b}{Qseq} ($Qstart)\n$p{$b}{Hseq} ($Hstart)";
	    for ($c=0; $c<$l; $c++)
	      {
		my $rQ=$lrQ[$c];
		my $rH=$lrH[$c];
		my $n=0;

		if ($rQ ne "-"){$n++, $Qstart++;}
		if ($rH ne "-"){$n++; $Hstart++;}

		if ( $n==2)
		  {
		    printf F "\t%d %d %d\n", $Qstart-1, $Hstart-1,$identity;
		  }
	      }
	  }
      }
    print F "! SEQ_1_TO_N\n";
    close (F);
    return $output;
  }

sub blast_msa_old
  {
    my ($infile,$outfile)=@_;
    my ($a, %seq);
    %s1=&read_fasta_seq ($infile);
    foreach $s (keys (%s1))
      {
	$i=$s1{$s}{order};
	$s{$i}{name}=$s;
	$s{$i}{seq}=$s1{$s}{seq};
	$s{$i}{len}=length( $s{$i}{seq});
	$s{n}++;
      }
    &safe_system ("formatdb -i $infile");
    &safe_system ("blastall -i $infile -d $infile -m7 -o io");
    &set_blast_type ("io");

    %FB=&xml2tag_list ("io", "Iteration");

    open (F, ">$outfile");
    print F "! TC_LIB_FORMAT_01\n";
    print F "$s{n}\n";
    for ( $a=0; $a<$s{n}; $a++)
      {
	print F "$s{$a}{name} $s{$a}{len} $s{$a}{seq}\n";
      }
    for ( $a=0; $a<$FB{n}; $a++)
      {
	%p=blast_xml2profile ($s{$a}{name}, $s{$a}{seq},100, 0, 0, $FB{$a}{body});
	for ($b=1; $b<$p{n}; $b++)
	  {
	    my $l=length ($p{$b}{Qseq});
	    my $hit=$p{$b}{definition};
	    my $Qstart=$p{$b}{Qstart};
	    my $Hstart=$p{$b}{Hstart};
	    my $identity=$p{$b}{identity};
	    my @lrQ=split (//,$p{$b}{Qseq});
	    my @lrH=split (//,$p{$b}{Hseq});
	    my $i= $s1{$s{$a}{name}}{order}+1;
	    my $j= $s1{$hit}{order}+1;
	    #if ( $j==$i){next;}
	    printf F "# %d %d\n", $i, $j;
	    #  print  F "\n$p{$b}{Qseq} ($Qstart)\n$p{$b}{Hseq} ($Hstart)";
	    for ($c=0; $c<$l; $c++)
	      {
		my $rQ=$lrQ[$c];
		my $rH=$lrH[$c];
		my $n=0;

		if ($rQ ne "-"){$n++, $Qstart++;}
		if ($rH ne "-"){$n++; $Hstart++;}

		if ( $n==2)
		  {
		    printf F "\t%d %d %d\n", $Qstart-1, $Hstart-1,$identity;
		  }
	      }
	  }
      }
    print F "! SEQ_1_TO_N\n";
    close (F);
    return $output;

  }

sub seq2msa
  {
    my ($mode, $infile, $method, $param, $outfile,$database)=@_;
    &set_temporary_dir ("set",$infile,"seq.pep", $database, "db.pep");
    $param.=" >/dev/null 2>&1 ";


    #make sure test.pep is in FASTA
    &safe_system ("t_coffee -other_pg seq_reformat -in seq.pep -output fasta_seq > x");
    `mv x seq.pep`;

    if ( $method eq "blastp")
      {
	&blast_msa ("blastp","seq.pep",$database,"result.aln");
      }
    elsif ( $method eq "blastn")
      {
	&blast_msa ("blastn","seq.pep",$database,"result.aln");
      }

    elsif ( $method eq "muscle")
      {
	`muscle -in seq.pep -out result.aln $param`;
      }
    elsif ( $method eq "probcons")
      {
	`probcons seq.pep >result.aln 2>/dev/null`;
      }
    elsif ( $method eq "mafft")
      {
	`mafft --quiet --localpair --maxiterate 1000 seq.pep> result.aln  2>/dev/null`
      }
    elsif ( $method=~/prank/)
      {
	`$method -d=seq.pep -o=result.aln -quiet 2>/dev/null`;
	`mv result.aln.1.fas result.aln`;
      }
    elsif ($method eq "clustalo")
      {
	`clustalo -i seq.pep > result.aln`;
      }

    else
      {
	`$method -infile=seq.pep -outfile=result.aln`;
      }

    &set_temporary_dir ("unset",$mode, $method,"result.aln",$outfile);
    myexit ($EXIT_SUCCESS);
  }

sub seq2thread_pair
  {
    my ($mode, $infile, $pdbfile1, $method, $param, $outfile)=@_;
    &set_temporary_dir ("set",$infile,"seq.pep",$pdbfile1,"struc.pdb");
    if ($method eq "fugueali")
      {
	#Env Variable that need to be defined for Fugue
	if (!$ENV{FUGUE_LIB_LIST}){$ENV{FUGUE_LIB_LIST}="DUMMY";}
	if (!$ENV{HOMSTRAD_PATH})  {$ENV{HOMSTRAD_PATH}="DUMMY";}
	if (!$ENV{HOMS_PATH}){$ENV{HOMS_PATH}="DUMMY";}

	`joy struc.pdb >x 2>x`;
	&check_file("struc.tem", "Joy failed [FATAL:$PROGRAM/$method]");
	`melody -t struc.tem >x 2>x`;
	&check_file("struc.tem", "Melody failed [FATAL:$PROGRAM/$method]");
	`fugueali -seq seq.pep -prf struc.fug -print > tmp_result.aln`;

	&check_file("tmp_result.aln", "Fugue failed [FATAL:$PROGRAM/$method]");
	&safe_system ("t_coffee -other_pg seq_reformat -in tmp_result.aln -output fasta_aln >result.aln");
      }
    elsif ( $method eq "t_coffee")
      {
	&safe_system ("t_coffee -in Pstruc.pdb Sseq.pep Mslow_pair -outfile result.aln -quiet");
      }
    else
      {
	&safe_system ("$method -infile=seq.pep -pdbfile1=struc.pdb -outfile=result.aln $param>x 2>x");
      }
    &set_temporary_dir ("unset",$mode,$method,"result.aln",$outfile);
    myexit ($EXIT_SUCCESS);
  }
sub seq2pdbid_pair
  {
    my ($mode, $pdbfile1, $pdbfile2, $method, $param, $outfile)=@_;
    my ($name);


    &set_temporary_dir ("set");
    $name=$pdbfile1." ".$pdbfile2;

    if (    &cache_file("GET","","$name","$method","dali",$outfile,"EBI"))
      {return $outfile;}
    else
      {
	if ($method eq "daliweb")
	  {
	    $pdbfile1=~/(....)(.)/;
	    $id1=$1; $c1=$2;

	    $pdbfile2=~/(....)(.)/;
	    $id2=$1; $c2=$2;

	    $command="t_coffee -other_pg dalilite.pl --pdb1 $id1 --chainid1 $c1 --pdb2 $id2 --chainid2 $c2 --email=$EMAIL  >dali_stderr 2>dali_stderr";
	    $dali=`$command`;

	    open (F, "dali_stderr");
	    while (<F>)
	      {
		if ( /JobId: dalilite-(\S+)/)
		{
		  $jobid=$1;
		}
	      }
	    close (F);
	    unlink ("dali_stderr");

	    $output1="dalilite-$jobid.txt";
	    if ( -e $output1)
	      {
		unlink ($output1);
		&url2file ("http://www.ebi.ac.uk/Tools/es/cgi-bin/jobresults.cgi/dalilite/dalilite-$jobid/aln.html", "output2");

		if ( -e "output2")
		  {
		    my ($seq1, $seq2);
		    $seq1=$seq2="";

		    open (F, "output2");
		    while (<F>)
		      {
			$l=$_;
			if ( $l=~/Query\s+(\S+)/)
			  {
			    $seq1.=$1;
			  }
			elsif ( $l=~/Sbjct\s+(\S+)/)
			  {
			    $seq2.=$1;
			  }
		      }
		    close (F);
		    unlink ("output2");
		    if ($seq1 ne "" && $seq2 ne "")
		      {
			$output3=">$A\n$seq1\n>$B\n$seq2\n";
			$output3=~s/\./-/g;
			open (F, ">result.aln");
			print F "$output3";
			close (F);
		      }
		  }
	      }
	  }
      }
    &cache_file("SET","","$name","$method","dali","result.aln","EBI");
    &set_temporary_dir ("unset",$mode, $method, "result.aln",$outfile);
    myexit ($EXIT_SUCCESS);
  }
sub seq2pdb_pair
  {
    my ($mode, $pdbfile1, $pdbfile2, $method, $param, $outfile)=@_;

    &set_temporary_dir ("set",$pdbfile1,"pdb1.pdb",$pdbfile2,"pdb2.pdb");
    if ($method eq "t_coffee")
      {
	&safe_system ("t_coffee -in Ppdb1.pdb Ppdb2.pdb -quiet -outfile=result.aln");
      }
    elsif ( $method eq "DaliLite")
      {
	if ( &safe_system ("DaliLite -pairwise pdb1.pdb pdb2.pdb >tmp1")==$EXIT_SUCCESS)
	  {
	     my ($seq1, $seq2);
	     $seq1=$seq2="";

	     open (F, "tmp1");
	     while (<F>)
	       {
		 $l=$_;
		 if ( $l=~/Query\s+(\S+)/)
		   {
		     $seq1.=$1;
		   }
		 elsif ( $l=~/Sbjct\s+(\S+)/)
		   {
		     $seq2.=$1;
		   }
	       }
	     close (F);
	     unlink ("tmp1");
	     if ($seq1 ne "" && $seq2 ne "")
	       {
		 my $output3=">$A\n$seq1\n>$B\n$seq2\n";
		 $output3=~s/\./-/g;
		 open (F, ">result.aln");
		 print F "$output3";
		 close (F);
	       }
	   }
	else
	  {
	    print "ERROR: DalLite failed to align the considered structures[tc_generic_method.pl]\n";
	  }
      }
    elsif ( $method eq "TMalign")
      {
	if ( &safe_system ("TMalign pdb1.pdb pdb2.pdb >tmp1")==$EXIT_SUCCESS)
	  {
	    `tail -4 tmp1 > tmp2`;

	    open (F, "tmp2");
	    while (<F>)
	      {
		unshift(@l, $_);
	      }
	    close (F);
	    open (F, ">result.aln");
	    $l[3]=~s/[^a-zA-Z0-9-]/\-/g;
	    $l[1]=~s/[^a-zA-Z0-9-]/\-/g;
	    print F ">$A\n$l[3]\n>$B\n$l[1]\n";
	    close (F);
	  }
	else
	  {
	    print "ERROR: TMalign failed to align the considered structures[tc_generic_method.pl]\n";
	    `rm result.aln >/dev/null 2>/dev/null`;
	  }
      }
    elsif ( $method eq "mustang")
      {
	if ( &safe_system ("mustang -i pdb1.pdb pdb2.pdb -F fasta >/dev/null 2>/dev/null")==$EXIT_SUCCESS)
	  {
	    `mv results.afasta result.aln`;
	  }
	else
	  {
	    print "ERROR: mustang failed to align the considered structures[tc_generic_method.pl]\n";
	    `rm result.aln >/dev/null 2>/dev/null`;
	  }
      }
    else
      {
	if ( &safe_system ("$method -pdbfile1=pdb1.pep -pdbfile2=pdb2.pdb -outfile=result.aln $param>x 2>x")==$EXIT_SUCCESS)
	  {
	    `mv results.afasta result.aln`;
	  }
	else
	  {
	    print "ERROR: $method failed to align the considered structures[tc_generic_method.pl]\n";
	    `rm result.aln >/dev/null 2>/dev/null`;
	  }
      }
    &set_temporary_dir ("unset",$mode, $method, "result.aln",$outfile);
    myexit ($EXIT_SUCCESS);
  }

sub seq2rnapdb_pair
  {
    my ($mode, $pdbfile1, $pdbfile2, $method, $param, $outfile)=@_;
    
    if ($method eq "runsara.py")
      {
	my $path=$ENV{PATH};
	
	if ($ENV{X3DNA_4_SARA}){$ENV{PATH}="$ENV{X3DNA_4_SARA}:$path";}
	
	open(TMP,"<$pdbfile1");
	my $count = 0;
	my $line;
	while (<TMP>)
	  {
	    $line = $_;
	    if ($count ==1)
	      {
		last;
	      }
	    $count += 1;
	  }
	
	
	$chain1 = substr($line,length($line)-3,1);
	
	close TMP;
	open(TMP,"<$pdbfile2");
	my $count = 0;
	while (<TMP>)
	  {
	    $line = $_;
	    if ($count ==1)
	      {
		last;
	      }
	    $count += 1;
	  }
	$chain2 = substr($line,length($line)-3,1);
	close TMP;
	
	$tmp_file=&vtmpnam();
	
	safe_system("runsara.py $pdbfile1 $chain1 $pdbfile2 $chain2 -s -o $tmp_file --limitation 5000 > /dev/null 2> /dev/null");
	if ($ENV{X3DNA_4_SARA}){$ENV{PATH}=$path;}
	
	open(TMP,"<$tmp_file") or die "cannot open the sara tmp file:$!\n";
	open(OUT,">$outfile") or die "cannot open the $outfile file:$!\n";
	
	my $switch = 0;
	my $seqNum = 0;
	foreach my $line (<TMP>)
	  {
	    next unless ($line=~/SARAALI/);
	    if ($line=~/>/)
	      {
		$switch =0;
		print OUT ">seq$seqNum\n";
		$seqNum++;
	      }
	    if ($switch < 2){
	      $switch++;
	      next;
	    }
	    
	    if ($line =~/REMARK\s+SARAALI\s+([^\*]+)\*/)
	      {
		my $string = $1;
		print OUT "$string\n";
	      }
	  }
	close TMP;
	close OUT;
	unlink($tmp_file);
      }
  }
sub seq2profile_pair
  {
    my ($mode, $profile1, $profile2, $method, $param, $outfile)=@_;
    
    
    if ($method eq "clustalw")
      {
	`clustalw -profile1=$profile1 -profile2=$profile2 -outfile=$outfile`;
      }
    elsif ( $method eq "clustalo")
      {
	
	`clustalo --p1 $profile1 --p2 $profile2 -o $outfile --force`;
      }
    elsif ( $method eq "hhalign")
      {
	hhalign ( $profile1,$profile2,$outfile,$param);
      }
    else
      {
	`$method -profile1=$profile1 -profile2=$profile2 -outfile=$outfile $param> /dev/null 2>/dev/null`;
      }
    myexit ($EXIT_SUCCESS);
  }

sub pg_is_installed
  {
    my @ml=@_;
    my ($r, $p, $m);
    my $supported=0;

    my $p=shift (@ml);
    if ($p=~/::/)
      {
	if (safe_system ("perl -M$p -e 1")==$EXIT_SUCCESS){return 1;}
	else {return 0;}
      }
    else
      {
	$r=`which $p 2>/dev/null`;
	if ($r eq ""){$r=0;}
	else {$r=1;}

	if ($r==0 && is_blast_package ($p)){return pg_is_installed ("legacy_blast.pl");}
	else {return $r;}
      }
  }

sub is_blast_package
  {
    my $p=shift;
    if ( $p=~/blastp/){return 1;}
    elsif ($p=~/blastall/){return 1;}
    elsif ($p=~/blastn/){return 1;}
    elsif ($p=~/blastx/){return 1;}
    elsif ($p=~/formatdb/){return 1;}
    else {return 0;}
  }

sub check_internet_connection
  {
    my $internet;
    my $tmp;
    &check_configuration ( "wget");

    $tmp=&vtmpnam ();

    if     (&pg_is_installed    ("wget")){`wget www.google.com -O$tmp >/dev/null 2>/dev/null`;}
    elsif  (&pg_is_installed    ("curl")){`curl www.google.com -o$tmp >/dev/null 2>/dev/null`;}

    if ( !-e $tmp || -s $tmp < 10){$internet=0;}
    else {$internet=1;}
    if (-e $tmp){unlink $tmp;}

    return $internet;
  }
sub check_pg_is_installed
  {
    my @ml=@_;
    my $r=&pg_is_installed (@ml);
    if (!$r && $p=~/::/)
      {
	print STDERR "\nYou Must Install the perl package $p on your system.\nRUN:\n\tsudo perl -MCPAN -e 'install $pg'\n";
      }
    elsif (!$r)
      {
	myexit(flush_error("\nProgram $p Supported but Not Installed on your system"));
      }
    else
      {
	return 1;
      }
  }
sub set_temporary_dir
  {
    my @list=@_;
    my $dir_mode, $a, $mode, $method;

    $dir_mode=shift (@list);


    if ( $dir_mode eq "set")
      {
	$initial_dir=cwd();
	if ( !$tmp_dir)
	  {
	    $rand=rand (100000);
	    $tmp_dir="$TMPDIR/tmp4tcoffee_profile_pair_dir_$$\_P_$rand";
	  }
	if ( !-d $tmp_dir)
	  {
	    push (@TMPDIR_LIST, $tmp_dir);
	    `mkdir $tmp_dir`;
	  }

	for ( $a=0; $a<=$#list; $a+=2)
	      {
		if (-e $list[$a]){ `cp $list[$a] $tmp_dir/$list[$a+1]`;}
	      }
	chdir $tmp_dir;
      }
    elsif ( $dir_mode eq "unset")
      {
	$mode=shift (@list);
	$method=shift (@list);

	if (!-e $list[0])
	  {
	   myexit(flush_error("Program $method failed to produce $list[1]" ));
	    myexit ($EXIT_FAILURE);
	  }
	else
	  {
	    chdir $initial_dir;
	    # `t_coffee -other_pg seq_reformat -in $tmp_dir/$list[0] -output fasta_aln -out $tmp_dir/result2.aln`;
	    `cp $tmp_dir/$list[0] $tmp_dir/result2.aln`;
	    if ( $list[1] eq "stdout")
	      {
		open (F, "$tmp_dir/result2.aln");
		while (<F>){print $_;}close(F);
	      }
	    else
	      {
		`mv $tmp_dir/result2.aln $list[1]`;
	      }
	    shift (@list); shift (@list);
	    foreach $f (@list)
	      {
		if (-e ("$tmp_dir/$f")){`mv $tmp_dir/$f .`;}
	      }
	  }
      }
  }




sub my_get_opt
  {
    my @list=@_;
    my ($cl, $a, $argv, @argl);

    
    @argl=();
    $cl=shift @list;
    for ( my $a=0; $a<=$#list; $a+=3)
      {
	my $option=$list[$a];
	my $optional=$list[$a+1];
	my $status=$list[$a+2];
	my $argv="";
	if ($cl=~/$option(\S+)/){$argv=$1;}
	@argl=(@argl,$argv);


	#$optional:0=>optional
	#$optional:1=>must be set
	#$status: 0=>no requirement
	#$status: 1=>must be an existing file
	#$status: 2=>must be an installed package
	

	if ($optional==0){;}
	elsif ( $optional==1 && $argv eq "")
	  {
	    myexit(flush_error( "ERROR: Option $option must be set"));
	    myexit ($EXIT_FAILURE);
	  }
	if ($status==0){;}
	elsif ($status ==1 && $argv ne "" && !-e $argv)
	  {
	    myexit(flush_error( "File [$argv] must exist"));
	    myexit ($EXIT_FAILURE);
	  }
	elsif ( $status==2 && $argv ne "" && &check_pg_is_installed ($argv)==0)
	  {
	    myexit(flush_error( " $argv is not installed"));
	    myexit ($EXIT_FAILURE);
	  }
      }
    return @argl;
    }

sub check_file
  {
    my ($file, $msg)=@_;

    if ( !-e $file)
      {
	myexit(flush_error("$msg"));
      }
    }
sub hhalign
  {
    my ($aln1, $aln2, $outfile, $param)=@_;
    my $hh=$ENV{"HHALIGN_4_TCOFFEE"};
    
    
    if ($hh)
      {
	
	#external_hhalign
	# set via HHALIGN_4_TCOFFEE
	#<pg> -profile1 <fasta_prf with seq1 top> -profile2 <fasta profile with seq2 top> -outfile < fasta alignmentof seq1 and 2 | tc_lib of seq 1 and 2>
	
	safe_system ("$hh -method=align -profile1=$aln1 -profile2=$aln2 -outfile=$outfile");
      }
    else
      {
	&local_hhalign ($aln1, $aln2, $outfile, $param);
      }
  }

    
    
sub local_hhalign
  {
    my ($aln1, $aln2, $outfile, $param)=@_;
    my $h1, $h2;

    $h{0}{index}=0;
    $h{1}{index}=1;

    $h{0}{aln}=$aln1;
    $h{1}{aln}=$aln2;



    %{$h{0}}=aln2psi_profile (%{$h{0}});
    %{$h{1}}=aln2psi_profile (%{$h{1}});

    $param=~s/#S/ /g;
    $param=~s/#M/\-/g;
    $param=~s/#E/\=/g;



    $command="hhalign -i $h{0}{a3m} -t $h{1}{a3m} -tc $outfile.tmp -rank 1 -mapt 0 $param";
    `$command`;

  #  `hhalign -i $h{0}{a3m} -t $h{1}{a3m} -tc $outfile.tmp -rank 1 -mapt 0 -gapf 0.8 -gapg 0.8`;


    # To run global use the following

    open (I, "$outfile.tmp");
    open (O, ">$outfile");
    $h{0}{cons}=s/\./x/g;
    $h{1}{cons}=s/\./x/g;

    print O "! TC_LIB_FORMAT_01\n2\n$h{0}{name} $h{0}{len} $h{0}{seq}\n$h{1}{name} $h{1}{len} $h{1}{seq}\n#1 2\n";

    while (<I>)
      {
	if (/(\d+)\s+(\d+)\s+(\d+)/)
	  {
	    print O "\t$h{0}{$1}\t$h{1}{$2}\t$3\n";
	  }
      }
    print O "! SEQ_1_TO_N\n";

    close (O);
    close (I);
  }

sub aln2psi_profile
  {
    my (%h)=@_;
    my ($aln,$i,$hv, $a, @c, $n);


    $i=$h{index};
    $aln=$h{aln};

    `cp $aln $$.hhh_aln`;
    $command="t_coffee -other_pg seq_reformat -in $aln -output hasch";
    $hv=`$command`;chomp ($hv);

    $h{a2m}="$tmp/$hv.tmp4hhpred.a2m";
    $h{a3m}="$tmp/$hv.tmp4hhpred.a3m";
    if ( -e $h{a3m}){;}
    else
      {
	$x=`which hhconsensus`;
	`hhconsensus  -M 50 -i $h{aln} -oa2m $h{a2m}`;
	if (!-e $h{a2m})
	  {
	    print STDERR "Program tc_generic_method.pl FAILED to run:\n\thhconsensus  -M 50 -i $h{aln} -oa2m $h{a2m}";
	    myexit ($EXIT_FAILURE);
	  }

	`hhconsensus  -M 50 -i $h{aln} -oa3m $h{a3m}`;
	if (!-e $h{a3m})
	  {
	    print STDERR "Program tc_generic_method.pl FAILED to run:\n\thhconsensus  -M 50 -i $h{aln} -oa3m $h{a3m}";
	    myexit ($EXIT_FAILURE);
	  }
       `buildali.pl $h{a3m} -n 1`;
      }


    $h{a2m_seq}=`head -n 2 $h{a2m} | grep -v ">"`;chomp ($h{a2m_seq});
    $h{a3m_seq}=`head -n 2 $h{a3m} | grep -v ">"`;chomp ($h{a3m_seq});
    $h{cons}=$h{a2m_seq};
    $h{seq}=`head -n 2 $h{aln} | grep -v ">"`;chomp ($h{seq});



    @c=split (//, $h{cons});
    $h{len}=$#c+1;
    for ($n=0,$a=0, $b=0; $a<$h{len};$a++)
      {
	if ( $c[$a]=~/[A-Z]/)
	  {
	    $h{++$n}=++$b;

	  }
	elsif ( $c[$a]=~/[a-z\.]/)
	  {
	    ++$b;
	  }
      }

    $name=`head -n 2 $h{aln} | grep ">"`;
    $name=~/\>(\S+)/;
    $h{name}=$1;

    `cp $h{a2m} $i.a2m`;
    `cp $h{a3m} $i.a3m`;
    `cp $h{aln} $i.hh_aln`;

    return %h;
  }
sub read_fasta_seq_index
  {
    my $f=@_[0];
    my %hseq;
    my (@seq, @com, @name);
    my ($a, $s,$nseq);

    open (F, $f);
    while (<F>)
      {
	$s.=$_;
      }
    close (F);


    @name=($s=~/>(\S*).*\n[^>]*/g);

    @seq =($s=~/>.*.*\n([^>]*)/g);
    @com =($s=~/>\S*(.*)\n([^>]*)/g);


    $nseq=$#name+1;

    for ($a=0; $a<$nseq; $a++)
      {
	my $s;
	my $n=$name[$a];
	$hseq{$a}{name}=$n;
	$seq[$a]=~s/[^A-Za-z]//g;
	$hseq{$a}{order}=$a;
	$hseq{$a}{seq}=$seq[$a];
	$hseq{$a}{com}=$com[$a];

      }
    return %hseq;
  }
sub read_fasta_seq
  {
    my $f=@_[0];
    my %hseq;
    my (@seq, @com, @name);
    my ($a, $s,$nseq);

    open (F, $f);
    while (<F>)
      {
	$s.=$_;
      }
    close (F);


    @name=($s=~/>(\S*).*\n[^>]*/g);

    @seq =($s=~/>.*.*\n([^>]*)/g);
    @com =($s=~/>\S*(.*)\n([^>]*)/g);


    $nseq=$#name+1;

    for ($a=0; $a<$nseq; $a++)
      {
	my $s;
	my $n=$name[$a];
	$hseq{$n}{name}=$n;
	$seq[$a]=~s/[^A-Za-z]//g;
	$hseq{$n}{order}=$a;
	$hseq{$n}{seq}=$seq[$a];
	$hseq{$n}{com}=$com[$a];

      }
    return %hseq;
  }


sub read_fasta_aln
  {
    my $f=@_[0];
    my %hseq;
    my (@seq, @com, @name);
    my ($a, $s,$nseq);

    open (F, $f);
    while (<F>)
      {
	$s.=$_;
      }
    close (F);


    @name=($s=~/>(\S*).*\n[^>]*/g);

    @seq =($s=~/>.*.*\n([^>]*)/g);
    @com =($s=~/>\S*(.*)\n([^>]*)/g);


    $nseq=$#name+1;

    for ($a=0; $a<$nseq; $a++)
      {
	my $s;
	my $n=$name[$a];
	$hseq{$n}{name}=$n;
	$seq[$a]=~s/[^A-Za-z-.()[\]]//g;
	$hseq{$n}{order}=$a;
	$hseq{$n}{seq}=$seq[$a];
	$hseq{$n}{com}=$com[$a];

      }
    return %hseq;
  }

sub recode_name2
{
	my ($in)=shift;
	my $mode=shift;

	my %seq;
	my $new_name;

	if (! -e $in){return;}

	#needed by ClustalOmega to avoid very long names
	open (INFILE, "+<$in");

	my $line;

	if ($mode eq "code")
	{
		chomp($line = <INFILE>);
		my $line_length = length($line);
		$new_name=++$RECODE_N;
		$new_name=">$new_name";
		my $new_length = length($new_name);
		$RECODE {$new_name}=$line;
		for ($count = $new_length; $count < $line_length; $count++)
		{
			$new_name .= " ";
		}
		$new_name="$new_name\n";
		seek INFILE, 0, 0
			or die "could not seek: $!";
		print INFILE "$new_name";
	}
	else
	{
		my $n_found = 0;
		my $file_pos=0;
		$file_pos=tell INFILE;
		while (<INFILE>)
		{
			$line=$_;
			$line =~ s/\s*$//;

			$old_name= $RECODE{$line};
			if ($old_name ne "")
			{
				seek INFILE, $file_pos, 0
					or die "could not seek: $!";
				print INFILE "$old_name\n";
				$file_pos++;
				if ($file_pos == 2)
				{
					print "stop\n";
					break;
				}
			}
			$file_pos=tell INFILE;
		}

	}


	close INFILE;
}


sub recode_name
{
	my ($in)=shift;
	my $mode=shift;
	my $f=new FileHandle;
	my %seq;
	my $new_name;

	if (! -e $in){return;}

	#needed by ClustalOmega to avoid very long names
	%seq=read_fasta_aln ($in);

	open ($f, ">$in");
	foreach my $s (keys(%seq))
	{
		if ($mode eq "code")
		{
			$new_name=++$RECODE_N;
			$RECODE {$new_name}=$seq{$s}{name};
		}
		else
		{
			$new_name=$RECODE{$seq{$s}{name}};
		}
		print $f ">$new_name\n$seq{$s}{seq}\n";
	}
	close $f;
}

sub fasta_hash2index_hash
  {
    my %s1=@_;
    my %s;
    foreach my $s (keys (%s1))
      {
	my $i=$s1{$s}{order};
	$s{$i}{name}=$s;
	$s{$i}{seq}=$s1{$s}{seq};
	$s{$i}{len}=length( $s{$i}{seq});
	$s{n}++;
      }
    return %s;
  }
sub file_contains
  {
    my ($file, $tag, $max)=(@_);
    my ($n);
    $n=0;

    if ( !-e $file && ($file =~/$tag/)) {return 1;}
    elsif ( !-e $file){return 0;}
    else
      {
	open (FC, "$file");
	while ( <FC>)
	  {
	    if ( ($_=~/$tag/))
	      {
		close (FC);
		return 1;
	      }
	    elsif ($max && $n>$max)
	      {
		close (FC);
		return 0;
	      }
	    $n++;
	  }
      }
    close (FC);
    return 0;
  }


sub file2string
  {
    my $f=@_[0];
    my $string, $l;
    open (F,"$f");
    while (<F>)
      {

	$l=$_;
	#chomp ($l);
	$string.=$l;
      }
    close (F);
    $string=~s/\r\n//g;
    $string=~s/\n//g;
    return $string;
  }


sub tag2value
  {

    my $tag=(@_[0]);
    my $word=(@_[1]);
    my $return;

    $tag=~/$word="([^"]+)"/;
    $return=$1;
    return $return;
  }

sub hit_tag2pdbid
  {
    my $tag=(@_[0]);
    my $pdbid;

    $tag=~/id="(\S+)"/;
    $pdbid=$1;
    $pdbid=~s/_//;
    return $pdbid;
  }
sub id2pdbid
  {
    my $in=@_[0];
    my $id;

    $in=~/(\S+)/;
    $id=$in;
    $id=~s/PDB/pdb/g;

    if ($id =~/pdb(.*)/){$id=$1;}
    elsif ( $id=~/(\S+)\s+mol:protein/){$id=$1;}
    $id=~s/[:|_]//g;
    return $id;
  }
sub set_blast_type
  {
    my $file =@_[0];
    if (&file_contains ($file,"EBIApplicationResult",100)){$BLAST_TYPE="EBI";}
    elsif (&file_contains ($file,"NCBI_BlastOutput",100)) {$BLAST_TYPE="NCBI";}
    else
      {
	$BLAST_TYPE="";
      }
    return $BLAST_TYPE;
  }
sub is_valid_blast_xml
    {
      my $file=shift;
      my $line;


      if ( !-e $file) {return 0;}
      $line=&file2tail ($file,100);

      if ( $line=~/<\/EBIApplicationResult/ || $line=~/<\/NCBI_BlastOutput/ || $line=~/<\/BlastOutput/ ){return 1;}
      return 0;
    }
sub file2blast_flavor
      {
	my $file=shift;
	if (&file_contains ($file,"EBIApplicationResult",100)){return "EBI";}
	elsif (&file_contains ($file,"NCBI_BlastOutput",100)){return "NCBI";}
	else {return "UNKNOWN";}
      }
sub blast_xml2profile
  {
    my ($name,$seq,$maxid, $minid, $mincov, $file)=(@_);
    my (%p, $a, $string, $n);



    if ($BLAST_TYPE eq "EBI" || &file_contains ($file,"EBIApplicationResult",100)){%p=ebi_blast_xml2profile(@_);}
    elsif ($BLAST_TYPE eq "NCBI" || &file_contains ($file,"NCBI_BlastOutput",100)){%p=ncbi_blast_xml2profile(@_);}
    else
      {
	myexit(add_error ( $$,$$,getppid(), "BLAST_FAILURE::unkown XML",$CL));
      }
    for ($a=0; $a<$p{n}; $a++)
      {
	my $name=$p{$a}{name};
	$p{$name}{seq}=$p{$a}{seq};
	$p{$name}{index}=$a;
      }
    return %p;
  }
sub ncbi_tblastx_xml2lib_file
  {
    my  ($outlib,$string)=(@_);
    my ($L,$l, $a,$b,$c,$d,$i,$nhits,@identifyerL);
    my (%ITERATION);

    open (F, ">>$outlib");

    $seq=~s/[^a-zA-Z]//g;
    $L=length ($seq);

    %ITERATION=xml2tag_list ($string, "Iteration");
    for ($i=0; $i<$ITERATION{n};$i++)
      {
	my ($qindex, $qlen, %hit, $string);
	$string=$ITERATION{$i}{body};

	$qindex=xmltag2value($string,"Iteration_iter-num");
	$qlen  =xmltag2value($string,"Iteration_query-len");
	%hit=&xml2tag_list  ($string, "Hit");

	for ($a=0; $a<$hit{n}; $a++)
	  {
	    my ($string);
	    $string=$hit{$a}{body};

	    $hindex=xmltag2value($string,"Hit_accession")+1;
	    if ($hindex<=$qindex){next;}
	    else  {print F  "# $qindex $hindex\n";}


	    $hlen=xmltag2value  ($string,"Hit_len");
	    %HSP=&xml2tag_list  ($string, "Hsp");

	    for ($b=0; $b<$HSP{n}; $b++)
	      {
		my ($string, $qs,$qe,$qf,$hs,$he,$hf,$s, $d, $e);
		$string=$HSP{$b}{body};

		$qs=xmltag2value  ($string,"Hsp_query-from");
		$qe=xmltag2value  ($string,"Hsp_query-to");
		$qf=xmltag2value  ($string,"Hsp_query-frame");

		$hs=xmltag2value  ($string,"Hsp_hit-from");
		$he=xmltag2value  ($string,"Hsp_hit-to");
		$hf=xmltag2value  ($string,"Hsp_hit-frame");

		$s=xmltag2value  ($string,"Hsp_identity");
		$l=xmltag2value  ($string,"Hsp_align-len");
		$s=int(($s*100)/$l);

		if ($qf>0)
		  {$rqs=$qs; $rqe=$qe;}
		else
		  {
		    $rqe=($qlen-$qs)+1;
		    $rqs=($qlen-$qe)+1;
		  }

		if ($hf>0)
		  {$rhs=$hs; $rhe=$he;}
		else
		  {
		    $rhe=($hlen-$hs)+1;
		    $rhs=($hlen-$he)+1;
		  }
		for ($d=0,$e=$rqs; $e<$rqe; $e++,$d++)
		  {
		    my ($r1,$r2);
		    $r1=$e;
		    $r2=$rhs+$d;
		    print F " $r1 $r2 $s 0\n";
		  }
	      }
	  }
      }
    print F "! SEQ_1_TO_N\n";

    close (F);
    return %lib;
  }

sub ncbi_tblastpx_xml2lib_file
  {
    my  ($outlib,$string,%s)=(@_);
    my ($L,$l, $a,$b,$c,$d,$i,$nhits,@identifyerL);
    my (%ITERATION,%hdes, %qdes);

    open (F, ">>$outlib");

    $seq=~s/[^a-zA-Z]//g;
    $L=length ($seq);

    %ITERATION=xml2tag_list ($string, "Iteration");
    for ($i=0; $i<$ITERATION{n};$i++)
      {
	my ($qindex, $qlen, %hit, $string);
	$string=$ITERATION{$i}{body};

	$qdef=xmltag2value($string,"Iteration_query-def");
	%qdes=&tblastpx_name2description($qdef,%s);
	$qlen  =xmltag2value($string,"Iteration_query-len");
	%hit=&xml2tag_list  ($string, "Hit");

	for ($a=0; $a<$hit{n}; $a++)
	  {
	    my ($string);
	    $string=$hit{$a}{body};
	    $hdef=xmltag2value($string,"Hit_def");
	    %hdes=&tblastpx_name2description($hdef,%s);
	    if ($hdes{index}<=$qdes{index}){next;}
	    else  {print F  "# $qdes{index} $hdes{index}\n";}


	    $hlen=xmltag2value  ($string,"Hit_len");
	    %HSP=&xml2tag_list  ($string, "Hsp");

	    for ($b=0; $b<$HSP{n}; $b++)
	      {
		my ($string, $l,$qs,$qe,$qf,$hs,$he,$hf,$s, $d, $e, @s1, @s2);
		$string=$HSP{$b}{body};

		$qs=xmltag2value  ($string,"Hsp_query-from");
		$qe=xmltag2value  ($string,"Hsp_query-to");
		$qf=$qdes{frame};
		$qseq=xmltag2value  ($string,"Hsp_qseq");

		$hs=xmltag2value  ($string,"Hsp_hit-from");
		$he=xmltag2value  ($string,"Hsp_hit-to");
		$hf=$hdes{frame};
		$hseq=xmltag2value  ($string,"Hsp_hseq");

		$s=xmltag2value  ($string,"Hsp_identity");
		$l=xmltag2value  ($string,"Hsp_align-len");
		$s=int(($s*100)/$l);
		@s1=tblastpx_hsp2coordinates($qseq,$qs,$qe,%qdes);
		@s2=tblastpx_hsp2coordinates($hseq,$hs,$he,%hdes);


		for ($f=0; $f<=$#s1; $f++)
		  {
		    if ($s1[$f]==-1 || $s2[$f]==-1){next;}
		    else
		      {
			print F " $s1[$f] $s2[$f] $s 0\n";
		      }
		  }
	      }
	  }
      }
    print F "! SEQ_1_TO_N\n";

    close (F);
    return %lib;
  }
sub tblastpx_hsp2coordinates
  {
    my ($seq, $s, $e, %des)=@_;
    my @list;
    my @sa;
    my @gap=(-1,-1,-1);

    $s=$des{start}+3*($s-1);

    if ($des{strand} eq "d"){;}
    else {$s=($des{length}-$s)+1;}

    foreach $c (split (//,$seq))
      {
	if ( $c eq '-'){push (@list,@gap);}
	elsif ($des{strand} eq "d")
	  {
	    push(@list,$s++,$s++,$s++);
	  }
	else
	  {
	    push(@list, $s--,$s--,$s--);
	  }
      }
    return @list;
  }

sub tblastpx_name2description
  {
    my ($name, %s)=@_;
    my @at=split("__", $name);
    my %des;

    $des{name}=$at[0];
    $des{strand}=$at[1];

    $des{start}=$at[2];
    $des{end}=$at[3];
    $des{length}=$at[4];
    $des{index}=$s{$at[0]}{order}+1;
    return %des;
  }
sub ncbi_blast_xml2profile
  {
    my ($name,$seq,$maxid, $minid, $mincov, $string)=(@_);
    my ($L,$l, $a,$b,$c,$d,$nhits,@identifyerL);


    $seq=~s/[^a-zA-Z]//g;
    $L=length ($seq);

    #This is causing the NCBI parser to fail when Iteration_query-def is missing
    #%query=&xml2tag_list ($string, "Iteration_query-def");
    #$name=$query{0}{body};

    %hit=&xml2tag_list ($string, "Hit");


    for ($nhits=0,$a=0; $a<$hit{n}; $a++)
      {
	my ($ldb,$id, $identity, $expectation, $start, $end, $coverage, $r);
	my (%ID,%DE,%HSP);

	$ldb="";

	%ID=&xml2tag_list ($hit{$a}{body}, "Hit_id");
	$identifyer=$ID{0}{body};

	%DE=&xml2tag_list ($hit{$a}{body}, "Hit_def");
	$definition=$DE{0}{body};

	%HSP=&xml2tag_list ($hit{$a}{body}, "Hsp");
	for ($b=0; $b<$HSP{n}; $b++)
	  {
	    my (%START,%END,%E,%I,%Q,%M);


	    %START=&xml2tag_list ($HSP{$b}{body}, "Hsp_query-from");
	    %HSTART=&xml2tag_list ($HSP{$b}{body}, "Hsp_hit-from");

	    %LEN=  &xml2tag_list ($HSP{$b}{body}, "Hsp_align-len");
	    %END=  &xml2tag_list ($HSP{$b}{body}, "Hsp_query-to");
	    %HEND=  &xml2tag_list ($HSP{$b}{body}, "Hsp_hit-to");
	    %E=&xml2tag_list     ($HSP{$b}{body}, "Hsp_evalue");
	    %I=&xml2tag_list     ($HSP{$b}{body}, "Hsp_identity");
	    %Q=&xml2tag_list     ($HSP{$b}{body}, "Hsp_qseq");
	    %M=&xml2tag_list     ($HSP{$b}{body}, "Hsp_hseq");

	    for ($e=0; $e<$Q{n}; $e++)

	      {
		$qs=$Q{$e}{body};
		$ms=$M{$e}{body};

		$expectation=$E{$e}{body};
		$identity=($LEN{$e}{body}==0)?0:$I{$e}{body}/$LEN{$e}{body}*100;
		$start=$START{$e}{body};
		$end=$END{$e}{body};
		$Hstart=$HSTART{$e}{body};
		$Hend=$HEND{$e}{body};

		$coverage=($L)?(($end-$start)*100)/$L:0;

		if ($identity>$maxid || $identity<$minid || $coverage<$mincov){next;}
		@lr1=(split (//,$qs));
		@lr2=(split (//,$ms));
		$l=$#lr1+1;
		for ($c=0;$c<$L;$c++){$p[$nhits][$c]="-";}
		for ($d=0,$c=0; $c<$l; $c++)
		  {
		    $r=$lr1[$c];
		    if ( $r=~/[A-Za-z]/)
		      {

			$p[$nhits][$d + $start-1]=$lr2[$c];
			$d++;
		      }
		  }
		$Qseq[$nhits]=$qs;
		$Hseq[$nhits]=$ms;
		$QstartL[$nhits]=$start;
		$HstartL[$nhits]=$Hstart;
		$identityL[$nhits]=$identity;
		$endL[$nhits]=$end;
		$definitionL[$nhits]=$definition;
		$identifyerL[$nhits]=$identifyer;
		$comment[$nhits]="$ldb|$identifyer [Eval=$expectation][id=$identity%][start=$Hstart end=$Hend]";
		$nhits++;
	      }
	  }
      }


    $profile{n}=0;
    $profile{$profile{n}}{name}=$name;
    $profile{$profile{n}}{seq}=$seq;
    $profile {n}++;

    for ($a=0; $a<$nhits; $a++)
      {
	$n=$a+1;

	$profile{$n}{name}="$name\_$a";
	$profile{$n}{seq}="";
	$profile{$n}{Qseq}=$Qseq[$a];
	$profile{$n}{Hseq}=$Hseq[$a];
	$profile{$n}{Qstart}=$QstartL[$a];
	$profile{$n}{Hstart}=$HstartL[$a];
	$profile{$n}{identity}=$identityL[$a];
	$profile{$n}{definition}=$definitionL[$a];
	$profile{$n}{identifyer}=$identifyerL[$a];
	$profile{$n}{comment}=$comment[$a];

	for ($b=0; $b<$L; $b++)
	  {
	    if ($p[$a][$b])
	      {
		$profile{$n}{seq}.=$p[$a][$b];
	      }
	    else
	      {
		$profile{$n}{seq}.="-";
	      }
	  }
      }

    $profile{n}=$nhits+1;
    return %profile;
  }
sub ebi_blast_xml2profile
  {
    my ($name,$seq,$maxid, $minid, $mincov, $string)=(@_);
    my ($L,$l, $a,$b,$c,$d,$nhits,@identifyerL,$identifyer);



    $seq=~s/[^a-zA-Z]//g;
    $L=length ($seq);
    %hit=&xml2tag_list ($string, "hit");

    for ($nhits=0,$a=0; $a<$hit{n}; $a++)
      {
	my ($ldb,$id, $identity, $expectation, $start, $end, $coverage, $r);
	my (%Q,%M,%E,%I);

	$ldb=&tag2value ($hit{$a}{open}, "database");
	$identifyer=&tag2value ($hit{$a}{open}, "id");

	$description=&tag2value ($hit{$a}{open}, "description");

	%Q=&xml2tag_list ($hit{$a}{body}, "querySeq");
	%M=&xml2tag_list ($hit{$a}{body}, "matchSeq");
	%E=&xml2tag_list ($hit{$a}{body}, "expectation");
	%I=&xml2tag_list ($hit{$a}{body}, "identity");


	for ($b=0; $b<$Q{n}; $b++)
	  {

	    $qs=$Q{$b}{body};
	    $ms=$M{$b}{body};

	    $expectation=$E{$b}{body};
	    $identity=$I{$b}{body};


	    $start=&tag2value ($Q{$b}{open}, "start");
	    $end=&tag2value ($Q{$b}{open}, "end");
	    $startM=&tag2value ($M{$b}{open}, "start");
	    $endM=&tag2value ($M{$b}{open}, "end");
	    $coverage=(($end-$start)*100)/$L;

	   # print "$id: ID: $identity COV: $coverage [$start $end]\n";

	    if ($identity>$maxid || $identity<$minid || $coverage<$mincov){next;}
	    # print "KEEP\n";


	    @lr1=(split (//,$qs));
	    @lr2=(split (//,$ms));
	    $l=$#lr1+1;
	    for ($c=0;$c<$L;$c++){$p[$nhits][$c]="-";}
	    for ($d=0,$c=0; $c<$l; $c++)
	      {
		$r=$lr1[$c];
		if ( $r=~/[A-Za-z]/)
		  {

		    $p[$nhits][$d + $start-1]=$lr2[$c];
		    $d++;
		  }
	      }

	    $Qseq[$nhits]=$qs;
	    $Hseq[$nhits]=$ms;
	    $QstartL[$nhits]=$start;
	    $HstartL[$nhits]=$Hstart;
	    $identityL[$nhits]=$identity;
	    $endL[$nhits]=$end;
	    $definitionL[$nhits]=$definition;
	    $identifyerL[$nhits]=$identifyer;
	    $comment[$nhits]="$ldb|$identifyer [Eval=$expectation][id=$identity%][start=$startM end=$endM]";
	    $nhits++;
	  }
      }

    $profile{n}=0;
    $profile{$profile{n}}{name}=$name;
    $profile{$profile{n}}{seq}=$seq;
    $profile {n}++;

    for ($a=0; $a<$nhits; $a++)
      {
	$n=$a+1;
	$profile{$n}{name}="$name\_$a";
	$profile{$n}{seq}="";
	$profile{$n}{Qseq}=$Qseq[$a];
	$profile{$n}{Hseq}=$Hseq[$a];
	$profile{$n}{Qstart}=$QstartL[$a];
	$profile{$n}{Hstart}=$HstartL[$a];
	$profile{$n}{identity}=$identityL[$a];
	$profile{$n}{definition}=$definitionL[$a];
	$profile{$n}{identifyer}=$identifyerL[$a];
	$profile{$n}{comment}=$comment[$a];

	for ($b=0; $b<$L; $b++)
	  {
	    if ($p[$a][$b])
	      {
		$profile{$n}{seq}.=$p[$a][$b];
	      }
	    else
	      {
		$profile{$n}{seq}.="-";
	      }
	  }
      }
    $profile{n}=$nhits+1;

    return %profile;
  }
sub output_profile
  {
    my ($outfile,$profileR, $trim)=(@_);
    my ($a);
    my %profile=%$profileR;
    my $P= new FileHandle;
    my $tmp=vtmpnam();

    open ($P, ">$tmp");
    for ($a=0; $a<$profile{n}; $a++)
      {
	print $P ">$profile{$a}{name} $profile{$a}{comment}\n$profile{$a}{seq}\n";
      }
    close ($P);

    if ( $trim)
      {
	
	if ($trim>0)
	  {
	    &safe_system ("t_coffee -other_pg seq_reformat -in $tmp -action +trim _aln_n$trim\_K1 -output fasta_aln -out $outfile");
	  }
	else
	  {
	    &safe_system ("t_coffee -other_pg seq_reformat -in $tmp -action +trim _aln_%%$trim\_K1 -output fasta_aln -out $outfile");
	  }
      }
    else
      {
	&safe_system ("mv $tmp $outfile");
      }
    return;
  }
sub blast_xml2hit_list
  {
    my $string=(@_[0]);
    return &xml2tag_list ($string, "hit");
  }
sub xmltag2value
  {
    my ($string_in, $tag)=@_;
    my %TAG;
    %TAG=xml2tag_list ($string_in, $tag);
    return $TAG{0}{body};
  }

sub xml2tag_list
  {
    my ($string_in,$tag)=@_;
    my $tag_in, $tag_out;
    my %tag;

    if (-e $string_in)
      {
	$string=&file2string ($string_in);
      }
    else
      {
	$string=$string_in;
      }
    $tag_in1="<$tag ";
    $tag_in2="<$tag>";
    $tag_out="/$tag>";
    $string=~s/>/>##1/g;
    $string=~s/</##2</g;
    $string=~s/##1/<#/g;
    $string=~s/##2/#>/g;
    @l=($string=~/(\<[^>]+\>)/g);
    $tag{n}=0;
    $in=0;$n=-1;



    foreach $t (@l)
      {

	$t=~s/<#//;
	$t=~s/#>//;

	if ( $t=~/$tag_in1/ || $t=~/$tag_in2/)
	  {

	    $in=1;
	    $tag{$tag{n}}{open}=$t;
	    $n++;

	  }
	elsif ($t=~/$tag_out/)
	  {


	    $tag{$tag{n}}{close}=$t;
	    $tag{n}++;
	    $in=0;
	  }
	elsif ($in)
	  {

	    $tag{$tag{n}}{body}.=$t;
	  }
      }

    return %tag;
  }


sub seq2gor_prediction
  {
    my ($name, $seq,$infile, $outfile, $gor_seq, $gor_obs)=(@_);
    my ($l);

    `gorIV -prd $infile -seq $gor_seq -obs $gor_obs > gor_tmp`;
    open (GR, ">$outfile");
    open (OG, "gor_tmp");

    while (<OG>)
      {

	$l=$_;
	if ($l=~/\>/){print GR "$l";}
	elsif ( $l=~/Predicted Sec. Struct./)
	  {
	    $l=~s/Predicted Sec. Struct\.//;
	    print GR "$l";
	  }
      }
    close (GR);
    close (OG);
    return;
  }
sub seq2msa_tm_prediction
  {
    my ($name, $seq, $db, $infile, $outfile, $arch, $psv)=(@_);
    my (%p,%gseq,%R, $blast_output, %s, $l);
    my $R2=new FileHandle;
    my $method="psitm";
    my $SERVER="EBI";

    $blast_output=&run_blast ($name,"blastp", $db, $infile, "outfile");

    if (&cache_file("GET",$infile,$name,$method,$db,$outfile,$SERVER))
      {
	print "\tPSITM: USE Cache\n";
	return $outfile;
      }
    else
      {
	$CACHE_STATUS="COMPUTE CACHE";
	%p=blast_xml2profile($name,$seq,$maxid, $minid,$mincov,$blast_output);


	open (F, ">tm_input");
	for (my $a=0; $a<$p{n}; $a++)
	  {
	    my $s;

	    $s=$p{$a}{seq};
	    $s=uc($s);
	    print F ">$p{$a}{name}\n$s\n";
	    #print stdout ">$p{$a}{name}\n$s\n";
	  }
	close (F);
	print "\tPSITM: kept  $p{n} Homologues for Sequence $p{0}{name}\n";
	&safe_system ("t_coffee -other_pg fasta_seq2hmmtop_fasta.pl -in=tm_input -out=$outfile -output=cons -cov=70 -trim=95 -arch=$arch -psv=$psv");
	unlink ("tm_input");
	&cache_file("SET",$infile,$name,$method,$db,$outfile,$SERVER);
	return;
      }
  }


sub seq2msa_gor_prediction
  {
    my ($name, $seq,$infile, $outfile, $gor_seq, $gor_obs)=(@_);
    my (%p,%gseq,%R, $blast_output, %s, $l);
    my $R2=new FileHandle;
    my $db="uniprot";
    my $method="psigor";
    my $SERVER="EBI";

    $blast_output=&run_blast ($name,"blastp", "uniprot", $infile, "outfile");

    if (&cache_file("GET",$infile,$name,$method,$db,$outfile,$SERVER))
      {
	print "\tPSIGOR: USE Cache\n";
	return $outfile;
      }
    else
      {
	$CACHE_STATUS="COMPUTE CACHE";
	%p=blast_xml2profile($name,$seq,$maxid, $minid,$mincov,$blast_output);


	open (F, ">gor_input");
	for (my $a=0; $a<$p{n}; $a++)
	  {
	    my $s;

	    $s=$p{$a}{seq};
	    $s=uc($s);
	    print F ">$p{$a}{name}\n$s\n";
	    #print stdout ">$p{$a}{name}\n$s\n";
	  }
	close (F);
	print "\tGORTM: kept  $p{n} Homologues for Sequence $p{0}{name}\n";
	&safe_system ("t_coffee -other_pg fasta_seq2hmmtop_fasta.pl -in=gor_input -out=$outfile -output=cons -cov=70 -trim=95 -gor_seq=$gor_seq -gor_obs=$gor_obs -mode=gor");
	unlink ("tm_input");
	&cache_file("SET",$infile,$name,$method,$db,$outfile,$SERVER);
	return;
      }
  }



sub run_blast
  {
    my ($name, $method, $db, $infile, $outfile, $run)=(@_);
    if (!$run){$run=1;}
    my $error_log=vtmpnam();
    my $cl_db;
    
    if (&cache_file("GET",$infile,$name,$method,$db,$outfile,$SERVER) && is_valid_blast_xml ($outfile))
      {return $outfile;}
    else
      {
	$CACHE_STATUS="COMPUTE CACHE";
	if ( $SERVER eq "EBI_SOAP")
	  {
	    &check_configuration ("EMAIL","SOAP::Light","INTERNET");

	    $cl_method=$method;
	    if ($cl_method =~/wu/)
	      {
		$cl_method=~s/wu//;
		if ( $cl_method eq "psiblast")
		  {
		    add_warning($$,$$,"PSI BLAST cannot be used with the wuBLAST Client. Use server=EBI Or server=LOCAL. blastp will be used instead");
		    $cl_method="blastp";
		  }

		$command="t_coffee -other_pg wublast.pl --email $EMAIL $infile -D $db -p $cl_method --outfile $outfile -o xml>/dev/null 2>$error_log";
		&safe_system ( $command);
		if (-e "$outfile.xml") {`mv $outfile.xml $outfile`;}
	      }
	    else
	      {
		if ($cl_method eq "psiblast"){$cl_method ="blastp -j5";}

		$command="t_coffee -other_pg blastpgp.pl --email $EMAIL $infile -d $db --outfile $outfile -p $cl_method --mode PSI-Blast>/dev/null 2>$error_log";
		&safe_system ( $command);

		if (-e "$outfile.xml") {`mv $outfile.xml $outfile`;}
	      }
	  }
	elsif ($SERVER eq "EBI_REST" || $SERVER eq "EBI")
	  {
	    $cl_method=$method;
	    &check_configuration("EMAIL","XML::Simple", "INTERNET");
	    if ($db eq "uniprot"){$db1="uniprotkb";}
	    else {$db1=$db;}

	    
	    if ($cl_method =~/wu/)
	      {
		$cl_method=~s/wu//;
		if ( $cl_method eq "psiblast"){$cl_method="blastp";}

		$command="t_coffee -other_pg wublast_lwp.pl --email $EMAIL -D $db1 -p $cl_method --outfile $outfile --align 5 --stype protein $infile>/dev/null 2>error_log";
	      }
	    else
	      {
		if ( $cl_method =~/psiblast/){$cl_method ="blastp -j5";}
		$command="t_coffee -other_pg ncbiblast_lwp.pl --email $EMAIL -D $db1 -p $cl_method --outfile $outfile --align 5 --stype protein $infile>/dev/null 2>$error_log";
		#DEBUG
		#$command="t_coffee -other_pg ncbiblast_lwp.pl --email $EMAIL -D $db1 -p $cl_method --outfile $outfile --align 5 --stype protein $infile";
		
		my $maxrun=5;#number of crashes accepetd
		my $nrun;
		my $keep_going=1;
		while ($keep_going)
		  {
		    
		    #print "----- $command [$nrun]\n";
		    $nrun++;
		    $keep_going=0;
		    &safe_system ( $command,5);
		    
		    my $success=0;
		    $success =$success || -e "$outfile.out.xml";
		    $success =$success || -e "$outfile.xml.xml";
		    $success =$success || -e "$outfile.out..xml";
		    $success =$success || -e "$outfile.xml..xml";
		    
		    if (!$success && ($nrun<$maxrun || -e "$outfile.out.txt"))
		      {
			$keep_going=1;
			add_warning($$,$$,"[ncbiblast_lwp.pl] [$command] failed to produce xml output -- will ne tried again [$nrun]");
		      }
		  }
		
		if (-e "$outfile.out.xml") {`mv $outfile.out.xml $outfile`;}
		elsif (-e "$outfile.xml.xml"){`mv $outfile.xml.xml $outfile`;}
		elsif (-e "$outfile.out..xml") {`mv $outfile.out..xml $outfile`;}
		elsif (-e "$outfile.xml..xml"){`mv $outfile.xml..xml $outfile`;}
		else
		  {
		    add_warning($$,$$,"[ncbiblast_lwp.pl] [$command] failed to produce xml output");
		  }
	      }
	  }
	elsif ($SERVER eq "NCBI")
	  {
	    &check_configuration ("INTERNET");
	    if ($db eq "uniprot"){$cl_db="swissprot";}
	    else {$cl_db=$db;}

	    if ( $method eq "psiblast")
	      {
		add_warning($$,$$,"PSI BLAST cannot be used with the NCBI BLAST Client. Use server=EBI Or server=LOCAL. blastp will be used instead");
		$cl_method="blastp";
	      }
	    else
	      {
		$cl_method=$method;
	      }
	      
	    &check_configuration ($cl_method);  
	    $command="$cl_method -db $cl_db -query $infile -out $outfile -outfmt 5 -remote";
	    &safe_system ($command);
	  }
	elsif ($SERVER =~/CLIENT_(.*)/)
	  {
	    my $client=$1;
	    $command="$client -p $method -d $db -i $infile -o $outfile -m 7";
	    &safe_system ($command);
	  }
	elsif ( $SERVER eq "LOCAL_blastall")
	  {
	    &check_configuration ("blastall");
	    if ($method eq "blastp")
	      {
		$command="blastall -d $db -i $infile -o $outfile -m7 -p blastp";
	      }
	    &safe_system ($command);
	  }
	elsif ( $SERVER eq "LOCAL")
	  {
	    if ($ENV{"BLAST_DB_DIR"}) {
	    	$x=$ENV{"BLAST_DB_DIR"};
			$cl_db="$x/$db";
	    }
	    else{
			$cl_db=$db;
	    }

        ##
		## BLAST+ provide different binaries names and CLI options
		## Use the 'legacy_blast.pl' to keep compatibility with old blast commands
		##
		$path=`which legacy_blast.pl 2>/dev/null`;  
		$path=`dirname $path`; 
		chomp($path);
	    if ($method eq "blastp"){
			&check_configuration("legacy_blast.pl");
			$command="legacy_blast.pl blastpgp --path $path -d $cl_db -i $infile -o $outfile -m7 -j1";
	    }
	    elsif ($method eq "psiblast")
	      {
		&check_configuration("legacy_blast.pl");
		$command="legacy_blast.pl blastpgp --path $path -d $cl_db -i $infile -o $outfile -m7 -j5";
	      }
	    elsif ($method eq "blastn")
	      {
		&check_configuration("legacy_blast.pl");
		$command="legacy_blast.pl blastall --path $path -p blastn -d $cl_db -i $infile -o $outfile -m7 -W6";
	      }
	    &safe_system ($command);
	  }
	else
	  {

	    myexit(add_error (EXIT_FAILURE,$$,$$,getppid(), "BLAST_FAILURE::UnknownServer",$CL));
	  }


	#Check that everything went well

	if ( !-e $outfile || !&is_valid_blast_xml($outfile))
	  {

	    if ( -e $outfile)
	      {
		add_warning ($$,$$,"Corrupted Blast Output (Run $run)");
		unlink($outfile);
	      }
	    if ( -e $error_log)
	      {

		my $error_msg=file2string ($error_log);

		if ( $error_msg =~/enter a valid email/)
		  {
		    myexit(add_error (EXIT_FAILURE,$$,$$,getppid(), "BLAST_FAILURE::Invalid_or_rejected_email::$EMAIL", "$command"));
		  }
	      }
	    if ( $run==$BLAST_MAX_NRUNS)
	      {

		myexit(add_error (EXIT_FAILURE,$$,$$,getppid(), "BLAST_FAILURE::UnknownReason", "$command"));
	      }
	    else
	      {
		my $out;
		if ($SERVER eq "NCBI") {$SERVER="EBI"; }
		elsif ($SERVER eq "EBI"){$SERVER="NCBI";}
		add_warning ($$,$$,"Blast for $name failed (Run: $run out of $BLAST_MAX_NRUNS. Use $SERVER)");
		$out=&run_blast ($name, $method, $db,$infile, $outfile, $run+1);
		if ($SERVER eq "NCBI") {$SERVER="EBI"; }
		elsif ($SERVER eq "EBI"){$SERVER="NCBI";}
		return $out;
	      }
	  }

	&cache_file("SET",$infile,$name,$method,$db,$outfile,$SERVER);
	#system ("cp $outfile ~/Dropbox/tmp/cedric.out");
	#die;
	return $outfile;
      }
  }

sub cache_file
  {
    my ($cache_mode,$infile,$name,$method,$db, $outfile,$server)=(@_);
    my $cache_file;
    #Protect names so that they can be turned into legal filenames
    $name=&clean_file_name ($name);

    if ($db=~/\//)
      {
	$db=~/([^\/]+)$/;
	$db=$1;
      }
    $cache_file_sh="$name.$method.$db.$server.tmp";
    $cache_file="$CACHE/$name.$method.$db.$server.tmp";

    if ($infile ne "")
      {
	$cache_file_infile_sh="$name.$method.$db.$server.infile.tmp";
	$cache_file_infile="$CACHE/$name.$method.$db.$server.infile.tmp";
      }

    if ($cache_mode eq "GET")
      {
	if ($CACHE eq "" || $CACHE eq "no" || $CACHE eq "ignore"  || $CACHE eq "local" || $CACHE eq "update"){return 0;}
	elsif ( !-d $CACHE)
	  {
	    print STDERR "ERROR: Cache Dir: $CACHE Does not Exist";
	    return 0;
	  }
	else
	  {
	    if ( -e $cache_file && &fasta_file1_eq_fasta_file2($infile,$cache_file_infile)==1)
	      {
		`cp $cache_file $outfile`;
		$CACHE_STATUS="READ CACHE";
		return 1;
	      }
	  }
      }
    elsif ($cache_mode eq "SET")
      {
	if ($CACHE eq "" || $CACHE eq "no" || $CACHE eq "ignore"  || $CACHE eq "local" || $CACHE eq "update"){return 0;}
	elsif ( !-d $CACHE)
	  {
	    print STDERR "ERROR: Cache Dir: $CACHE Does not Exist";
	    return 0;
	  }
	elsif (-e $outfile)
	  {
	    `cp $outfile $cache_file`;
	    if ($cache_file_infile ne ""){ `cp $infile $cache_file_infile`;}

	    #functions for updating the cache
	    #`t_coffee -other_pg clean_cache.pl -file $cache_file_sh -dir $CACHE`;
	    #`t_coffee -other_pg clean_cache.pl -file $cache_file_infile_sh -dir $CACHE`;
	    return 1;
	  }
      }
    $CACHE_STATUS="COMPUTE CACHE";
    return 0;
  }
sub file1_eq_file2
  {
    my ($f1, $f2)=@_;
    if ( $f1 eq ""){return 1;}
    elsif ( $f2 eq ""){return 1;}
    elsif ( !-e $f1){return 0;}
    elsif ( !-e $f2){return 0;}
    elsif ($f1 eq "" || $f2 eq "" || `diff $f1 $f2` eq ""){return 1;}

    return 0;
  }
sub clean_file_name
  {
    my $name=@_[0];

    $name=~s/[^A-Za-z1-9.-]/_/g;
    return $name;
  }
sub url2file
  {
    my ($address, $out)=(@_);

    if (&pg_is_installed ("wget"))
	{
	  return &safe_system ("wget $address -O$out >/dev/null 2>/dev/null");
	}
    elsif (&pg_is_installed ("curl"))
      {
	return &safe_system ("curl $address -o$out >/dev/null 2>/dev/null");
      }
    else
      {
	myexit(flus_error("neither curl nor wget are installed. Imnpossible to fectch remote file"));
	exit ($EXIT_FAILURE);
      }
  }
sub fasta_file1_eq_fasta_file2
  {
    my ($f1, $f2)=@_;
    my (%s1, %s2);
    my @names;
    %s1=read_fasta_seq ($f1);
    %s2=read_fasta_seq ($f2);

    @names=(keys (%s1));

    foreach $n (keys(%s1))
      {
	if ($s1{$n}{seq} ne $s2{$n}{seq}){return 0;}
      }

    foreach $n (keys(%s2))
      {
	if ($s1{$n}{seq} ne $s2{$n}{seq}){return 0;}
      }
    return 1;
  }



sub read_template_file
  {
    my $pdb_templates = @_[0];
    my $tmp=new FileHandle;
    open ($tmp, "<$pdb_templates");
    my %temp_h;
    my ($skip,$seq, $temp);

    #supports both a simple [seq pdb] format and the regular fasta like template format
    while (<$tmp>)
      {
	
	$line = $_;
	if ($line=~/\>(\S+)\s_._\s(\S+)/){$temp_h{$1}= $2;}
	elsif ($line =~/(\S+)\s(\S+)/){$temp_h{$1}= $2;}
      }
    close($tmp);
    return %temp_h;
  }






sub seq2tblastx_lib
  {
    my ($mode, $infile, $outfile)=@_;
    my (%s, $method,$nseq);

    $method=$mode;
    &set_temporary_dir ("set",$infile,"infile");
    %s=read_fasta_seq("infile");


    foreach $seq (keys(%s))
      {
	$slist[$s{$seq}{order}]=$s{$seq}{seq};
	$sname[$s{$seq}{order}]=$s{$seq}{name};
	$slen[$s{$seq}{order}]=length ($s{$seq}{seq});
      }
    $nseq=$#sname+1;
    open (F, ">outfile");
    print F "! TC_LIB_FORMAT_01\n";
    print F "$nseq\n";
    for ($a=0; $a<$nseq;$a++)
      {
	print F "$sname[$a] $slen[$a]  $slist[$a]\n"
      }
    close (F);
    &safe_system ("formatdb -i infile -p F");
    &safe_system ("blastall -p tblastx -i infile -d infile -m 7 -S1>blast.output");

    ncbi_tblastx_xml2lib_file ("outfile", file2string ("blast.output"));
    &set_temporary_dir ("unset",$mode, $method, "outfile",$outfile);
    myexit ($EXIT_SUCCESS);
    }
sub seq2tblastpx_lib
  {
    my ($mode, $infile, $outfile)=@_;
    my (%s, $method,$nseq);
    $method=$mode;
    &set_temporary_dir ("set",$infile,"infile");
    %s=read_fasta_seq("infile");

    foreach $seq (keys(%s))
      {
	$slist[$s{$seq}{order}]=$s{$seq}{seq};
	$sname[$s{$seq}{order}]=$s{$seq}{name};
	$slen[$s{$seq}{order}]=length ($s{$seq}{seq});
      }
    $nseq=$#sname+1;
    open (F, ">outfile");
    print F "! TC_LIB_FORMAT_01\n";
    print F "$nseq\n";
    for ($a=0; $a<$nseq;$a++)
      {
	print F "$sname[$a] $slen[$a]  $slist[$a]\n"
      }
    close (F);
    &safe_system("t_coffee -other_pg seq_reformat -in infile -output tblastx_db1 > tblastxdb");
    &safe_system ("formatdb -i tblastxdb -p T");
    &safe_system ("blastall -p blastp -i tblastxdb -d tblastxdb -m7 >blast.output");
    ncbi_tblastpx_xml2lib_file ("outfile", file2string ("blast.output"), %s);
    &set_temporary_dir ("unset",$mode, $method, "outfile",$outfile);
    myexit ($EXIT_SUCCESS);
    }

sub x3dna_find_pair2lib
      {
      my ($seq, $pdb, $lib, $pg)=@_;
      my $outfile1="dssr-2ndstrs.dbn";
      my $outfile2="simple.output";
      my $f= new FileHandle;
      my ($rnaSS,$pdbSS);
      my $command;
      my %s_pdb;
      my %s_seq;
      
      #$pg: "find_pair" OR "find_pair -p"
      
      if (!pg_is_installed ("find_pair"))
	{
	  add_warning ($$,$$, "x3dna/find_pairs could not be used to extract RNA secondary structures. Secondary structures will be extracted by x3dna-ssr instead");
	  return x3dnassr2lib ($seq, $pdb, $lib);
	}
      
      #get PDB sequence
      safe_system ("t_coffee -other_pg extract_from_pdb $pdb -seq >$outfile1");
      
      #get find_pair contacts
      $command="$pg $pdb simple.output > /dev/null 2>/dev/null";
      safe_system ($command);

      if (($command=~/find_pair -p/)){$outfile2="allpairs.ana";}
      else {$outfile2="simple.output";}
      
      if ( !-e $outfile2)
	{
	  myexit(flush_error("x3dna failed to compute the secondary structure file $outfile2 for $pdb"));
	  myexit ($EXIT_FAILURE);
	}
      

      #Handle situations when the pdb sequence differs from the RNA sequence
      #my @out=file2array($outfile1);
      %s_pdb=read_fasta_seq_index ($outfile1);
      %s_seq=read_fasta_seq_index ($seq);
      my $rnaS=uc($s_seq{0}{seq});
      my $pdbS=uc($s_pdb{0}{seq});
      
      my $vienna;
      my @lu;
    
      if ($rnaS ne $pdbS)
	{
	  
	  my ($rna,$pdb);
	  $rnaSS=$rnaS;
	  $pdbSS=$pdbS;
	  $rnaSS=~s/T/U/g;
	  $pdbSS=~s/T/U/g;
	  ($rnaSS,$pdbSS)=nw ($rnaS, $pdbS);
	  
	  my @rnaA =split (//,$rnaSS);
	  my @pdbA=split (//,$pdbSS);
	  my $l=@rnaA;
	  
	  #print "\n--- $s_seq{0}{name} $rnaSS\n--- $s_seq{0}{name} $pdbSS\n\n";
	  
	  for (my $b=0,my $a=0; $a<$l; $a++)
	    {
	      if   ($rnaA[$a] ne '-' && $pdbA[$a] ne '-'){$lu[++$pdb]=++$rna;}
	      elsif($rnaA[$a] eq '-'){$lu[++$pdb]=-1;}
	      elsif($pdbA[$a] eq '-'){++$rna;}
	    }
	}
      else
	{
	  for (my $a=0; $a<=length ($rnaS); $a++)
	    {
	      $lu[$a]=$a;
	    }
	}
      my $l=length ($rnaS);
      open ($f, ">$lib");
      print $f "! TC_LIB_FORMAT_01\n";
      print $f "1\n";
      print $f "$s_seq{0}{name} $l $rnaS\n";
      print $f "!CMT: [SOURCE] >$s_seq{0}{name} 3D contact library Generated by $pg (x3dna)\n";
      print $f "#1 1\n";
      
      my $ne;
      my @array=file2array($outfile2);
      for (my $a=0; $a<5; $a++){shift (@array);}
      while (!($array[0]=~/####/))
	{
	  my $line= shift (@array);
	  my @l=($line=~/(\d+)/g);
	  
	 
	  my $f1=$lu[$l[0]];
	  my $s1=$lu[$l[1]];

	  #print "\n$line\n$l[0] --> $f1\n$l[1] --> $s1\n\n"; 
	  
	  if (!$f1 || !$s1)
	    {
	      print "\n---- $rnaSS\n---- $pdbSS\n$line\n[$l[0] --- $l[1]]<---->[$f1 --- $s1]\n";
	      myexit(flush_error("Error while parsing s3dna::find_pair output"));
	    }
	  elsif ($f1==-1 || $s1==-1){;}
	  elsif ($f1<$s1){print $f "$f1 $s1 100\n";}
	  else {print $f "$s1 $f1 100\n";$ne++;}
	}
      print $f "! SEQ_1_TO_N\n";
      close ($f);
      return;
    }
sub RNAplfold2lib
  {
    my ($seq, $lib)=@_;
    my $f= new FileHandle;
    
    &safe_system ("t_coffee -other_pg RNAplfold2tclib.pl -in=$seq -out=$lib");
    
    if ( !-e $lib)
	{
	 myexit(flush_error("RNAplfold failed to compute the secondary structure of $s{$seq}{name}"));
	 myexit ($EXIT_FAILURE);
       }
    open ($f, ">>$lib");
    print $f "!CMT: [SOURCE] 2D contact library Generated by RNAPlfold (Vienna Package)\n";
    close $f;
    return;
  }
sub x3dnassr2lib
    {
      my ($seq, $pdb, $lib)=@_;
      my $outfile="dssr-2ndstrs.dbn";
      my $f= new FileHandle;
      

      if (!pg_is_installed ("x3dna-ssr"))
	{
	  add_warning ($$,$$, "x3dna-ssr could not be used to extract RNA secondary structures. Secondary structures will be predicted ab-initio instead with RNAPlfold");
	  return RNAplfold2lib ($seq,$lib);
	}
      
      safe_system ("x3dna-ssr -i=$pdb >/dev/null 2>/dev/null");
      if ( !-e $outfile)
	{
	  myexit(flush_error("x3dna-ssr failed to compute the secondary structure file "));
	  myexit ($EXIT_FAILURE);
	}

      #Handle situations when the pdb sequence differs from the RNA sequence
      @out=file2array($outfile);
      my %s=read_fasta_seq ($seq);
      my @names=keys (%s);
      my $rnaS=uc($s{$names[0]}{seq});
      my $pdbS=uc($out[1]);
      my $vienna;
      
      #x3dna returns non legitimate nucleotides
       $pdbS=~s/[^AGCTU]//g;
      
      if ($rnaS ne $pdbS)
	{
	  my ($rna,$pdb);
	  my $rnaSS=$rnaS;
	  my $pdbSS=$pdbS;
	  $rnaSS=~s/T/U/g;
	  $pdbSS=~s/T/U/g;
	  ($rnaSS,$pdbSS)=nw ($rnaSS, $pdbSS);
	  my @rnaA =split (//,$rnaSS);
	  my @pdbA=split (//,$pdbSS);
	  my @SS=split (//, $out[2]);
	  
	  my $l=@rnaA;
	  for (my $b=0,my $a=0; $a<$l; $a++)
	    {
	      if   ($rnaA[$a] ne '-' && $pdbA[$a] ne '-'){$vienna.=$SS[$b++];}
	      elsif($rnaA[$a] eq '-'){$b++;}
	      elsif($pdbA[$a] eq '-'){$vienna.='.';}
	    }
	}
      else
	{
	  $vienna=$out[2];
	}
    

      open ($f, ">seq");
      print $f ">$names[0]\n$rnaS\n";
      close $f;
      
      open ($f, ">str");
      print $f ">$names[0]\n$vienna\n";
      close $f;
      
      safe_system ("t_coffee -other_pg seq_reformat -in seq -in2 str -output vienna2tc_lib >$lib");
      if ( !-e $lib)
	    {
	      myexit(flush_error("seq_reformat failed to convert your secondary structure"));
	      myexit ($EXIT_FAILURE);
	    }
      
      open ($f, ">>$lib");
      print $f "!CMT: [SOURCE] >$names[0] 2D Contact library generated by x3dna-ssr\n";
      #print $f "! Vienna_Format: >$names[0]\n";
      #print $f "! Vienna_Format: $vienna\n";
      
      close $f;
      return;
    }


sub file2head
      {
	my $file = shift;
	my $size = shift;
	my $f= new FileHandle;
	my $line;
	open ($f,$file);
	read ($f,$line, $size);
	close ($f);
	return $line;
      }
sub file2tail
      {
	my $file = shift;
	my $size = shift;
	my $f= new FileHandle;
	my $line;

	open ($f,$file);
	seek ($f,$size*-1, 2);
	read ($f,$line, $size);
	close ($f);
	return $line;
      }


sub vtmpnam
      {
	my $r=rand(100000);
	my $f="file.$r.$$";
	while (-e $f)
	  {
	    $f=vtmpnam();
	  }
	push (@TMPFILE_LIST, $f);
	return $f;
      }

sub myexit
  {
    my $code=@_[0];
    if ($CLEAN_EXIT_STARTED==1){return;}
    else {$CLEAN_EXIT_STARTED=1;}
    ### ONLY BARE EXIT
    exit ($code);
  }
sub set_error_lock
    {
      my $name = shift;
      my $pid=$$;


      &lock4tc ($$,"LERROR", "LSET", "$$ -- ERROR: $name $PROGRAM\n");
      return;
    }
sub set_lock
  {
    my $pid=shift;
    my $msg= shift;
    my $p=getppid();
    &lock4tc ($pid,"LLOCK","LRESET","$p$msg\n");
  }
sub unset_lock
   {

    my $pid=shift;
    &lock4tc ($pid,"LLOCK","LRELEASE","");
  }
sub shift_lock
  {
    my $from=shift;
    my $to=shift;
    my $from_type=shift;
    my $to_type=shift;
    my $action=shift;
    my $msg;

    if (!&lock4tc($from, $from_type, "LCHECK", "")){return 0;}
    $msg=&lock4tc ($from, $from_type, "LREAD", "");
    &lock4tc ($from, $from_type,"LRELEASE", $msg);
    &lock4tc ($to, $to_type, $action, $msg);
    return;
  }
sub isshellpid
  {
    my $p=shift;
    if (!lock4tc ($p, "LLOCK", "LCHECK")){return 0;}
    else
      {
	my $c=lock4tc($p, "LLOCK", "LREAD");
	if ( $c=~/-SHELL-/){return 1;}
      }
    return 0;
  }
sub isrootpid
  {
    if(lock4tc (getppid(), "LLOCK", "LCHECK")){return 0;}
    else {return 1;}
  }
sub lock4tc
	{
	  my ($pid,$type,$action,$value)=@_;
	  my $fname;
	  my $host=hostname;

	  if ($type eq "LLOCK"){$fname="$LOCKDIR/.$pid.$host.lock4tcoffee";}
	  elsif ( $type eq "LERROR"){ $fname="$LOCKDIR/.$pid.$host.error4tcoffee";}
	  elsif ( $type eq "LWARNING"){ $fname="$LOCKDIR/.$pid.$host.warning4tcoffee";}

	  if ($debug_lock)
	    {
	      print STDERR "\n\t---lock4tc(tcg): $action => $fname =>$value (RD: $LOCKDIR)\n";
	    }

	  if    ($action eq "LCHECK") {return -e $fname;}
	  elsif ($action eq "LREAD"){return file2string($fname);}
	  elsif ($action eq "LSET") {return string2file ($value, $fname, ">>");}
	  elsif ($action eq "LRESET") {return string2file ($value, $fname, ">");}
	  elsif ($action eq "LRELEASE")
	    {
	      if ( $debug_lock)
		{
		  my $g=new FileHandle;
		  open ($g, ">>$fname");
		  print $g "\nDestroyed by $$\n";
		  close ($g);
		  safe_system ("mv $fname $fname.old");
		}
	      else
		{
		  unlink ($fname);
		}
	    }
	  return "";
	}

sub file2string
	{
	  my $file=@_[0];
	  my $f=new FileHandle;
	  my $r;
	  open ($f, "$file");
	  while (<$f>){$r.=$_;}
	  close ($f);
	  return $r;
	}
sub file2array
	{
	  my $file=@_[0];
	  my $f=new FileHandle;
	  my @r;
	  open ($f, "$file");
	  while (<$f>){@r=(@r,$_);}
	  close ($f);
	  return @r;
	}
sub string2file
    {
    my ($s,$file,$mode)=@_;
    my $f=new FileHandle;

    open ($f, "$mode$file");
    print $f  "$s";
    close ($f);
  }

BEGIN
    {
      srand;

      $SIG{'SIGUP'}='signal_cleanup';
      $SIG{'SIGINT'}='signal_cleanup';
      $SIG{'SIGQUIT'}='signal_cleanup';
      $SIG{'SIGILL'}='signal_cleanup';
      $SIG{'SIGTRAP'}='signal_cleanup';
      $SIG{'SIGABRT'}='signal_cleanup';
      $SIG{'SIGEMT'}='signal_cleanup';
      $SIG{'SIGFPE'}='signal_cleanup';

      $SIG{'SIGKILL'}='signal_cleanup';
      $SIG{'SIGPIPE'}='signal_cleanup';
      $SIG{'SIGSTOP'}='signal_cleanup';
      $SIG{'SIGTTIN'}='signal_cleanup';
      $SIG{'SIGXFSZ'}='signal_cleanup';
      $SIG{'SIGINFO'}='signal_cleanup';

      $SIG{'SIGBUS'}='signal_cleanup';
      $SIG{'SIGALRM'}='signal_cleanup';
      $SIG{'SIGTSTP'}='signal_cleanup';
      $SIG{'SIGTTOU'}='signal_cleanup';
      $SIG{'SIGVTALRM'}='signal_cleanup';
      $SIG{'SIGUSR1'}='signal_cleanup';


      $SIG{'SIGSEGV'}='signal_cleanup';
      $SIG{'SIGTERM'}='signal_cleanup';
      $SIG{'SIGCONT'}='signal_cleanup';
      $SIG{'SIGIO'}='signal_cleanup';
      $SIG{'SIGPROF'}='signal_cleanup';
      $SIG{'SIGUSR2'}='signal_cleanup';

      $SIG{'SIGSYS'}='signal_cleanup';
      $SIG{'SIGURG'}='signal_cleanup';
      $SIG{'SIGCHLD'}='signal_cleanup';
      $SIG{'SIGXCPU'}='signal_cleanup';
      $SIG{'SIGWINCH'}='signal_cleanup';

      $SIG{'INT'}='signal_cleanup';
      $SIG{'TERM'}='signal_cleanup';
      $SIG{'KILL'}='signal_cleanup';
      $SIG{'QUIT'}='signal_cleanup';

      our $debug_lock=$ENV{"DEBUG_LOCK"};




      foreach my $a (@ARGV){$CL.=" $a";}
      if ( $debug_lock ){print STDERR "\n\n\n********** START PG: $PROGRAM *************\n";}
      if ( $debug_lock ){print STDERR "\n\n\n**********(tcg) LOCKDIR: $LOCKDIR $$ *************\n";}
      if ( $debug_lock ){print STDERR "\n --- $$ -- $CL\n";}




    }
sub flush_error
  {
    my $msg=shift;
    return add_error ($EXIT_FAILURE,$$, $$,getppid(), $msg, $CL);
  }
sub add_error
  {
    my $code=shift;
    my $rpid=shift;
    my $pid=shift;
    my $ppid=shift;
    my $type=shift;
    my $com=shift;

    $ERROR_DONE=1;
    lock4tc ($rpid, "LERROR","LSET","$pid -- ERROR: $type\n");
    lock4tc ($$, "LERROR","LSET", "$pid -- COM: $com\n");
    lock4tc ($$, "LERROR","LSET", "$pid -- STACK: $ppid -> $pid\n");

    return $code;
  }
sub add_warning
  {
    my $rpid=shift;
    my $pid =shift;
    my $command=shift;
    my $msg="$$ -- WARNING: $command\n";
    print STDERR "$msg";
    lock4tc ($$, "LWARNING", "LSET", $msg);
  }

sub signal_cleanup
  {
    print dtderr "\n**** $$ (tcg) was killed\n";
    &cleanup;
    exit ($EXIT_FAILURE);
  }
sub clean_dir
  {
    my $dir=@_[0];
    if ( !-d $dir){return ;}
    elsif (!($dir=~/tmp/)){return ;}#safety check 1
    elsif (($dir=~/\*/)){return ;}#safety check 2
    else
      {
	`rm -rf $dir`;
      }
    return;
  }
sub cleanup
  {
    #print stderr "\n----tc: $$ Kills $PIDCHILD\n";
    #kill (SIGTERM,$PIDCHILD);
    my $p=getppid();
    $CLEAN_EXIT_STARTED=1;



    if (&lock4tc($$,"LERROR", "LCHECK", ""))
      {
	my $ppid=getppid();
	if (!$ERROR_DONE)
	  {
	    &lock4tc($$,"LERROR", "LSET", "$$ -- STACK: $p -> $$\n");
	    &lock4tc($$,"LERROR", "LSET", "$$ -- COM: $CL\n");
	  }
      }
    my $warning=&lock4tc($$, "LWARNING", "LREAD", "");
    my $error=&lock4tc($$,  "LERROR", "LREAD", "");
    #release error and warning lock if root

    if (isrootpid() && ($warning || $error) )
      {

	print STDERR "**************** Summary *************\n$error\n$warning\n";

	&lock4tc($$,"LERROR","RELEASE","");
	&lock4tc($$,"LWARNING","RELEASE","");
      }


    foreach my $f (@TMPFILE_LIST)
      {
	if (-e $f){unlink ($f);}
      }
    foreach my $d (@TMPDIR_LIST)
      {
	clean_dir ($d);
      }
    #No More Lock Release
    #&lock4tc($$,"LLOCK","LRELEASE",""); #release lock

    if ( $debug_lock ){print STDERR "\n\n\n********** END PG: $PROGRAM ($$) *************\n";}
    if ( $debug_lock ){print STDERR "\n\n\n**********(tcg) LOCKDIR: $LOCKDIR $$ *************\n";}
  }
END
  {

    &cleanup();
  }

sub blast_com2new_blast_com
    {
      my $com=shift;
	  if ($com=~/formatdb/)
	    {
	      $com=~s/formatdb/makeblastdb/;
	      $com=~s/\-i/\-in/;
	      if ($com =~/pF/){$com=~s/\-pF/\-dbtype nucl/;}
	      if ($com =~/p F/){$com=~s/\-p F/\-dbtype nucl/;}
	      $com="$com -logfile /dev/null";
	      return $com;
	    }
	  else {return $com;}

    }
sub safe_system
{
  my $com=shift;
  my $ntry=shift;
  my $ctry=shift;
  my $pid;
  my $status;
  my $ppid=getppid();
  if ($com eq ""){return 1;}

  if ( ($com=~/^blast/) ||($com=~/^formatdb/)){$com=&blast_com2new_blast_com($com);}

  if (($pid = fork ()) < 0){return (-1);}
  if ($pid == 0)
    {
      set_lock($$, " -SHELL- $com (tcg)");
      if( $debug_generic_method ) { printf "~ exec: %s\n", $com; }
      exec ($com);
      if( $debug_generic_method ) { printf "~ exitcode: %s\n", $?; }
    }
  else
    {
      lock4tc ($$, "LLOCK", "LSET", "$pid\n");#update parent
      $PIDCHILD=$pid;
    }
  if ($debug_lock){printf STDERR "\n\t .... safe_system (fasta_seq2hmm)  p: $$ c: $pid COM: $com\n";}

  waitpid ($pid,WTERMSIG);

  shift_lock ($pid,$$, "LWARNING","LWARNING", "LSET");

  if ($? == $EXIT_FAILURE || lock4tc($pid, "LERROR", "LCHECK", ""))
    {
      if ($ntry && $ctry <$ntry)
	{

	  add_warning ($$,$$,"$com failed [retry: $ctry out of $ntry]");
	  lock4tc ($pid, "LRELEASE", "LERROR", "");
	  #if ($com=~/EBI/){$com=~s/EBI/NCBI/;}
	  #elsif ($com=~/NCBI/){$com=~s/NCBI/EBI/;}

	  return safe_system ($com, $ntry, ++$ctry);
	}
      elsif ($ntry == -1)
	{
	  if (!shift_lock ($pid, $$, "LERROR", "LWARNING", "LSET"))
	    {
	      add_warning ($$,$$,"$com failed");
	    }
	  else
	    {
	      lock4tc ($pid, "LRELEASE", "LERROR", "");
	    }
	  return $?;}
      else
	{
	  if (!shift_lock ($pid,$$, "LERROR","LERROR", "LSET"))
	    {
	      myexit(add_error ($EXIT_FAILURE,$$,$pid,getppid(), "UNSPECIFIED system", $com));
	    }
	}
    }
  return $?;
}

sub check_configuration
    {
      my @l=@_;
      my $v;
      foreach my $p (@l)
	{

	  if   ( $p eq "EMAIL")
	    {
	      if ( !($EMAIL=~/@/))
		{
		add_warning($$,$$,"Could Not Use EMAIL");
		myexit(add_error ($EXIT_FAILURE,$$,$$,getppid(),"EMAIL","$CL"));
	      }
	    }
	  elsif( $p eq "INTERNET")
	    {
	      if ( !&check_internet_connection())
		{
		  myexit(add_error ($EXIT_FAILURE,$$,$$,getppid(),"INTERNET","$CL"));
		}
	    }
	  elsif( $p eq "wget")
	    {
	      if (!&pg_is_installed ("wget") && !&pg_is_installed ("curl"))
		{
		  myexit(add_error ($EXIT_FAILURE,$$,$$,getppid(),"PG_NOT_INSTALLED:wget","$CL"));
		}
	    }
	  elsif( !(&pg_is_installed ($p)))
	    {
	      myexit(add_error ($EXIT_FAILURE,$$,$$,getppid(),"PG_NOT_INSTALLED:$p","$CL"));
	    }
	}
      return 1;
    }
sub nw
      {
	my($A,$B)=@_;
	my ($i,$j, $s);
	my $gep=-2;
	my $match=+2;
	my $mismatch=0;
	my ($sub, $ins, $del);


	if ($A eq $B){return ($A,$B);}
	
	$A=~s/[\s\d]//g;	
	$B=~s/[\s\d]//g;	


	my @rA=split ('',$A);
	my @rB=split ('',$B);
	
	#evaluate substitutions
	my $lenA=@rA;
	my $lenB=@rB;
	
	for ($i=0; $i<=$lenA; $i++){$smat[$i][0]=$i*$gep;$tb[$i][0 ]= 1;}
	for ($j=0; $j<=$lenB; $j++){$smat[0][$j]=$j*$gep;$tb[0 ][$j]=-1;}
	
	for ($i=1; $i<=$lenA; $i++)
	  {
	    for ($j=1; $j<=$lenB; $j++)
	      {
		if ($rA[$i-1] eq $rB[$j-1]){$s=$match;}
		else {$s=$mismatch;}
		
		$sub=$smat[$i-1][$j-1]+$s;
		$del=$smat[$i  ][$j-1]+$gep;
		$ins=$smat[$i-1][$j  ]+$gep;
		
		if   ($sub>=$del && $sub>=$ins){$smat[$i][$j]=$sub;$tb[$i][$j]=0;}
		elsif($del>$ins){$smat[$i][$j]=$del;$tb[$i][$j]=-1;}
		else {$smat[$i][$j]=$ins;$tb[$i][$j]=1;}
		}
	  }
	#print "\n---- SCORE=$smat[$lenA][$lenB]\n";
	
	$i=$lenA;
	$j=$lenB;
	my $aln_len=0;

	while (!($i==0 && $j==0))
	  {
	    if ($tb[$i][$j]==0)
	    {
	      $aA[$aln_len]=$rA[--$i];
	      $aB[$aln_len]=$rB[--$j];
	    }
	  elsif ($tb[$i][$j]==-1)
	    {
	      $aA[$aln_len]='-';
	      $aB[$aln_len]=$rB[--$j];
	    }
	  elsif ($tb[$i][$j]==1)
	    {
	      $aA[$aln_len]=$rA[--$i];
	      $aB[$aln_len]='-';
	    }
	  $aln_len++;
	  }
	
	
	@aA=reverse (@aA);
	@aB=reverse (@aB);
	my $sA=join('',@aA);
	my $sB=join('',@aB);
	return ($sA,$sB);
      }
      
sub fasta2nseq
	{
	  
	  my $f=@_[0];
	  my $nseq;

	  open (F, "$f") or return 0;
	  while (<F>)
	    {
	      if ($_=~/\>/){$nseq++;}
	    }
	  close (F);
	  return $nseq;
	}
	
$program="T-COFFEE (Version_13.39.0.d675aed)";\n

</content>
</file>
<file>
<stream>output</stream>
<name>rnapdb2protpdb.pl</name>
<content>#!/usr/bin/env perl
use Env;
use FileHandle;
use Cwd;
use File::Path;
use Sys::Hostname;
my $f = new FileHandle;

open ($f, $ARGV[1]);
$atom=$ARGV[0];

$atom=~s/PRIME/\'/;
while (<$f>)
  {
    my $l=$_;

    $l=~s/$atom/CA /;
    
    
    $l=~s/  G /GLY /g;
    $l=~s/  C /CYS /g;
    $l=~s/  T /THR /g;
    $l=~s/  A /ALA /g;
    $l=~s/  U /THR /g;
    
    $l=~s/ DG /GLY /g;
    $l=~s/ DC /CYS /g;
    $l=~s/ DT /THR /g;
    $l=~s/ DA /ALA /g;
    $l=~s/ DU /THR /g;
    
    print $l;
  }




</content>
</file>
<file>
<stream>output</stream>
<name>generic_method.tc_method</name>
<content>#!/usr/bin/env perl
*TC_METHOD_FORMAT_01
******************generic_method.tc_method*************
*
*       Incorporating new methods in T-Coffee
*       Cedric Notredame 26/08/08
*
*******************************************************
*This file is a method file
*Copy it and adapt it to your need so that the method 
*you want to use can be incorporated within T-Coffee
*******************************************************
*                  USAGE                              *
*******************************************************
*This file is passed to t_coffee via -in:
*
*	t_coffee -in Mgeneric_method.method
*
*	The method is passed to the shell using the following
*call:
*<EXECUTABLE><PARAM1><IN_FLAG><seq_file><PARAM2><OUT_FLAG><outname><PARAM>
*
*Conventions:
*<FLAG_NAME> 	<TYPE>		<VALUE>
*<VALUE>:	no_name 	<=> Replaced with a space
*<VALUE>:	&nbsp	<=> Replaced with a space
*
*******************************************************
*                  ALN_MODE                           *
*******************************************************
*pairwise   ->all Vs all (no self )[(n2-n)/2aln]
*m_pairwise ->all Vs all (no self)[n^2-n]^2
*s_pairwise ->all Vs all (self): [n^2-n]/2 + n
*multiple   ->All the sequences in one go
*
ALN_MODE		pairwise
*
*******************************************************
*                  OUT_MODE                           *
*******************************************************
* mode for the output:
*External methods: 
* aln -> alignmnent File (Fasta or ClustalW Format)
* lib-> Lib file (TC_LIB_FORMAT_01)
*Internal Methods:
* fL -> Internal Function returning a List (Librairie)
* fA -> Internal Function returning an Alignmnent
*
OUT_MODE		aln
*******************************************************
*                  SEQ_TYPE                           *
*******************************************************
*G: Genomic, S: Sequence, P: PDB, R: Profile
*Examples:
*SEQTYPE	S	sequences against sequences (default)
*SEQTYPE	S_P	sequence against structure
*SEQTYPE	P_P	structure against structure
*SEQTYPE	PS	mix of sequences and structure	
*
SEQ_TYPE	S
*

*******************************************************
*                COMMAND LINE                         *
*EXECUTABLE PARAM1 IN_FLAG OUT_FLAG PARAM             *
*******************************************************
*******************************************************
*                  EXECUTABLE                         *
*******************************************************
*name of the executable
*passed to the shell: executable
*	
EXECUTABLE	tc_generic_method.pl
*
*******************************************************
*                  IN_FLAG                             *
*******************************************************
*IN_FLAG
*flag indicating the name of the in coming sequences
*IN_FLAG S no_name ->no flag
*IN_FLAG S &bnsp-in&bnsp -> " -in "
*
IN_FLAG		-infile=
*
*******************************************************
*                  OUT_FLAG                           *
*******************************************************
*OUT_FLAG
*flag indicating the name of the out-coming data
*same conventions as IN_FLAG
*OUT_FLAG	S no_name ->no flag
*if you want to redirect, pass the parameters via PARAM1
*set OUT_FLAG to >
*
OUT_FLAG		-outfile=
*
*******************************************************
*                  PARAM_1                              *
*******************************************************
*<EXECUTABLE><PARAM1><IN_FLAG><seq_file><PARAM2><OUT_FLAG><outname><PARAM>
*Parameters sent to the EXECUTABLE and specified *before* IN_FLAG 
*If there is more than 1 PARAM line, the lines are
*concatenated
*Command_line: @EP@PARAM@-gapopen%e10%s-gapext%e20
*	%s white space
*	%e equal sign
*
*PARAM1	
*
*
*
*******************************************************
*                  PARAM_2                              *
*******************************************************
*<EXECUTABLE><PARAM1><IN_FLAG><seq_file><PARAM2><OUT_FLAG><outname><PARAM>
*Parameters sent to the EXECUTABLE and specified 
*after* IN_FLAG and *before* OUT_FLAG
*If there is more than 1 PARAM line, the lines are
*concatenated
*
*PARAM1	
*
*
*******************************************************
*                  PARAM                              *
*******************************************************
*<EXECUTABLE><PARAM1><IN_FLAG><seq_file><PARAM2><OUT_FLAG><outname><PARAM>
*Parameters sent to the EXECUTABLE and specified *after* OUT_FLAG
*If there is more than 1 PARAM line, the lines are
*concatenated
*
PARAM	-mode=seq_msa -method=clustalw2
PARAM   -OUTORDER=INPUT -NEWTREE=core -align -gapopen=-15
*
*******************************************************
*                  END                                *
*******************************************************

</content>
</file>
<file>
<stream>output</stream>
<name>clustalw_method.tc_method</name>
<content>#!/usr/bin/env perl
*TC_METHOD_FORMAT_01
***************clustalw_method.tc_method*********
EXECUTABLE	clustalw
ALN_MODE		pairwise
IN_FLAG		-INFILE=
OUT_FLAG		-OUTFILE=
OUT_MODE		aln
PARAM		-gapopen=-10
SEQ_TYPE		S
*************************************************

</content>
</file>
<file>
<stream>output</stream>
<name>extract_from_pdb</name>
<content>#!/usr/bin/env perl
$VersionTag =                                                                                                                                   2.43;
use Env;
use FileHandle;
use Cwd;
use File::Path;
use Sys::Hostname;

our $PIDCHILD;
our $ERROR_DONE;
our @TMPFILE_LIST;
our $EXIT_FAILURE=1;
our $EXIT_SUCCESS=0;

our $REFDIR=getcwd;
our $EXIT_SUCCESS=0;
our $EXIT_FAILURE=1;

our $PROGRAM="extract_from_pdb";
our $CL=$PROGRAM;

our $CLEAN_EXIT_STARTED;
our $debug_lock=$ENV{"DEBUG_LOCK"};
our $LOCKDIR=$ENV{"LOCKDIR_4_TCOFFEE"};
if (!$LOCKDIR){$LOCKDIR=getcwd();}
our $ERRORDIR=$ENV{"ERRORDIR_4_TCOFFEE"};
our $ERRORFILE=$ENV{"ERRORFILE_4_TCOFFEE"};
&set_lock ($$);
if (isshellpid(getppid())){lock4tc(getppid(), "LLOCK", "LSET", "$$\n");}
      
our $SILENT=" >/dev/null 2>/dev/null";
our $INTERNET=-1;







our $BLAST_MAX_NRUNS=2;
our $EXIT_SUCCESS=0;
our $EXIT_FAILURE=1;
our $CONFIGURATION=-1;
our $REF_EMAIL="";
our $PROGRAM="extract_from_pdb";


my %onelett_prot=&fill_onelett_prot();
my %threelett_prot=&fill_threelett_prot();
my %onelett_RNA=&fill_onelett_RNA();
my %threelett_RNA=&fill_threelett_RNA();
my %onelett_DNA=&fill_onelett_DNA();
my %threelett_DNA=&fill_threelett_DNA();





my %onelett = (
'P' => \%onelett_prot,
'D' => \%onelett_DNA,
'R' => \%onelett_RNA
);


my %threelett = (
'P' => \%threelett_prot,
'D' => \%threelett_DNA,
'R' => \%threelett_RNA
);







if($ARGV[0]=~/help/ ||$ARGV[0]=~/man/ || $ARGV[0]=~/HELP/ || $ARGV[0]=~/Man/ || $ARGV[0] eq "-h"  || $ARGV[0] eq "-H"  )
{die "SYNTAX: extract_from_pdb Version $VersionTag	
	Minimum:             [extract_from_pdb file] 
			   OR 
			     [... | extract_from_pdb]
 	Flags (Default setting on the first line)
	   -version...................[Returns the Version Number]
           -force.....................[Forces the file to be treated like a PDB file]
                                      [Regenerates the header and SEQRES fields]
           -force_name................[Forces the file to be named after name]]
           -infile.....file...........[Flag can be omited]
			              [File must be pdb or fro pgm]
                                      [File can also be compressed Z or gz]
                                      [In the case of a compressed file, you can omit the gz|Z extension]
           -netfile...................[File will be fetch from the net using wget]
                                      [wget or curl must be installed]
                                      [ftp://ftp.gnu.org/pub/gnu/wget/]
                                      [http://curl.haxx.se/]
                                      [Must also be used to retrieve the file from a local pdb copy (cf netaddress)]
           -netaddress................[Address used for the retrieving the netfile]
                                      [http://www.rcsb.org/pdb/cgi/export.cgi/%%.pdb.gz?format=PDB&pdbId=%%&compression=gz]
                                      [http://www.expasy.ch/cgi-bin/get-pdb-entry.pl?%%]
                                      [local -> will get the file from pdb_dir (see pdb_dir)]
           -netcompression............[Extension if the netfile comes compressed]
                                      [gz]
           -pdb_dir...................[address of the repertory where the pdb is installed]
                                      [Supports standard ftp style installation OR every stru in DIR]
                                      [Give the ..../pdb/structure/ dir]
                                      [If value omitted, the pg gets it from the env variable PDB_DIR]
           -netcompression_pg.........[gunzip]
           -is_pdb_name..........name.[Returns 1 if the name is a PDB ID, 0 otherwise]
           -model_type...........name.[Returns the model type if valid PDB name]
           -is_released_pdb_name name.[Returns 1 if the name corresponds to a released PDB file]
           -get_pdb_chains.....name...[Returns the list of chains corresponding to the entry]
           -get_pdb_id.........name...[Returns the PDB id within the provided pdb file]
           -get_fugue_name.....name...[Turns a name into a name valid for fugue]
                                      [Uses the netaddress to do so]
	   -chain......FIRST..........[Extract the first chain only]
		       A B C..........[Extract Several chains if needed]
		       ALL............[Extract all the chains]	
           -ligand.....ALL............[Extract the ligands in the chain (HETATM)]
                       <name1>,<name2>[Extract All the named lignds]
	   -ligand_only...............[Extract only the ligands]
           -ligand_list...............[Extract the list of ligands]
	   -coor.......<start>..<end>.[Coordinates of the fragment to extract]
			              [Omit end to include the Cter]
           -num........absolute.......[absolute: relative to the seq] 
                       file...........[file: relative to file]
           -num_out....new............[new: start 1->L]
                       old............[old: keep the file coordinates]
           -delete.....<start>..<end>.[Delete from residue start to residue end]
	   -atom.......CA.............[Atoms to include, ALL for all of them]
		       CA O N.........[Indicate several atoms if needed]
	   -code.......3..............[Use the 1 letter code or the 3 letters code]
	   -mode.......raw............[Output original pdb file]
                       pdb............[Output something that looks like pdb]
		       fasta..........[Output the sequences in fasta format]
		       simple.........[Output a format easy to parse in C ]
            -seq_field..ATOM...........[Field used to extract the sequence]
		       SEQRES.........[Use the complete sequence]
	   -seq.......................[Equivalent to  -mode fasta]
	   -model......1..............[Chosen Model in an NMR file]
           -nodiagnostic..............[Switches Error Messages off]
           -debug.....................[Sets the DEBUG ON]
           -no_remote_pdb_dir.........[Do not look for a remote file]
           -cache_pdb.................[Cache Value, default is $HOME/.t_coffee/cache, other values: NO<=> No cache]

      Environement Variables
           These variables can be set from the environement
           Command line values with the corresponding flag superseed evironement value
           NO_REMOTE_PDB_DIR..........[Prevents the program from searching remote file: faster]
           PDB_DIR....................[Indicates where PDB file must be fetched (localy)]

	 PROBLEMS: please contact cedric.notredame\@europe.com\n";
	 exit ($EXIT_SUCCESS);
}

$np=0;
$n_para=$#ARGV;
$model=1;
$pdb_dir=$ENV{'PDB_DIR'};if ($pdb_dir){$pdb_dir.="/";}
$debug=$ENV{'DEBUG_EXTRACT_FROM_PDB'};

$no_remote_pdb_dir=$ENV{NO_REMOTE_PDB_DIR};
$HOME=$ENV{'HOME'};
if ( $ENV{CACHE_4_TCOFFEE})
{$cache=$ENV{CACHE_4_TCOFFEE};}
else
{
    $cache="$HOME/.t_coffee/cache/";
}

   
$netaddress="http://www.rcsb.org/pdb/files/%%.pdb.gz";
$netcompression_pg="gunzip";
$netcompression="gz";

foreach ($np=0; $np<=$n_para; $np++)
  {        
    $value=$ARGV[$np];
   
    if  ($np==0 && !($value=~/^-.*/))
      { 
	$pdb_file= $ARGV[$np];
      }
    elsif ( !($value=~/^-.*/))
      {
	print "@ARGV";
	die;
      } 
    
    elsif ($value eq "-nodiagnostic"){$nodiagnostic=1;}
    elsif ($value eq "-force")
      {
	$force_pdb=1;
      }
    elsif ($value eq "-force_name")
      {
	$force_name=$ARGV[++$np];
	$force_pdb=1;
      }
    
    elsif ($value eq "-is_pdb_name")
      {
	$pdb_file= $ARGV[++$np];	
	$is_pdb_name=1;	
      } 
    elsif ($value eq "-is_released_pdb_name")
      {
	$pdb_file= $ARGV[++$np];	
	$is_released_pdb_name=1;
      }
    elsif ($value eq "-model_type")
      {
	$pdb_file= $ARGV[++$np];	
	$model_type=1;
      }
    elsif ($value eq "-debug")
{
	$debug=1;
}
    elsif ($value eq "-get_pdb_chains")
{
	$pdb_file= $ARGV[++$np];
	$get_pdb_chains=1;
}
    elsif ($value eq "-get_pdb_ligands")
{
	$get_pdb_ligands=1;
}
    
    elsif ($value eq "-get_pdb_id")
{
	$pdb_file= $ARGV[++$np];
	$get_pdb_id=1;
	
}
    
    elsif ( $value eq "-get_fugue_name")
{
	$pdb_file= $ARGV[++$np];
	$get_fugue_name=1;
}
    elsif ( $value eq "-infile")
{
       $pdb_file= $ARGV[++$np];
} 
    elsif ($value eq "-netfile")
{
	$netfile=1;
	if ( !($ARGV[$np+1]=~/^-.*/)){$pdb_file= $ARGV[++$np];}
}
    elsif (  $value eq "-num")
{
       $numbering= $ARGV[++$np];
}
    elsif (  $value eq "-num_out")
{
       $numbering_out= $ARGV[++$np];
}
    elsif ( $value eq "-netaddress")
{
	$netadress=$ARGV[++$np];
}
     
    elsif ( $value eq "-netcompression")
{
	 $netcompression=$ARGV[++$np];
}
    elsif ( $value eq "-pdb_dir")
{
	 if ( !($ARGV[$np+1]=~/^-.*/)){$pdb_dir= "$ARGV[++$np]/";}
}
     elsif ( $value eq "-no_remote_pdb_dir")
{
	$no_remote_pdb_dir=1;
	if ( !($ARGV[$np+1]=~/^-.*/)){$pdb_dir= "$ARGV[++$np]/";}
}
    elsif ( $value eq "-cache")
{
	$cache=$ARGV[++$np];
}
    
    elsif ($value eq "-netcompression_pg")
{
	  $netcompression_pg=$ARGV[++$np];
}
     elsif ($value eq "-mode")
{
       $MODE=$ARGV[++$np];
}

    elsif ( $value eq "-model")
{
       $model= $ARGV[++$np];
}
    elsif ($value eq "-seq_field" )
{
       $seq_field= $ARGV[++$np];
}   
    elsif ($value eq "-coor" )
{
       $start= $ARGV[++$np];
  
       if (($ARGV[$np+1] eq "") ||($ARGV[$np+1]=~/^-.*/)){$end="*";} 
       else {$end=   $ARGV[++$np];}     
       $coor_set=1;
}
    elsif ($value eq "-delete" )
{
       $delete_start= $ARGV[++$np];
       $delete_end= $ARGV[++$np];
       $delete_set=1;
}
    elsif  ($value eq "-code")
{
       $code= $ARGV[++$np];
}
    elsif  ($value eq "-no_hetatm")
{
       $no_hetatm=1;
}
    elsif ($value eq "-chain")
{
       while (!($ARGV[$np+1] eq "") &&!($ARGV[$np+1]=~/^-.*/))
{
	      ++$np;
	      @c_chain=(@chain,  $ARGV[$np]);
	      $hc_chain{$ARGV[$np]}=$#c_chain+1;
}           
}
    elsif ($value eq "-atom")
{

       while (!($ARGV[$np+1] eq "") && !($ARGV[$np+1]=~/^-.*/))
{
	      ++$np;
	      $atom[$n_atom++]=  $ARGV[$np];
	      $atom_list{$ARGV[$np]}=1;	      
} 
       
}
    elsif ( $value eq "-unfold")
{
	$unfold=1;
}
    elsif ($value eq "-seq" ||$value eq "-fasta" )
{
       $MODE="fasta";
}
    elsif ( $value eq "-version")
{
	print STDERR  "\nextract_from_pdb: Version $VersionTag\n";
	&myexit ($EXIT_SUCCESS);
}
    elsif ( $value eq "-ligand")
{
	while (!($ARGV[$np+1] eq "") && !($ARGV[$np+1]=~/^-.*/))
{
	    ++$np;
	    $ligand=1;
	    $ligand_list{$ARGV[$np]}=1;	      
} 
	$hc_chain{'LIGAND'}=1;
}
    elsif ( $value eq "-ligand_only")
{
	$ligand_only=1;
}
}
if ( $debug)
{
    print STDERR "\n[DEBUG:extract_from_pdb] NO_REMOTE_PDB_DIR: $no_remote_pdb_dir\n";
    print STDERR "\n[DEBUG:extract_from_pdb] PDB_DIR: $pdb_dir\n";
}


if ( $is_pdb_name)
  {
    if (&remote_is_pdb_name($pdb_file))
      {
	print "1";
      }
    else
      {
	print "0";
      }
    exit ($EXIT_SUCCESS);
  }

if ( $is_released_pdb_name)
  {
    
    if (&is_released($pdb_file))
      {
	print "1";
      }
    else
      {
	print "0";
      }
    exit ($EXIT_SUCCESS);
  }
if ($model_type)
  {
   
    printf "%s", &pdb2model_type($pdb_file);
    exit ($EXIT_SUCCESS);
    
  }
    

if (!$force_name)
{
    $pdb_file=~/([^\/]*)$/;
    $force_name=$1;
}

$local_pdb_file=$pdb_file;

if ( $debug){print STDERR "\n[DEBUG: extract_from_pdb] Scan For $local_pdb_file\n";}

$mem=$no_remote_pdb_dir;
$no_remote_pdb_dir=1;
$tmp_pdb_file=get_pdb_file ($local_pdb_file);

if ( !-e $tmp_pdb_file || $tmp_pdb_file eq "")
  {
    $local_pdb_file=$pdb_file;
    ($local_pdb_file, $suffix_chain)=&pdb_name2name_and_chain($local_pdb_file);

    if ($local_pdb_file)
      {
	if ( $debug){print STDERR "\nSplit $pdb_file into $local_pdb_file and $suffix_chain \n";}
	$tmp_pdb_file=get_pdb_file ($local_pdb_file);
	if ( $tmp_pdb_file ne "")
	  {
	    @c_chain=();
	    @c_chain=($suffix_chain);
	    %hc_chain=();
	    $hc_chain{$suffix_chain}=1;
	  }
      }
  }

$no_remote_pdb_dir=$mem;
if ($no_remote_pdb_dir==0)
  {
    
    if ( !-e $tmp_pdb_file || $tmp_pdb_file eq "")
      {
	
	$local_pdb_file=$pdb_file;
	($local_pdb_file, $suffix_chain)=&pdb_name2name_and_chain($local_pdb_file);
	if ($local_pdb_file)
	  {
	    
	    if ( $debug){print STDERR "\nSplit $pdb_file into $local_pdb_file and $suffix_chain \n";}
	    
	    $tmp_pdb_file=get_pdb_file ($local_pdb_file);    
	    
	    if ( $tmp_pdb_file ne "")
	      {
		@c_chain=();
		@c_chain=($suffix_chain);
		%hc_chain=();
		$hc_chain{$suffix_chain}=1;
	      }
	  }
      }
  }

if ( $debug){print STDERR "\n$pdb_file copied into ##$tmp_pdb_file##\n";}

if ( !-e $tmp_pdb_file || $tmp_pdb_file eq "")
{
	if ($is_pdb_name)
{
	    print "0\n"; exit ($EXIT_SUCCESS);
}
	else
{
  
	    print "\nEXTRACT_FROM_PDB: NO RESULT for $pdb_file\n";
	    &myexit ($EXIT_SUCCESS);	
}
}




%molecule_type=&pdbfile2chaintype($tmp_pdb_file);
if ( $debug){print STDERR "\n\tSequence Type determined\n";}

$pdb_id=&get_pdb_id ($tmp_pdb_file);
if ( $debug){print STDERR "\n\tID: $pdb_id (for $tmp_pdb_file)\n";}

if ( $pdb_id eq ""){$pdb_id=$force_name;}

@f_chain=&get_chain_list ($tmp_pdb_file);
if ( $debug){print STDERR "\n\tChain_list:@f_chain\n";}

if ( $get_pdb_chains)
{
    print "@f_chain\n";
    &myexit ($EXIT_SUCCESS);
}
if ( $get_pdb_ligands)
{
    %complete_ligand_list=&get_ligand_list ($tmp_pdb_file);
    print $complete_ligand_list{"result"};
    &myexit ($EXIT_SUCCESS);
}

elsif ( $get_pdb_id ||$get_fugue_name )
{
    if    (@c_chain && $c_chain[0] eq "FIRST"){$pdb_id=$pdb_id.$f_chain[0];}
    elsif (@c_chain && $c_chain[0] ne " "){$pdb_id=$pdb_id.$c_chain[0];}
    
    print "$pdb_id\n";
    &myexit ($EXIT_SUCCESS);
    
}
elsif ( $is_pdb_name)
{
    printf "1\n";
    &myexit ($EXIT_SUCCESS);
}



$structure_file=vtmpnam();

if ( $debug){print STDERR "\n\tCheck_point #1: $tmp_pdb_file  $structure_file\n";}

$INFILE=vfopen ("$tmp_pdb_file", "r"); 
my $TMP=vfopen ("$structure_file", "w");

$print_model=1;
$in_model=0;

if ( $debug){print STDERR "\n\tCheck_point #2\n";}
while ( <$INFILE>)
{
  my $first_model=0;
  $line=$_;

  if ( !$first_model && ($line =~/^MODEL\s*(\d*)/))
    {
      $first_model=$1;
      if ($model==1){$model=$first_model;}
    }
  
  if (($line =~/^MODEL\s*(\d*)/))
    {
      if ($1==$model)
	{
	  $in_model=1;
	  $print_model=1;
	  $is_nmr=1;
	}
      elsif ( $in_model==0)
	{
	  $print_model=0;
	}
      elsif ( $in_model==1)
	{
	  last;
	}
    }
  if ($print_model){print $TMP $line;}  
}
close ($TMP);
close ($INFILE);

if ( $debug){print STDERR "\n\tCheck_point #3\n";}	

  if ($numbering eq ""){$numbering="absolute";}
  if ($numbering_out eq ""){$numbering_out="new";}

  if ( $delete_set && $coor_set) {die "-delete and -coor are mutually exclusive, sorry\n";}
  if ( $n_atom==0){$atom_list[$n_atom++]="ALL";$atom_list{$atom_list[0]}=1;}
  if ( $seq_field eq ""){$seq_field="ATOM";}
  
  if ( $MODE eq ""){$MODE="pdb";}
  elsif ( $MODE eq "simple" && $code==0){$code=1;}

  if ( $code==0){$code=3;}


if ($f_chain[0] eq " "){$hc_chain{' '}=1;$c_chain[0]=" ";}
elsif (!@c_chain){$hc_chain{FIRST}=1;$c_chain[0]="FIRST";}#make sure the first chain is taken by default

if    ($hc_chain{ALL}) 
{
      @c_chain=@f_chain;
      foreach $e (@c_chain){$hc_chain{$e}=1;}
}
elsif($hc_chain{FIRST})
{
	@c_chain=($f_chain[0]);
	$hc_chain{$f_chain[0]}=1;
}


$MAIN_HOM_CODE=&get_main_hom_code ($structure_file);
$INFILE=vfopen ($structure_file, "r");


if ( $MODE eq "raw_pdb" || $MODE eq "raw")
{
    while (<$INFILE>)
{	print "$_";}
    close ( $INFILE);
    &myexit($EXIT_SUCCESS);
}    
if ( $MODE eq "raw4fugue" )
{
    while (<$INFILE>)
{	
	$l=$_;
	if ($l=~/^SEQRES/)
{
	    
	    $c= substr($l,11,1);
	    if ($hc_chain {$c}){print "$l";}
}
	elsif ( $l=~/^ATOM/)
{
	    $c=substr($l,21,1);
	    if ($hc_chain {$c}){print "$l";}
}
}
    close ( $INFILE);
    &myexit($EXIT_SUCCESS);
}    

if ( $MODE eq "pdb")
{

    $read_header=0;
    while (<$INFILE>) 
{
	    $line=$_;
	    if    ($line =~ /^HEADER/){print "$line";$read_header=1;}
}
    close ($INFILE);

    if (!$read_header)
{
	print "HEADER    UNKNOWN                                 00-JAN-00   $force_name\n";
}

    $INFILE=vfopen ($structure_file, "r");
    
    print "COMPND   1 CHAIN:";
    $last=pop(@c_chain);
    foreach $c ( @c_chain){ print " $c,";}
    if ( $last eq " "){print " NULL;\n";}
    else 
{
      print " $last;\n";
}
    @c_chain=(@c_chain, $last);
    
    print "REMARK Output of the program extract_from_pdb (Version $VersionTag)\n";
    print "REMARK Legal PDB format not Guaranteed\n";
    print "REMARK This format is not meant to be used in place of the PDB format\n";
    print "REMARK The header refers to the original entry\n";
    print "REMARK The sequence from the original file has been taken in the field: $seq_field\n";
    print "REMARK extract_from_pdb, 2001, 2002, 2003, 2004, 2005 2006 (c) CNRS and Cedric Notredame\n";   
    if ( $coor_set)
{
       print "REMARK Partial chain: Start $start End $end\n";
}
    if ( $is_nmr)
{
       print "REMARK NMR structure: MODEL $model\n";
}
   
    if ( $n_atom!=0)
{
       print "REMARK Contains Coordinates of: ";
       foreach $a (@atom){print "$a ";}
       print "\n";
}  
}




my $residue_index = -999;
my $old_c = "TemporaryChain";

while (<$INFILE>) 
{
	$line=$_;


	if ($line =~ /^SEQRES/)
{

		@field=/(\S*)\s*/g;

		$c= substr($_,11,1);

		
		$l=$#field;
		for ($a=4; $a<$#field ;)
{
			if (!$onelett{$molecule_type{$c}}->{$field[$a]})
{
				splice @field, $a, 1;
}
			else 
{
				$a++;
}
}
	
		if ( $c ne $in_chain)
{
			$pdb_chain_list[$n_pdb_chains]=$c;
			$pdb_chain_len [$n_pdb_chains]=$len;
			$in_chain=$c;
			$n_pdb_chains++;
}
	
		for ( $a=4; $a<$#field;$a++)
{
			$complete_seq{$c}[$complete_seq_len{$c}++]=$field[$a];
}
}
    elsif ( $line=~/^ATOM/ || ($line=~/^HETATM/ && &is_aa(substr($line,17,3),substr($line,21,1)) && !$no_hetatm))
{

	 
    $RAW_AT_ID=$AT_ID=substr($line,12,4);
	$RES_ID=&is_aa(substr($line,17,3),substr($line,21,1));
	$CHAIN=substr($line,21,1);

    $RES_NO=substr($line,22,4);
	$HOM_CODE=substr ($line, 26, 1);
	$TEMP=substr($line,60,6);
	
	$TEMP=~s/\s//g;
        $AT_ID=~s/\s//g;
	$RES_ID=~s/\s//g;
        $RES_NO=~s/\s//g;
		
	if ( $HOM_CODE ne $MAIN_HOM_CODE){next;}
	elsif ( $already_read2{$CHAIN}{$RES_ID}{$AT_ID}{$RES_NO}){next;}
	else{$already_read2{$CHAIN}{$RES_ID}{$AT_ID}{$RES_NO}=1;}
	
	
	if ($coor_set && $numbering eq "file" && $residue_index ne $RES_NO)
{
	    
	    if ( $RES_NO<=$start){$real_start{$CHAIN}++;}
	    if ( $RES_NO<=$end){$real_end{$CHAIN}++;}
}
	elsif ($numbering eq "absolute")
{
	    $real_start{$CHAIN}=$start;
	    $real_end{$CHAIN}=$end;
}

        $KEY="ALL";
        if ( $CHAIN ne $in_atom_chain)
{
	    
	  $pdb_atom_chain_list[$n_pdb_atom_chains]=$c;
	  $pdb_atom_chain_len [$n_pdb_atom_chains]=$len;
	  $in_atom_chain=$c;
	  $n_pdb_atom_chains++;
}
	
	if ( $residue_index ne $RES_NO)
{
	     $residue_index = $RES_NO;
	     $atom_seq{$CHAIN}[$atom_seq_len{$CHAIN}++]=$RES_ID;;
}
}

}
close ($INFILE);






$INFILE=vfopen ($structure_file, "r");
foreach $c (@c_chain)
{

	if    ( $seq_field eq "SEQRES"){@pdb_seq=@{$complete_seq{$c}};}
	elsif ( $seq_field eq "ATOM")  {@pdb_seq=@{$atom_seq{$c}};}
	

	$full_length=$l=$#pdb_seq+1;
		
	if ( $real_end{$c}=="*"){$real_end{$c}=$full_length;}
	if ( $coor_set)
{	   

	   if ( $real_end{$c} < $l){splice @pdb_seq, $real_end{$c}, $l;}
	   if ( $real_start{$c} < $l){splice @pdb_seq, 0, $real_start{$c}-1;}	  	   
	   $l=$#pdb_seq;
}

	elsif ( $delete_set)
{
	   splice @pdb_seq, $delete_start, $delete_end-$delete_start+1;
	   $l=$#pdb_seq;
}
	
	$new_fasta_name="$pdb_id$c";
	if ( $coor_set)
{
	   if ( $n_pdb_chains==0){$new_fasta_name="$new_fasta_name$c";}
	   $new_fasta_name= $new_fasta_name."\_$start\_$end";
}
	   
	if ( $MODE eq "pdb")
{
	   $nl=1;
	   $n=0;
	   
	   foreach $res ( @pdb_seq)
		{
		if ( !$n)
		{
		
		 printf "SEQRES %3d %1s %4d  ", $nl,$c, $l;
		 $nl++;
	}
	     $res=~s/\s//g;
	     
	     if ($code==1){ printf "%3s ",$onelett{$molecule_type{$c}}->{$res};}
	     elsif  ($code==3){ printf "%3s ",$res};
	     
	     $n++;		  
	     if ( $n==13){$n=0;print "\n";}
}
	  if ( $n!=0){print "\n"; $n=0;}
}
	elsif ( $MODE eq "simple")
{
	  print "# SIMPLE_PDB_FORMAT\n";
	  if ( $new_fasta_name eq " "){$new_fasta_name="dummy_name";}
	  print ">$new_fasta_name\n";

	  foreach $res ( @pdb_seq)
{
	      print "$onelett{$molecule_type{$c}}->{$res}";
}
	  print "\n";
}
	elsif ( $MODE eq "fasta")
{
	  $n=0;
	  print ">$new_fasta_name\n";
	  
	  foreach $res ( @pdb_seq)
{

	      print "$onelett{$molecule_type{$c}}->{$res}";
              $n++;
	      if ( $n==60){print "\n"; $n=0;}
}
	  print "\n"; 
}
}

if ( $MODE eq "fasta")
{
     &myexit($EXIT_SUCCESS);
  
}

  
  $charcount=0;
  $inchain="BEGIN";
  $n=0;
  while (<$INFILE>) 
{
    $line=$_;
     
    if ($line =~/^ATOM/  ||  ($line=~/^HETATM/))
{
	$line_header="UNKNWN";
	$RES_ID=substr($line,17,3);
	$chain = substr($line,21,1);

	if ($line =~/^ATOM/)
{
	    $line_header="ATOM";
	    $RES_ID=(&is_aa($RES_ID,$chain))?&is_aa($RES_ID,$chain):$RES_ID;
}
	elsif ($line=~/^HETATM/ && ($ligand_list {$RES_ID} ||$ligand_list {'ALL'} || !&is_aa($RES_ID,$chain)))
{
	    $line_header="HETATM";
}
	elsif ($line=~/^HETATM/ && (&is_aa($RES_ID,$chain) && !$no_hetatm))
{
	    $line_header="ATOM";
	    $RES_ID=&is_aa($RES_ID,$chain);
}
	else
{
	    next;
}

	

	$X=substr($line,30,8);     
	$Y=substr($line,38,8);
	$Z=substr($line,46,8);
	$TEMP=substr($line,60,6);
	
	$RAW_AT_ID=$AT_ID=substr($line,12,4);
	$CHAIN=substr($line,21,1);
	$RES_NO=substr($line,22,4);
	$HOM_CODE=substr ($line, 26, 1);
	
	$X=~s/\s//g;
	$Y=~s/\s//g;
	$Z=~s/\s//g;
	$TEMP=~s/\s//g;
	
	$AT_ID=~s/\s//g;
	$RES_ID=~s/\s//g;
	$RES_NO=~s/\s//g;

	
	if ( $HOM_CODE ne $MAIN_HOM_CODE){next;}
	elsif ( $already_read{$CHAIN}{$RES_ID}{$AT_ID}{$RES_NO}){next;}
	else{$already_read{$CHAIN}{$RES_ID}{$AT_ID}{$RES_NO}=1;}
	
	$KEY="ALL";

      	if ( $RES_NO ==0){$start_at_zero=1;}

	$RES_NO+=$start_at_zero;    
	
	if ( $current_chain ne $CHAIN)
{
	    $current_chain=$CHAIN;
	    $pos=$current_residue=0;
	    $offset=($coor_set)?($real_start{$CHAIN}-1):0;
	    if    ( $seq_field eq "SEQRES"){@ref_seq=@{$complete_seq{$CHAIN}};}
	    elsif ( $seq_field eq "ATOM")  {@ref_seq=@{$atom_seq{$CHAIN}};}
}
	
	if ($current_residue != $RES_NO)
{
	    $current_residue=$RES_NO;
	    if    ( $seq_field eq "SEQRES"){$pos=$current_residue;}
	    elsif ( $seq_field eq "ATOM"){$pos++;}
}
	
	
	if ($n_atom==0 || $atom_list{$AT_ID}==1 || $atom_list{$KEY}==1)
{ 	
	    
	    $do_it=(!@c_chain || $hc_chain{$CHAIN} ||$hc_chain{'LIGAND'} );
	    
	    $do_it= ($do_it==1) && ($coor_set==0 ||($pos>=$real_start{$CHAIN} && $pos<=$real_end{$CHAIN}));
	    $do_it= ($do_it==1) && ($delete_set==0 || $pos<$delete_start ||$pos>$delete_end );
	    if ($ligand==0 && $line_header eq "HETATM" ){$do_it=0;}
	    if ($ligand_only==1 && $line_header eq "ATOM" ){$do_it=0;}
	    if ($ligand==1 && $line_header eq "HETATM" && $ligand_list{$RES_ID}==0 && $ligand_list{"ALL"}==0){$do_it=0;} 
	    
	    
	    if ( $do_it)
{
		$n++;
		$out_pos=$pos;
		
	       if ( $delete_set)
{
		  if ( $out_pos< $delete_start){;}
		  else {$offset=$delete_end-$delete_start;}
}       
	       
	       if ( $numbering_out eq "new"){$out_pos-=$offset;}
	       elsif ( $numbering_out eq "old"){$out_pos=$RES_NO;}
	       
       
	       
	       if ( $code==1){$RES_ID=$onelett{$molecule_type{$c}}->{$RES_ID};}
	    
	       if ($unfold)
{
		   $unfolded_x+=5;
		   $X=$unfolded_x;
		   $Y=0;
		   $Z=0;
		   $float=1;
}
	       else
{
		   $float=3;
}

	       if ( $MODE eq "pdb")
{
		   printf "%-6s%5d %-4s %3s %s%4d    %8.3f%8.3f%8.3f  1.00 %5.2f\n",$line_header, $n, $RAW_AT_ID,$RES_ID,$CHAIN,$out_pos, $X, $Y, $Z,$TEMP;		  
}
	       elsif ( $MODE eq "simple")
{
		    if ( $RES_ID eq ""){$RES_ID="X";}
		  printf "%-6s %5s %s %2s %4d    %8.3f %8.3f %8.3f\n",$line_header, $AT_ID, $RES_ID,($CHAIN eq"" || $CHAIN eq " ")?"A":$CHAIN,$out_pos, $X, $Y, $Z,$TEMP;
}

}
}
}
}
print "\n";
close($INFILE);


if ( $error ne "") 
{$error=$error."\nDiagnostic:    SEQRES and the residues in ATOM are probably Incompatible\n";
    $error=$error.  "Recomendation: Rerun with '-fix 1' in order to ignore the SEQRES sequences\n";
}
if (!$nodiagnostic){print STDERR $error;}
&myexit ( $EXIT_SUCCESS);

sub get_pdb_entry_type_file
  {
    my $cache_file="$cache/pdb_entry_type.txt";
    my $env_file  = $ENV{"PDB_ENTRY_TYPE_FILE"};
    my $pdb_file  ="$ENV{'PDB_DIR'}/derived_data/pdb_entry_type.txt";
    
    
    if (-z $cache_file){unlink ($cache_file);}#will get updated
    if (-z $env_file){$env_file="";}    #cannot update
    if (-z $pdb_file){$pdb_file="";}    #cannot update
    
    if    (-e $env_file){return $env_file;} #env wins: user decides
    elsif (-e $pdb_file){return $pdb_file;} #local database wins: network file may be out of sync
    elsif ($no_remote_pdb_dir==1)
      {
	if (-e $cache_file){return $cache_file;}
	else
	  {add_warning($$,$$,"PDB_ENTRY_TYPE_FILE must be set to the location of <pdb>/derived_data/pdb_entry_type.txt when using NO_REMOTE_PDB_DIR=1");
	   return "";
	 }
      }
    else #update can only take place if the file lives in cache
      {
	my $new_file;
	if (!-e $cache_file || (-M $cache_file)>1)
	  {
	    $new_file=vtmpnam();
	    &url2file("ftp://ftp.wwpdb.org/pub/pdb/derived_data/pdb_entry_type.txt", $new_file);
	    if ( !-z $new_file){system ("mv $new_file $cache_file"); unlink ($new_file); $new_file=$cache_file;}
	    else {unlink($new_file);}
	  }
	else
	  {
	    $new_file=$cache_file;
	  }
	
	if (!-e $cache_file && !-e $new_file)
	  {
	    add_warning($$,$$,"Could not download ftp://ftp.wwpdb.org/pub/pdb/derived_data/pdb_entry_type.txt");
	    return "";
	  }
	elsif (-e $cache_file && !-e $new_file)
	  {
	    my $m=(-M $cache_file);
	    add_warning($$,$$,"Could not update file ftp://ftp.wwpdb.org/pub/pdb/derived_data/pdb_entry_type.txt. Older Version [$cache_file]($m Month(s) old) will be used instead");
	    return $cache_file;
	  }
	else
	  {
	    return $new_file;
	  }
      }
  }



sub get_unrealeased_file
  {
    my $cache_file="$cache/unrealeased.xml";
    my $env_file  = $ENV{"PDB_UNREALEASED_FILE"};
    my $pdb_file  ="$ENV{'PDB_DIR'}/derived_data/unrealeased.xml";
    
    
    if ($env_file eq "NO" || $env_file eq "No" || $env_file eq "no" || $env_file eq "0"){return "NO";}

    if (-z $cache_file){unlink ($cache_file);}#will get updated
    if (-z $env_file){unlink($env_file);}     #will update
    if (-z $pdb_file){$pdb_file="";}          #cannot update
    
    if    (-e $env_file){return $env_file;} #env wins: user decides
    elsif (-e $pdb_file){return $pdb_file;} #local database wins: network file may be out of sync
    elsif ($no_remote_pdb_dir==1)        
      {
	if (-e $cache_file){return $cache_file;}
	elsif ( $env_file && ! -e $env_file)
	  {
	    &url2file("http://www.rcsb.org/pdb/rest/getUnreleased",$env_file);
	    if ( -e $env_file && !-z $env_file){return $env_file;}
	  }
	else
	  {
	    add_warning($$,$$,"UNREALEASED_FILE must be set to the location of your unrealeased.xml file as downloaded from http://www.rcsb.org/pdb/rest/getUnreleased when using NO_REMOTE_PDB_DIR=1");
	    return "";
	  }
      }
    else #update can only take place if the file lives in cache
      {
	my $new_file=vtmpnam ();
	if (!-e $cache_file || (-M $cache_file)>1)
	  {
	    &url2file("http://www.rcsb.org/pdb/rest/getUnreleased",$new_file);
	    if ( !-z $new_file){system ("mv $new_file $cache_file"); unlink ($new_file); $new_file=$cache_file;}
	    else {unlink($new_file);}
	  }
	else
	  {
	    $new_file=$cache_file;
	  }
	
	if (!-e $cache_file && !-e $new_file)
	  {
	    add_warning($$,$$,"Could not download http://www.rcsb.org/pdb/rest/getUnreleased");
	    return "";
	  }
	elsif (-e $cache_file && !-e $new_file)
	  {
	    my $m=(-M $cache_file);
	    add_warning($$,$$,"Could not update file http://www.rcsb.org/pdb/rest/getUnreleased. Older Version [$cache_file]($m Month(s) ) will be used");
	    return $cache_file;
	  }
	else
	  {
	    return $new_file;
	  }
      }
  }

sub is_released 
  {
    my ($r);
    my $in=@_[0];
    my $name=&remote_is_pdb_name ($in);
    my $hold=&remote_is_on_hold($in);
    
    $r=($name && !$hold)?1:0;
    return $r;
  }

sub remote_is_pdb_name 
  {
    my $in=@_[0];
    my ($pdb);
    my ($value,$value1,$value2);
    my $max=2;
    
    
    
    my $ref_file=&get_pdb_entry_type_file();
    
    if ( $in=~/[^\w\d\:\_]/){return 0;}
    elsif (!-e $ref_file)
      {
	add_warning ($$,$$,"Cannot find pdb_entry_type.txt;  $in is assumed to be valid; add ftp://ftp.wwpdb.org/pub/pdb/derived_data/pdb_entry_type.txt in $cache to automatically check name status");
	return 1;
      }
    else
      {
	$pdb=substr ($in,0, 4);
	chomp(($value1=`grep -c $pdb $ref_file`));
	$pdb=lc($pdb);
	chomp(($value2=`grep -c $pdb $ref_file`));
	$value=($value1 || $value2)?1:0;
	$value=($value>0)?1:0;
	
	return $value;
      }
  }



sub pdb2model_type
{
    my $in=@_[0];
    my ($ref_file, $pdb);
    my ($value, $ret);

    if ( $in=~/[^\w\d\:\_]/){return 0;}
    $ref_file=&get_pdb_entry_type_file();
    if (!-e $ref_file)
      {
	add_warning ($$,$$,"Cannot find pdb_entry_type.txt;  $in is assumed to be diffraction; add ftp://ftp.wwpdb.org/pub/pdb/derived_data/pdb_entry_type.txt in $cache to check name status");
	return "diffraction";
      }
    else
      {
	$pdb=substr ($in,0, 4);
	$pdb=lc($pdb);
	
	chomp(($value=`grep $pdb $ref_file`));
	
	$value=~/^\S+\s+\S+\s+(\S+)/;
	$ret=$1;
	if ( $ret eq""){return "UNKNOWN";}
	
	return $ret;
      }
  }
sub remote_is_on_hold
  {
    my $in=@_[0];
    my ($ref_file, $pdb);
    my ($value1, $value2,$value);
    


    
    $ref_file=&get_unrealeased_file();
    if ($ref_file eq "NO"){return 0;}


    if ($no_remote_pdb==1){return 0;}
    if ( $in=~/[^\w\d\:\_]/){return 0;}
    
    $ref_file=&get_unrealeased_file();
    if (!-e $ref_file)
      {
	add_warning ($$,$$,"Cannot find unrealeased.xml;  $in is assumed to be released;");
	return 1;
      }
    
    $pdb=substr ($in,0, 4);
    chomp(($value1=`grep -c $pdb $ref_file`));
    $pdb=lc($pdb);
    chomp(($value2=`grep -c $pdb $ref_file`));
    $value=($value1 || $value2)?1:0;
    $value=($value>0)?1:0;
    return $value;
  }

sub is_pdb_file
  {
    my @arg=@_;
    
    if ( !-e $arg[0]){return 0;}
    
    $F=vfopen ($arg[0], "r");
    while ( <$F>)
      {
	if (/^HEADER/)
	  {
	    close $F;
	    return 1;
	  }
	elsif ( /^SEQRES/)
	  {
	    close $F;
	    return 1;
	  }
	elsif ( /^ATOM/)
	  {
	    close $F;
	    return 1;
	  }
      }
    return 0;
  }
sub get_pdb_id
{
    my $header_file=@_[0];
    my $id;
    my $F= new FileHandle;
    
    
    $F=vfopen ("$header_file", "r");

    while ( <$F>)
      {
	if ( /HEADER/)
	  {
	    if ($debug){print "$_";}
	    $id=substr($_,62,4 );
	    return $id;
	  }
      }
    close ($F);
    
    return "";
}

sub get_ligand_list
{
    my $pdb_file=@_[0];
    my $chain;
    my $ligand;
    my %complete_ligand_list;
    

    $F=vfopen ($pdb_file, "r");
    while ( <$F>)
{
	if ( /^HETATM/)
{
	    $line=$_;
	    $chain=substr($line,21,1);
	    $ligand=substr($line,17,3);
	    
	    if (!$complete_ligand_list{$chain}{$ligand})
{
		
		$complete_ligand_list{"result"}.="CHAIN $chain LIGAND $ligand\n";
		$complete_ligand_list{$chain}{$ligand}=1;
}
}
}
    close ($F);
    return %complete_ligand_list;
}

sub get_chain_list 
{
    my $header_file;
    my @chain_list;
    my @list;
    my $n_chains;
    my %chain_hasch;
    my $pdb_file=@_[0];
    my $c;
    my %hasch;
    my $chain;
  
    
    $F=vfopen ($pdb_file, "r");
    while ( <$F>)
{


	if (/SEQRES\s+\d+\s+(\S+)/)
	  {
	    $chain = substr($_,11,1);$chain=~s/\s//g;if ( $chain eq ""){$chain=" ";}
	    if (!$hasch{$chain}){$hasch{$chain}=1;push @chain_list, $chain;}
	  }
	if (/^ATOM/ || /^HETATM/)
	  {
	    $chain = substr($_,21,1); $chain=~s/\s//g;if ( $chain eq ""){$chain=" ";}
	    if (!$hasch{$chain}){$hasch{$chain}=1;push @chain_list, $chain;}
	  }
      }


close ($F);
if (!@chain_list)
  {
    @chain_list=("A");
  }


return @chain_list;
}

sub token_is_in_list
{

    my @list=@_;
    my $a;
    
    for ($a=1; $a<=$#list; $a++)
{
	if ( $list[$a] eq $list[0]){return $a;}
}
}

sub pdb_name2name_and_chain 
{
    my $pdb_file=@_[0];
    my $pdb_file_in;
    my @array;
    my $chain;
    my $c;

    $pdb_file_in=$pdb_file;

    $pdb_file=~/^(.{4})/;$pdb_id=$1;
    @array=($pdb_file=~/([\w])/g);
  
  
    $chain=uc ($array[4]);
    $chain=($chain eq "")?"FIRST":$chain;
    
    return ( $pdb_id, $chain);

    if ( $#array==3){return ($pdb_id, "FIRST");}
    elsif ( $#array<4){ return ($pdb_id, "");}
    else {return ( $pdb_id, $chain);}
      
    
    
}
sub get_main_hom_code 
{
    my $pdb_file=@_[0];
    my %hom, $n, $best, $best_h;
    open (F, $pdb_file);
    while (<F>)
{
	if ( $_=~/^ATOM/)
{
	    $h=substr ($_,26, 1);
	    $n=++$hom{$h};
	    if ($n>$best)
{
		$best=$n;
		$best_h=$h;
}
}
}
    close (F);
    return $best_h;
}


sub get_pdb_file 
{
    my ($pdb_file_in)=(@_);
    my $result;
    my @letter;
    my @chain;
    my $v;
    my $pdb_file=$pdb_file_in;

    $pdb_file=($pdb_file_in=~/\S+_S_(\S+)/)?$1:$pdb_file_in;
    
    if ($no_remote_pdb_dir==0)
      {
	$no_remote_pdb_dir=1;
	$result=get_pdb_file3 ($pdb_file);
	$no_remote_pdb_dir=0;
	if ( $result){return $result;}
	else
	  {
	    
	    lc ($pdb_file);
	    $result=get_pdb_file3($pdb_file);
	    return  $result;
	  }
      }
    else
      {
	return get_pdb_file3 ($pdb_file);
      }
    
  }

sub get_pdb_file3 
{
    my $pdb_file_in=@_[0];
    my $result;
    my @letter;
    my @chain;
    my $lcfile;
    my $ucfile;
    my $pdb_file=$pdb_file_in;
    
    $lcfile=lc $pdb_file;
    $ucfile=uc $pdb_file;

    if ( ($result=get_pdb_file2 ($pdb_file))){return $result;}
    

    if ($lcfile ne $pdb_file && ($result=get_pdb_file2 ($lcfile))){return $result;}
    if ($ucfile ne $pdb_file && ($result=get_pdb_file2 ($ucfile))){return $result;}
    
   
    
    return "";
}
sub get_pdb_file2
{
    my $pdb_file=@_[0];
    my $return_value;
    
    $return_value="";
    
    if ( ($result=get_pdb_file1 ($pdb_file))){$return_value=$result;}
    elsif ( !($pdb_file=~/\.pdb/) && !($pdb_file=~/\.PDB/))
{
	if ( ($result=get_pdb_file1 ("$pdb_file.pdb"))){$return_value=$result;}
	elsif ( ($result=get_pdb_file1 ("$pdb_file.PDB"))){$return_value=$result;}

	elsif ( ($result=get_pdb_file1 ("pdb$pdb_file.pdb"))){$return_value=$result;}	
	elsif ( ($result=get_pdb_file1 ("pdb$pdb_file.PDB"))){$return_value=$result;}
	elsif ( ($result=get_pdb_file1 ("PDB$pdb_file.PDB"))){$return_value=$result;}
	elsif ( ($result=get_pdb_file1 ("PDB$pdb_file.pdb"))){$return_value=$result;}
	
	
	elsif ( ($result=get_pdb_file1 ("$pdb_file.ent"))){$return_value=$result;}
	elsif ( ($result=get_pdb_file1 ("pdb$pdb_file.ent"))){$return_value=$result;}
	elsif ( ($result=get_pdb_file1 ("PDB$pdb_file.ent"))){$return_value=$result;}

	elsif ( ($result=get_pdb_file1 ("$pdb_file.ENT"))){$return_value=$result;}
	elsif ( ($result=get_pdb_file1 ("pdb$pdb_file.ENT"))){$return_value=$result;}
	elsif ( ($result=get_pdb_file1 ("PDB$pdb_file.ENT"))){$return_value=$result;}
	
	
	
}
    return $return_value;
}
    
sub get_pdb_file1
{
    my ($pdb_file)=(@_);
    my $return_value;
    

    $return_value="";
    if ( ($result=get_pdb_file0 ($pdb_file))){$return_value=$result;}
    elsif ( ($result=get_pdb_file0 ("$pdb_file.Z"))){$return_value=$result;}
    elsif ( ($result=get_pdb_file0 ("$pdb_file.gz"))){$return_value=$result;}
    elsif ( ($result=get_pdb_file0 ("$pdb_file.GZ"))){$return_value=$result;}
    return $return_value;
}
sub get_pdb_file0 
{ 
    my ($pdb_file, $attempt)=(@_);
    my $pdb_file=@_[0];
    my $tmp_pdb_file;    
    my $return_value;

    if ( !$attempt){$attempt=1;}
    
    $local_pdb_file="$pdb_file";
    if ( $local_pdb_file eq "")
{
	$tmp_pdb_file=vtmpnam();
	open F, ">$tmp_pdb_file";
	
	while (<STDIN>){print F "$_";}
	close (F);
	
	if (-e $tmp_pdb_file && &is_pdb_file ( $local_pdb_file))
{return $tmp_pdb_file;}
}

    $local_pdb_file="$pdb_file";
    &debug_print ("\nTry access local file: $local_pdb_file");
    
    $local_pdb_file=&check_pdb_file4compression ($local_pdb_file);
    if ( -e $local_pdb_file && (&is_pdb_file ($local_pdb_file) || $force_pdb))
{
	&debug_print ( "\n\tIs in Current Dir");
	$tmp_pdb_file=vtmpnam();
	`cp $local_pdb_file $tmp_pdb_file`;
	return $tmp_pdb_file;
}
    else
{
	&debug_print ("\n\tFile Not in Current Dir");
}

    if ($pdb_file=~/^pdb/||$pdb_file=~/^PDB/){$pdb_div=substr ($pdb_file, 4, 2);}
    else
{
	  $pdb_div=substr ($pdb_file, 1, 2);
}
    $local_pdb_file="$pdb_dir/$pdb_div/$pdb_file";
    $local_pdb_file=&check_pdb_file4compression ( $local_pdb_file);
    &debug_print ("\nTry access file From PDB_DIR: $local_pdb_file");
    if ($pdb_dir && -e $local_pdb_file && &is_pdb_file ($local_pdb_file))
{
	&debug_print ( "\n\tIs in Local PDB DIR");
	$tmp_pdb_file=vtmpnam();
	`cp $local_pdb_file $tmp_pdb_file`;
	return $tmp_pdb_file;
}

    $local_pdb_file="$pdb_dir/$pdb_file";
    $local_pdb_file=&check_pdb_file4compression ( $local_pdb_file);
    &debug_print ("\nTry access file From PDB_DIR: local_pdb_file");
    if ($pdb_dir && -e $local_pdb_file && &is_pdb_file ($local_pdb_file))
{
	&debug_print ( "\n\tIs in Local PDB DIR");
	$tmp_pdb_file=vtmpnam();
	`cp $local_pdb_file $tmp_pdb_file`;
	return $tmp_pdb_file;
}

    $local_pdb_file="$pdb_dir$pdb_file";
    $local_pdb_file=&check_pdb_file4compression ( $local_pdb_file);
    &debug_print ("\nTry access file From PDB_DIR: $local_pdb_file");
    if ($pdb_dir && -e $local_pdb_file && &is_pdb_file ($local_pdb_file))
{
	&debug_print ( "\n\tIs in Local PDB DIR");
	$tmp_pdb_file=vtmpnam();
	`cp $local_pdb_file $tmp_pdb_file`;
	return $tmp_pdb_file;
}
    else
{&debug_print ( "\n\tNot In Local Pdb Dir");}

    if ($cache ne "NO" && $cache ne "no")
{

	$local_pdb_file="$cache/$pdb_file";
	$local_pdb_file=&check_pdb_file4compression ( $local_pdb_file);
	&debug_print("\nTry access file From Cache: $local_pdb_file");
	if (-e $local_pdb_file && &is_pdb_file ($local_pdb_file))
{
	    &debug_print ( "\n\tIs in T-Coffee Cache");
	    $tmp_pdb_file=vtmpnam();
	    `cp $local_pdb_file $tmp_pdb_file`;
	    return $tmp_pdb_file;
}
	else{&debug_print ( "\n\tNot in Cache Dir");}
}

if (!$no_remote_pdb_dir) 
  {
    my $value=&is_released ($pdb_file);
    my $return_value="";
    if ($value==1)
      {
	
	&debug_print ("\n*****************************************************\nTry Remote Access for $pdb_file");
	$tmp_pdb_file=vtmpnam();
	$netcommand=$netaddress;
	$netcommand=~s/%%/$pdb_file/g;
	&url2file("$netcommand", "$tmp_pdb_file.$netcompression");
	&debug_print("\nREMOTE: $netcommand\n");
	
	$compressed_tmp_file_name="$tmp_pdb_file.$netcompression";
	
	if ($netcompression && -B $compressed_tmp_file_name && $attempt<5)
	  {
	    my $r;
	    &debug_print ("\n\tFile Found Remotely");
	    if (($r=safe_system ( "$netcompression_pg $compressed_tmp_file_name")!=$EXIT_SUCCESS) && $attempts<5)
	      {
		&debug_print ("\n\tProper Download Failed Try again");
		unlink $compressed_tmp_file_name;
		print "\nFailed to Download $compressed_tmp_file_name. New Attempt $attempt/5\n";
		return &get_pdb_file0($pdb_file, $attempt+1);
	      }
	    elsif ($r== $EXIT_SUCCESS)
	      {
		&debug_print ("\n\tProper Download Succeeded ");
		$return_value=$tmp_pdb_file;
	      }
	    else
	      {
		&debug_print ("\n\tProper Download Failed ");
		&debug_print ("\nFile Not Found Remotely");
		unlink $compressed_tmp_file_name;
	      }
	  }
	else
	  {

	    &debug_print ("\nFile Not Found Remotely");
	    unlink $compressed_tmp_file_name;
	  }
	#Update cache if required
	if ($cache ne "no" && $cache ne "update" && -e $return_value)
	  {
	    `cp $return_value $cache/$pdb_file.pdb`;
	    #`t_coffee -other_pg clean_cache.pl -file $pdb_file.pdb -dir $cache`;
	  }
      }
    &debug_print ("\nRemote Download Finished");
    return $return_value;
  }
return "";
}

sub check_pdb_file4compression 
{
    my $file=@_[0];
    my $tmp;
    my $r;
    
    $tmp=&vtmpnam();
    if (-e $tmp){unlink $tmp;}
    
    $file=~s/\/\//\//g;
    if    (-B $file && ($file=~/\.Z/)) {`cp $file $tmp.Z`;`rm $tmp`;`gunzip $tmp.Z $SILENT`;$r=$tmp;}
    elsif (-B $file && ($file=~/\.gz/)){`cp $file $tmp.gz`;`gunzip $tmp.gz $SILENT`;return $r=$tmp;}
    elsif (-B $file ){`cp $file $tmp.gz`;`gunzip $tmp.gz $SILENT`;$r=$tmp;}
    elsif ( -e $file ) {$r= $file;}
    elsif ( -e "$file.gz" ){ `cp $file.gz $tmp.gz`;`gunzip     $tmp.gz $SILENT`;$r=$tmp;}    
    elsif ( -e "$file.Z") {`cp $file.Z  $tmp.Z`; `gunzip $tmp.Z $SILENT`;$r=$tmp;}
    else  {$r= $file;}

    if ( -e "$tmp.Z"){unlink "$tmp.Z";}
    if ( -e "$tmp.gz"){unlink "$tmp.gz";}
    
    return $r;
    
}





    







sub vfopen 
{
    my $file=@_[0];
    my $mode=@_[1];
    my $tmp;
    my $F = new FileHandle;
    
    
    $tmp=$file;
	
    
    if ( $mode eq "r" && !-e $file){ myexit(flush_error ("Cannot open file $file"));}
    elsif ($mode eq "w"){$tmp=">$file";}
    elsif ($mode eq "a"){$tmp=">>$file";}
    
    
    open ($F,$tmp);
    return $F;
}
sub debug_print
{
    my $message =@_[0];
    if ($debug){print STDERR "NO_REMOTE_PDB_DIR: $no_remote_pdb_dir - $message [DEBUG:extract_from_pdb]";}
    return;
}
sub is_aa 
{
    my ($aa, $chain) =@_;

    my $one;
    my $trhee;
    
    if ( $onelett{$molecule_type{$chain}}->{$aa} eq 'X' || !$onelett{$molecule_type{$chain}}->{$aa} ){return '';}
    else
      {
	$one=$onelett{$molecule_type{$chain}}->{$aa};

	$three=$threelett{$molecule_type{$chain}}->{$one};
	

	return $three;
      }
  }





sub url2file
{
    my ($address, $out, $wget_arg, $curl_arg)=(@_);
    my ($pg, $flag, $r, $arg, $count);
    
    if (!$CONFIGURATION){&check_configuration ("wget", "INTERNET", "gzip");$CONFIGURATION=1;}
    
    if (&pg_is_installed ("wget"))   {$pg="wget"; $flag="-O";$arg=$wget_arg;}
    elsif (&pg_is_installed ("curl")){$pg="curl"; $flag="-o";$arg=$curl_arg;}
    return safe_system ("$pg $flag$out $address >/dev/null 2>/dev/null");

}




sub pdbfile2chaintype
  {
    my $file=@_[0];
    my %ct;
    my $F;
    
    $F=vfopen ($file, "r");
    while (<$F>)
      {
	my $line=$_;
	if ($line =~/^ATOM/)
	  {
	    my $C=substr($line,21,1);
	    if (!$ct{$C})
	      {	
		my $r=substr($line,17,3);
		$r=~s/\s+//;
		if (length ($r)==1){$ct{$C}="R";}
		elsif (length ($r)==2){$ct{$C}="D";}
		elsif (length ($r)==3){$ct{$C}="P";}
		else 
		  {
		    myexit(flush_error("ERROR: Could not read RES_ID field in file $file"));
		  }
	      }
	  }
      }
    close ($F);
    return %ct;
  }
   
    



sub fill_threelett_RNA
{

	my %threelett=(
	'A', '  A',
	'T', '  T',
	'U', '  U',
	'C', '  C',
	'G', '  G',
	'I', '  I', #Inosine
	);
	
	return %threelett;

}


sub fill_onelett_RNA
{
	my   %onelett=(
	'  A' => 'A',
	'  T' => 'T',
	'  U' => 'U',
	'  C' => 'C',
	'  G' => 'G',
	'CSL' => 'X',
	'UMS' => 'X',
	'  I' => 'I',
	'A' => 'A',
	'T' => 'T',
	'U' => 'U',
	'C' => 'C',
	'G' => 'G',
	'I' => 'I',
	);

	return %onelett;

}


sub fill_onelett_DNA
{
	my   %onelett=(
	' DA', 'A',
	' DT', 'T',
	' DC', 'C',
	' DG', 'G',
	'DA', 'A',
	'DT', 'T',
	'DC', 'C',
	'DG', 'G',
	);

	return %onelett;

}

sub fill_threelett_DNA
{

	my %threelett=(
	'A', ' DA',
	'T', ' DT',
	'C', ' DC',
	'G', ' DG',
	);

	return %threelett;

}




sub fill_threelett_prot
{  
  my %threelett;

  %threelett=(
'A', 'ALA',
'C', 'CYS',
'D', 'ASP',
'E', 'GLU',
'F', 'PHE',
'G', 'GLY',
'H', 'HIS',
'I', 'ILE',
'K', 'LYS',
'L', 'LEU',
'N', 'ASN',
'M', 'MET',
'P', 'PRO',
'Q', 'GLN',
'R', 'ARG',
'S', 'SER',
'T', 'THR',
'V', 'VAL',
'W', 'TRP',
'Y', 'TYR',
);

return %threelett;


}

sub fill_onelett_prot
{
    my %onelett;
    
    %onelett=(

'10A', 'X',
'11O', 'X',
'12A', 'X',
'13P', 'X',
'13R', 'X',
'13S', 'X',
'14W', 'X',
'15P', 'X',
'16A', 'X',
'16G', 'X',
'1AN', 'X',
'1AP', 'X',
'1AR', 'X',
'1BH', 'X',
'1BO', 'X',
'1C5', 'X',
'1CU', 'X',
'1DA', 'X',
'1GL', 'X',
'1GN', 'X',
'1IN', 'X',
'1LU', 'L',
'1MA', 'X',
'1MC', 'X',
'1MG', 'X',
'1MZ', 'X',
'1NA', 'X',
'1NB', 'X',
'1NI', 'X',
'1PA', 'A',
'1PC', 'X',
'1PE', 'X',
'1PG', 'X',
'1PI', 'A',
'1PM', 'X',
'1PN', 'X',
'1PU', 'X',
'1PY', 'X',
'1UN', 'X',
'24T', 'X',
'25T', 'X',
'26P', 'X',
'2AB', 'X',
'2AM', 'X',
'2AN', 'X',
'2AP', 'X',
'2AR', 'X',
'2AS', 'D',
'2BL', 'X',
'2BM', 'X',
'2CP', 'X',
'2DA', 'X',
'2DG', 'X',
'2DP', 'X',
'2DT', 'X',
'2EP', 'X',
'2EZ', 'X',
'2FG', 'X',
'2FL', 'X',
'2FP', 'X',
'2FU', 'X',
'2GL', 'X',
'2GP', 'X',
'2HP', 'X',
'2IB', 'X',
'2IP', 'X',
'2LU', 'L',
'2MA', 'X',
'2MD', 'X',
'2ME', 'X',
'2MG', 'X',
'2ML', 'L',
'2MO', 'X',
'2MR', 'R',
'2MU', 'X',
'2MZ', 'X',
'2NO', 'X',
'2NP', 'X',
'2OG', 'X',
'2PA', 'X',
'2PC', 'X',
'2PE', 'X',
'2PG', 'X',
'2PH', 'X',
'2PI', 'X',
'2PL', 'X',
'2PP', 'X',
'2PU', 'X',
'2SI', 'X',
'2TB', 'X',
'34C', 'X',
'35G', 'X',
'3AA', 'X',
'3AD', 'X',
'3AH', 'H',
'3AN', 'X',
'3AP', 'X',
'3AT', 'X',
'3BT', 'X',
'3CH', 'X',
'3CN', 'X',
'3CO', 'X',
'3CP', 'X',
'3DR', 'X',
'3EP', 'X',
'3FM', 'X',
'3GA', 'X',
'3GP', 'X',
'3HB', 'X',
'3HC', 'X',
'3HP', 'X',
'3IB', 'X',
'3ID', 'X',
'3IN', 'X',
'3MA', 'X',
'3MB', 'X',
'3MC', 'X',
'3MD', 'D',
'3MF', 'X',
'3MP', 'X',
'3MT', 'X',
'3OL', 'X',
'3PA', 'X',
'3PG', 'X',
'3PO', 'X',
'3PP', 'X',
'3PY', 'X',
'49A', 'X',
'4AB', 'X',
'4AM', 'X',
'4AN', 'X',
'4AP', 'X',
'4BA', 'X',
'4BT', 'X',
'4CA', 'X',
'4CO', 'X',
'4HP', 'X',
'4IP', 'X',
'4MO', 'X',
'4MV', 'X',
'4MZ', 'X',
'4NC', 'X',
'4NP', 'X',
'4OX', 'X',
'4PB', 'X',
'4PN', 'X',
'4PP', 'X',
'4SC', 'X',
'4SU', 'X',
'4TB', 'X',
'55C', 'X',
'5AD', 'X',
'5AN', 'X',
'5AT', 'X',
'5CM', 'X',
'5GP', 'X',
'5HP', 'E',
'5HT', 'X',
'5IT', 'X',
'5IU', 'X',
'5MB', 'X',
'5MC', 'X',
'5MD', 'X',
'5MP', 'X',
'5MU', 'X',
'5NC', 'X',
'5OB', 'X',
'5PA', 'X',
'5PV', 'X',
'6AB', 'X',
'6CT', 'X',
'6HA', 'X',
'6HC', 'X',
'6HG', 'X',
'6HT', 'X',
'6IN', 'X',
'6MO', 'X',
'6MP', 'X',
'6PG', 'X',
'6WO', 'X',
'70U', 'X',
'7DG', 'X',
'7HP', 'X',
'7I2', 'X',
'7MG', 'X',
'7MQ', 'X',
'7NI', 'X',
'87Y', 'X',
'8AD', 'X',
'8BR', 'X',
'8IG', 'X',
'8IN', 'X',
'8OG', 'X',
'95A', 'X',
'9AD', 'X',
'9AM', 'X',
'9AP', 'X',
'9DG', 'X',
'9DI', 'X',
'9HX', 'X',
'9OH', 'X',
'9TA', 'X',
'A12', 'X',
'A15', 'X',
'A23', 'X',
'A24', 'X',
'A26', 'X',
'A2G', 'X',
'A2P', 'X',
'A32', 'X',
'A3P', 'X',
'A4P', 'X',
'A5P', 'X',
'A70', 'X',
'A76', 'X',
'A77', 'X',
'A78', 'X',
'A79', 'X',
'A80', 'X',
'A85', 'X',
'A88', 'X',
'A9A', 'X',
'AA3', 'X',
'AA4', 'X',
'AA6', 'X',
'AAA', 'X',
'AAB', 'X',
'AAC', 'X',
'AAE', 'X',
'AAG', 'R',
'AAH', 'X',
'AAM', 'X',
'AAN', 'X',
'AAP', 'X',
'AAR', 'R',
'AAS', 'X',
'AAT', 'X',
'ABA', 'X',
'ABC', 'X',
'ABD', 'X',
'ABE', 'X',
'ABH', 'X',
'ABI', 'X',
'ABK', 'X',
'ABM', 'X',
'ABN', 'X',
'ABP', 'X',
'ABR', 'X',
'ABS', 'X',
'ABU', 'X',
'AC1', 'X',
'AC2', 'X',
'ACA', 'X',
'ACB', 'D',
'ACC', 'C',
'ACD', 'X',
'ACE', 'X',
'ACH', 'X',
'ACI', 'X',
'ACL', 'R',
'ACM', 'X',
'ACN', 'X',
'ACO', 'X',
'ACP', 'X',
'ACQ', 'X',
'ACR', 'X',
'ACS', 'X',
'ACT', 'X',
'ACV', 'V',
'ACX', 'X',
'ACY', 'X',
'AD2', 'X',
'AD3', 'X',
'ADC', 'X',
'ADD', 'X',
'ADE', 'X',
'ADH', 'X',
'ADI', 'X',
'ADM', 'X',
'ADN', 'X',
'ADP', 'X',
'ADQ', 'X',
'ADR', 'X',
'ADS', 'X',
'ADT', 'X',
'ADU', 'X',
'ADW', 'X',
'ADX', 'X',
'AE2', 'X',
'AEA', 'X',
'AEB', 'X',
'AEI', 'D',
'AEN', 'X',
'AET', 'T',
'AF1', 'X',
'AF3', 'X',
'AFA', 'D',
'AFP', 'X',
'AG7', 'X',
'AGB', 'X',
'AGF', 'X',
'AGL', 'X',
'AGM', 'R',
'AGN', 'X',
'AGP', 'X',
'AGS', 'X',
'AGU', 'X',
'AH0', 'X',
'AH1', 'X',
'AHA', 'X',
'AHB', 'D',
'AHC', 'X',
'AHF', 'X',
'AHG', 'X',
'AHH', 'X',
'AHM', 'X',
'AHO', 'X',
'AHP', 'X',
'AHS', 'X',
'AHT', 'Y',
'AHU', 'X',
'AHX', 'X',
'AI1', 'X',
'AI2', 'X',
'AIB', 'X',
'AIC', 'X',
'AIM', 'X',
'AIP', 'X',
'AIQ', 'X',
'AIR', 'X',
'AJ3', 'X',
'AKB', 'X',
'AKG', 'X',
'AKR', 'X',
'AL1', 'X',
'AL2', 'X',
'AL3', 'X',
'AL4', 'X',
'AL5', 'X',
'AL6', 'X',
'AL7', 'X',
'AL8', 'X',
'AL9', 'X',
'ALA', 'A',
'ALB', 'X',
'ALC', 'X',
'ALD', 'L',
'ALE', 'X',
'ALF', 'X',
'ALG', 'X',
'ALL', 'X',
'ALM', 'A',
'ALN', 'A',
'ALO', 'T',
'ALP', 'X',
'ALQ', 'X',
'ALR', 'X',
'ALS', 'X',
'ALT', 'A',
'ALY', 'K',
'ALZ', 'X',
'AMA', 'X',
'AMB', 'X',
'AMC', 'X',
'AMD', 'X',
'AMG', 'X',
'AMH', 'X',
'AMI', 'X',
'AML', 'X',
'AMN', 'X',
'AMO', 'X',
'AMP', 'X',
'AMQ', 'X',
'AMR', 'X',
'AMS', 'X',
'AMT', 'X',
'AMU', 'X',
'AMW', 'X',
'AMX', 'X',
'AMY', 'X',
'ANA', 'X',
'ANB', 'X',
'ANC', 'X',
'AND', 'X',
'ANE', 'X',
'ANI', 'X',
'ANL', 'X',
'ANO', 'X',
'ANP', 'X',
'ANS', 'X',
'ANT', 'X',
'AOE', 'X',
'AOP', 'X',
'AP1', 'X',
'AP2', 'X',
'AP3', 'X',
'AP4', 'X',
'AP5', 'X',
'AP6', 'X',
'APA', 'X',
'APB', 'X',
'APC', 'X',
'APE', 'F',
'APF', 'X',
'APG', 'X',
'APH', 'A',
'API', 'X',
'APL', 'X',
'APM', 'X',
'APN', 'G',
'APP', 'X',
'APQ', 'X',
'APR', 'X',
'APS', 'X',
'APT', 'X',
'APU', 'X',
'APX', 'X',
'APY', 'X',
'APZ', 'X',
'AQS', 'X',
'AR1', 'X',
'AR2', 'X',
'ARA', 'X',
'ARB', 'X',
'ARC', 'X',
'ARD', 'X',
'ARG', 'R',
'ARH', 'X',
'ARI', 'X',
'ARM', 'R',
'ARN', 'X',
'ARO', 'R',
'ARP', 'X',
'ARQ', 'X',
'ARS', 'X',
'AS1', 'R',
'AS2', 'X',
'ASA', 'D',
'ASB', 'D',
'ASC', 'X',
'ASD', 'X',
'ASE', 'X',
'ASF', 'X',
'ASI', 'X',
'ASK', 'D',
'ASL', 'X',
'ASM', 'N',
'ASO', 'X',
'ASP', 'D',
'ASQ', 'X',
'ASU', 'X',
'ATA', 'X',
'ATC', 'X',
'ATD', 'X',
'ATF', 'X',
'ATG', 'X',
'ATH', 'X',
'ATM', 'X',
'ATO', 'X',
'ATP', 'X',
'ATQ', 'X',
'ATR', 'X',
'ATT', 'X',
'ATY', 'X',
'ATZ', 'X',
'AUC', 'X',
'AUR', 'X',
'AVG', 'X',
'AXP', 'X',
'AYA', 'A',
'AZ2', 'X',
'AZA', 'X',
'AZC', 'X',
'AZD', 'X',
'AZE', 'X',
'AZI', 'X',
'AZL', 'X',
'AZM', 'X',
'AZR', 'X',
'AZT', 'X',
'B12', 'X',
'B1F', 'F',
'B2A', 'A',
'B2F', 'F',
'B2I', 'I',
'B2V', 'V',
'B3I', 'X',
'B3P', 'X',
'B7G', 'X',
'B96', 'X',
'B9A', 'X',
'BA1', 'X',
'BAA', 'X',
'BAB', 'X',
'BAC', 'X',
'BAF', 'X',
'BAH', 'X',
'BAI', 'X',
'BAK', 'X',
'BAL', 'A',
'BAM', 'X',
'BAO', 'X',
'BAP', 'X',
'BAR', 'X',
'BAS', 'X',
'BAT', 'F',
'BAY', 'X',
'BAZ', 'X',
'BB1', 'X',
'BB2', 'X',
'BBA', 'X',
'BBH', 'X',
'BBS', 'X',
'BBT', 'X',
'BBZ', 'X',
'BCA', 'X',
'BCB', 'X',
'BCC', 'X',
'BCD', 'X',
'BCL', 'X',
'BCN', 'X',
'BCR', 'X',
'BCS', 'C',
'BCT', 'X',
'BCY', 'X',
'BCZ', 'X',
'BDA', 'X',
'BDG', 'X',
'BDK', 'X',
'BDM', 'X',
'BDN', 'X',
'BDS', 'X',
'BE1', 'X',
'BE2', 'X',
'BEA', 'X',
'BEF', 'X',
'BEN', 'X',
'BEO', 'X',
'BEP', 'X',
'BER', 'X',
'BES', 'X',
'BET', 'X',
'BEZ', 'X',
'BF2', 'X',
'BFA', 'X',
'BFD', 'X',
'BFP', 'X',
'BFS', 'X',
'BFU', 'X',
'BG6', 'X',
'BGF', 'X',
'BGG', 'X',
'BGL', 'X',
'BGN', 'X',
'BGP', 'X',
'BGX', 'X',
'BH4', 'X',
'BHA', 'X',
'BHC', 'X',
'BHD', 'D',
'BHO', 'X',
'BHS', 'X',
'BIC', 'X',
'BIN', 'X',
'BIO', 'X',
'BIP', 'X',
'BIS', 'X',
'BIZ', 'X',
'BJH', 'X',
'BJI', 'X',
'BJP', 'X',
'BLA', 'X',
'BLB', 'X',
'BLE', 'L',
'BLG', 'P',
'BLI', 'X',
'BLM', 'X',
'BLV', 'X',
'BLY', 'K',
'BM1', 'X',
'BM2', 'X',
'BM5', 'X',
'BM9', 'X',
'BMA', 'X',
'BMD', 'X',
'BME', 'X',
'BMP', 'X',
'BMQ', 'X',
'BMS', 'X',
'BMT', 'T',
'BMU', 'X',
'BMY', 'X',
'BMZ', 'X',
'BNA', 'X',
'BNG', 'X',
'BNI', 'X',
'BNN', 'F',
'BNO', 'L',
'BNS', 'X',
'BNZ', 'X',
'BO3', 'X',
'BO4', 'X',
'BOC', 'X',
'BOG', 'X',
'BOM', 'X',
'BOT', 'X',
'BOX', 'X',
'BOZ', 'X',
'BPA', 'X',
'BPB', 'X',
'BPD', 'X',
'BPG', 'X',
'BPH', 'X',
'BPI', 'X',
'BPJ', 'X',
'BPM', 'X',
'BPN', 'X',
'BPO', 'X',
'BPP', 'X',
'BPT', 'X',
'BPY', 'X',
'BRB', 'X',
'BRC', 'X',
'BRE', 'X',
'BRI', 'X',
'BRL', 'X',
'BRM', 'X',
'BRN', 'X',
'BRO', 'X',
'BRS', 'X',
'BRU', 'X',
'BRZ', 'X',
'BSB', 'X',
'BSI', 'X',
'BSP', 'X',
'BT1', 'X',
'BT2', 'X',
'BT3', 'X',
'BTA', 'L',
'BTB', 'X',
'BTC', 'C',
'BTD', 'X',
'BTN', 'X',
'BTP', 'X',
'BTR', 'W',
'BU1', 'X',
'BUA', 'X',
'BUB', 'X',
'BUC', 'X',
'BUG', 'X',
'BUL', 'X',
'BUM', 'X',
'BUQ', 'X',
'BUT', 'X',
'BVD', 'X',
'BX3', 'X',
'BYS', 'X',
'BZ1', 'X',
'BZA', 'X',
'BZB', 'X',
'BZC', 'X',
'BZD', 'X',
'BZF', 'X',
'BZI', 'X',
'BZM', 'X',
'BZO', 'X',
'BZP', 'X',
'BZQ', 'X',
'BZS', 'X',
'BZT', 'X',
'C02', 'X',
'C11', 'X',
'C1O', 'X',
'C20', 'X',
'C24', 'X',
'C2F', 'X',
'C2O', 'X',
'C2P', 'X',
'C3M', 'X',
'C3P', 'X',
'C3X', 'X',
'C48', 'X',
'C4M', 'X',
'C4X', 'X',
'C5C', 'X',
'C5M', 'X',
'C5P', 'X',
'C5X', 'X',
'C60', 'X',
'C6C', 'X',
'C6M', 'X',
'C78', 'X',
'C8E', 'X',
'CA3', 'X',
'CA5', 'X',
'CAA', 'X',
'CAB', 'X',
'CAC', 'X',
'CAD', 'X',
'CAF', 'C',
'CAG', 'X',
'CAH', 'X',
'CAL', 'X',
'CAM', 'X',
'CAN', 'X',
'CAO', 'X',
'CAP', 'X',
'CAQ', 'X',
'CAR', 'X',
'CAS', 'C',
'CAT', 'X',
'CAV', 'X',
'CAY', 'C',
'CAZ', 'X',
'CB3', 'X',
'CB4', 'X',
'CBA', 'X',
'CBD', 'X',
'CBG', 'X',
'CBI', 'X',
'CBL', 'X',
'CBM', 'X',
'CBN', 'X',
'CBO', 'X',
'CBP', 'X',
'CBS', 'X',
'CBX', 'X',
'CBZ', 'X',
'CC0', 'X',
'CC1', 'X',
'CCC', 'X',
'CCH', 'X',
'CCI', 'X',
'CCM', 'X',
'CCN', 'X',
'CCO', 'X',
'CCP', 'X',
'CCR', 'X',
'CCS', 'C',
'CCV', 'X',
'CCY', 'X',
'CD1', 'X',
'CDC', 'X',
'CDE', 'X',
'CDF', 'X',
'CDI', 'X',
'CDL', 'X',
'CDM', 'X',
'CDP', 'X',
'CDR', 'X',
'CDU', 'X',
'CE1', 'X',
'CEA', 'C',
'CEB', 'X',
'CEC', 'X',
'CED', 'X',
'CEF', 'X',
'CEH', 'X',
'CEM', 'X',
'CEO', 'X',
'CEP', 'X',
'CEQ', 'X',
'CER', 'X',
'CES', 'G',
'CET', 'X',
'CFC', 'X',
'CFF', 'X',
'CFM', 'X',
'CFO', 'X',
'CFP', 'X',
'CFS', 'X',
'CFX', 'X',
'CGN', 'X',
'CGP', 'X',
'CGS', 'X',
'CGU', 'E',
'CH2', 'X',
'CH3', 'X',
'CHA', 'X',
'CHB', 'X',
'CHD', 'X',
'CHF', 'X',
'CHG', 'G',
'CHI', 'X',
'CHN', 'X',
'CHO', 'X',
'CHP', 'G',
'CHR', 'X',
'CHS', 'F',
'CHT', 'X',
'CHX', 'X',
'CIC', 'X',
'CIN', 'X',
'CIP', 'X',
'CIR', 'X',
'CIT', 'X',
'CIU', 'X',
'CKI', 'X',
'CL1', 'X',
'CL2', 'X',
'CLA', 'X',
'CLB', 'A',
'CLC', 'S',
'CLD', 'A',
'CLE', 'L',
'CLF', 'X',
'CLK', 'S',
'CLL', 'X',
'CLM', 'X',
'CLN', 'X',
'CLO', 'X',
'CLP', 'X',
'CLQ', 'X',
'CLR', 'X',
'CLS', 'X',
'CLT', 'X',
'CLX', 'X',
'CLY', 'X',
'CMA', 'R',
'CMC', 'X',
'CMD', 'X',
'CME', 'C',
'CMG', 'X',
'CMK', 'X',
'CMN', 'X',
'CMO', 'X',
'CMP', 'X',
'CMR', 'X',
'CMS', 'X',
'CMT', 'C',
'CMX', 'X',
'CNA', 'X',
'CNC', 'X',
'CND', 'X',
'CNH', 'X',
'CNM', 'X',
'CNN', 'X',
'CNO', 'X',
'CNP', 'X',
'CO2', 'X',
'CO3', 'X',
'CO5', 'X',
'CO8', 'X',
'COA', 'X',
'COB', 'X',
'COC', 'X',
'COD', 'X',
'COE', 'X',
'COF', 'X',
'COH', 'X',
'COI', 'X',
'COJ', 'X',
'COL', 'X',
'COM', 'X',
'CON', 'X',
'COP', 'X',
'COR', 'X',
'COS', 'X',
'COT', 'X',
'COY', 'X',
'CP1', 'G',
'CP2', 'X',
'CP4', 'X',
'CPA', 'X',
'CPB', 'X',
'CPC', 'X',
'CPD', 'X',
'CPG', 'X',
'CPH', 'X',
'CPI', 'X',
'CPM', 'X',
'CPN', 'G',
'CPO', 'X',
'CPP', 'X',
'CPQ', 'X',
'CPR', 'X',
'CPS', 'X',
'CPT', 'X',
'CPU', 'X',
'CPV', 'X',
'CPY', 'X',
'CR1', 'X',
'CR6', 'X',
'CRA', 'X',
'CRB', 'X',
'CRC', 'X',
'CRG', 'X',
'CRH', 'X',
'CRO', 'T',
'CRP', 'X',
'CRQ', 'X',
'CRS', 'X',
'CRT', 'X',
'CRY', 'X',
'CSA', 'C',
'CSB', 'X',
'CSD', 'C',
'CSE', 'C',
'CSH', 'X',
'CSI', 'X',
'CSN', 'X',
'CSO', 'C',
'CSP', 'C',
'CSR', 'C',
'CSS', 'C',
'CST', 'X',
'CSW', 'C',
'CSX', 'C',
'CSY', 'X',
'CSZ', 'C',
'CT3', 'X',
'CTA', 'X',
'CTB', 'X',
'CTC', 'X',
'CTD', 'X',
'CTH', 'T',
'CTO', 'X',
'CTP', 'X',
'CTR', 'X',
'CTS', 'X',
'CTT', 'X',
'CTY', 'X',
'CTZ', 'X',
'CU1', 'X',
'CUA', 'X',
'CUC', 'X',
'CUL', 'X',
'CUO', 'X',
'CUZ', 'X',
'CVI', 'X',
'CXF', 'X',
'CXL', 'X',
'CXM', 'M',
'CXN', 'X',
'CXP', 'X',
'CXS', 'X',
'CY1', 'C',
'CY3', 'X',
'CYB', 'X',
'CYC', 'X',
'CYF', 'C',
'CYG', 'C',
'CYH', 'X',
'CYL', 'X',
'CYM', 'C',
'CYN', 'X',
'CYO', 'X',
'CYP', 'X',
'CYQ', 'C',
'CYS', 'C',
'CYU', 'X',
'CYY', 'X',
'CYZ', 'X',
'CZH', 'X',
'CZZ', 'C',
'D12', 'X',
'D13', 'X',
'D16', 'X',
'D18', 'X',
'D19', 'X',
'D1P', 'X',
'D24', 'X',
'D34', 'X',
'D35', 'X',
'D4D', 'X',
'D4T', 'X',
'D6G', 'X',
'DA2', 'R',
'DA3', 'X',
'DA6', 'X',
'DA7', 'X',
'DAA', 'X',
'DAB', 'X',
'DAC', 'X',
'DAD', 'X',
'DAE', 'X',
'DAF', 'X',
'DAG', 'X',
'DAH', 'A',
'DAJ', 'X',
'DAK', 'X',
'DAL', 'A',
'DAM', 'A',
'DAN', 'X',
'DAO', 'X',
'DAP', 'X',
'DAQ', 'X',
'DAR', 'R',
'DAS', 'D',
'DAT', 'X',
'DAU', 'X',
'DAV', 'X',
'DBA', 'X',
'DBD', 'X',
'DBF', 'X',
'DBG', 'X',
'DBI', 'X',
'DBV', 'X',
'DBY', 'Y',
'DCA', 'X',
'DCB', 'X',
'DCE', 'X',
'DCF', 'X',
'DCG', 'X',
'DCH', 'X',
'DCI', 'I',
'DCL', 'X',
'DCM', 'X',
'DCP', 'X',
'DCS', 'X',
'DCT', 'X',
'DCY', 'C',
'DCZ', 'X',
'DDA', 'X',
'DDB', 'X',
'DDC', 'X',
'DDF', 'X',
'DDG', 'X',
'DDH', 'X',
'DDL', 'X',
'DDM', 'X',
'DDO', 'L',
'DDP', 'X',
'DDQ', 'X',
'DDT', 'Y',
'DDU', 'X',
'DEA', 'X',
'DEB', 'X',
'DEC', 'X',
'DEF', 'X',
'DEL', 'X',
'DEM', 'X',
'DEN', 'X',
'DEP', 'X',
'DEQ', 'X',
'DES', 'X',
'DET', 'X',
'DFC', 'X',
'DFG', 'X',
'DFI', 'X',
'DFL', 'X',
'DFO', 'X',
'DFP', 'X',
'DFR', 'X',
'DFT', 'X',
'DFV', 'X',
'DFX', 'X',
'DG2', 'X',
'DG3', 'X',
'DG6', 'X',
'DGA', 'X',
'DGD', 'X',
'DGG', 'X',
'DGL', 'E',
'DGN', 'Q',
'DGP', 'X',
'DGT', 'X',
'DGX', 'X',
'DH2', 'X',
'DHA', 'A',
'DHB', 'X',
'DHC', 'X',
'DHD', 'X',
'DHE', 'X',
'DHF', 'X',
'DHG', 'X',
'DHI', 'H',
'DHL', 'X',
'DHM', 'X',
'DHN', 'V',
'DHP', 'X',
'DHQ', 'X',
'DHR', 'X',
'DHS', 'X',
'DHT', 'X',
'DHU', 'X',
'DHY', 'X',
'DHZ', 'X',
'DI2', 'X',
'DI3', 'G',
'DI4', 'X',
'DI5', 'X',
'DIA', 'X',
'DIC', 'X',
'DIF', 'X',
'DIG', 'X',
'DII', 'X',
'DIL', 'I',
'DIM', 'X',
'DIO', 'X',
'DIP', 'X',
'DIQ', 'X',
'DIS', 'X',
'DIT', 'X',
'DIV', 'V',
'DIX', 'X',
'DIY', 'X',
'DKA', 'X',
'DLA', 'X',
'DLE', 'L',
'DLF', 'X',
'DLS', 'K',
'DLY', 'K',
'DM1', 'X',
'DM2', 'X',
'DM3', 'X',
'DM4', 'X',
'DM5', 'X',
'DM6', 'X',
'DM7', 'X',
'DM8', 'X',
'DM9', 'X',
'DMA', 'X',
'DMB', 'X',
'DMC', 'X',
'DMD', 'X',
'DME', 'X',
'DMF', 'X',
'DMG', 'G',
'DMH', 'N',
'DMI', 'X',
'DMJ', 'X',
'DML', 'X',
'DMM', 'X',
'DMN', 'X',
'DMO', 'X',
'DMP', 'X',
'DMQ', 'X',
'DMR', 'X',
'DMS', 'X',
'DMT', 'X',
'DMV', 'X',
'DMY', 'X',
'DNC', 'X',
'DND', 'X',
'DNH', 'X',
'DNJ', 'X',
'DNN', 'X',
'DNP', 'X',
'DNQ', 'X',
'DNR', 'X',
'DO2', 'X',
'DO3', 'X',
'DOA', 'X',
'DOB', 'X',
'DOC', 'X',
'DOH', 'D',
'DOM', 'X',
'DOS', 'X',
'DOX', 'X',
'DP5', 'X',
'DP7', 'X',
'DPA', 'X',
'DPC', 'X',
'DPD', 'X',
'DPE', 'X',
'DPG', 'X',
'DPH', 'F',
'DPM', 'X',
'DPN', 'F',
'DPO', 'X',
'DPP', 'X',
'DPR', 'P',
'DPS', 'X',
'DPT', 'X',
'DPX', 'X',
'DPY', 'X',
'DPZ', 'X',
'DQH', 'X',
'DQN', 'X',
'DR1', 'X',
'DRB', 'X',
'DRC', 'X',
'DRI', 'X',
'DRP', 'X',
'DRT', 'X',
'DRU', 'X',
'DSA', 'X',
'DSB', 'X',
'DSC', 'X',
'DSD', 'X',
'DSE', 'S',
'DSI', 'X',
'DSN', 'S',
'DSP', 'D',
'DSR', 'X',
'DSS', 'X',
'DSX', 'X',
'DSY', 'X',
'DTB', 'X',
'DTD', 'X',
'DTH', 'T',
'DTN', 'X',
'DTO', 'X',
'DTP', 'X',
'DTQ', 'X',
'DTR', 'W',
'DTT', 'X',
'DTY', 'Y',
'DUD', 'X',
'DUO', 'X',
'DUR', 'X',
'DUT', 'X',
'DVA', 'V',
'DVR', 'X',
'DX9', 'X',
'DXA', 'X',
'DXB', 'X',
'DXC', 'X',
'DXG', 'X',
'DXX', 'X',
'DZF', 'X',
'E09', 'X',
'E20', 'X',
'E2P', 'X',
'E3G', 'X',
'E4N', 'X',
'E4P', 'X',
'E64', 'X',
'E6C', 'X',
'E96', 'X',
'E97', 'X',
'EA2', 'X',
'EAA', 'X',
'EAP', 'X',
'EBP', 'X',
'EBW', 'X',
'ECO', 'X',
'EDA', 'X',
'EDC', 'X',
'EDE', 'X',
'EDO', 'X',
'EDR', 'X',
'EEB', 'X',
'EEE', 'X',
'EFC', 'X',
'EFZ', 'X',
'EG1', 'X',
'EG2', 'X',
'EG3', 'X',
'EGC', 'X',
'EGL', 'X',
'EHP', 'A',
'EIC', 'X',
'EJT', 'X',
'ELA', 'X',
'EMB', 'X',
'EMC', 'X',
'EMD', 'X',
'EMM', 'X',
'EMO', 'X',
'EMP', 'X',
'EMR', 'X',
'ENA', 'X',
'ENC', 'X',
'ENH', 'X',
'ENO', 'X',
'ENP', 'X',
'EOA', 'X',
'EOH', 'X',
'EOT', 'X',
'EOX', 'X',
'EPA', 'X',
'EPE', 'X',
'EPH', 'X',
'EPI', 'X',
'EPN', 'X',
'EPO', 'X',
'EPT', 'X',
'EPU', 'X',
'EPX', 'X',
'EPY', 'X',
'EQI', 'X',
'EQP', 'X',
'EQU', 'X',
'ERG', 'X',
'ERI', 'X',
'ERY', 'X',
'ESC', 'X',
'ESD', 'X',
'ESI', 'X',
'ESO', 'X',
'ESP', 'X',
'EST', 'X',
'ESX', 'X',
'ETA', 'X',
'ETC', 'X',
'ETD', 'X',
'ETF', 'X',
'ETH', 'X',
'ETI', 'X',
'ETN', 'X',
'ETO', 'X',
'ETP', 'X',
'ETR', 'X',
'ETS', 'X',
'ETY', 'X',
'EU3', 'X',
'EUG', 'X',
'EYS', 'C',
'F09', 'X',
'F2B', 'X',
'F3S', 'X',
'F42', 'X',
'F43', 'X',
'F4S', 'X',
'F6B', 'X',
'F6P', 'X',
'F89', 'X',
'FA1', 'X',
'FA5', 'F',
'FAA', 'X',
'FAB', 'X',
'FAC', 'X',
'FAD', 'X',
'FAF', 'X',
'FAG', 'X',
'FAM', 'X',
'FAR', 'X',
'FAS', 'X',
'FAT', 'X',
'FBA', 'X',
'FBE', 'X',
'FBI', 'X',
'FBP', 'X',
'FBQ', 'X',
'FBS', 'X',
'FBT', 'X',
'FBU', 'X',
'FCA', 'X',
'FCB', 'X',
'FCI', 'X',
'FCN', 'X',
'FCO', 'X',
'FCR', 'X',
'FCT', 'X',
'FCX', 'X',
'FCY', 'C',
'FD1', 'F',
'FD2', 'F',
'FD3', 'F',
'FD4', 'F',
'FDA', 'X',
'FDC', 'X',
'FDI', 'X',
'FDP', 'X',
'FDS', 'X',
'FE2', 'X',
'FEA', 'X',
'FEL', 'X',
'FEM', 'X',
'FEN', 'X',
'FEO', 'X',
'FEP', 'X',
'FER', 'X',
'FES', 'X',
'FFB', 'X',
'FFC', 'X',
'FFF', 'X',
'FFO', 'X',
'FGL', 'G',
'FHB', 'X',
'FHC', 'X',
'FHP', 'X',
'FHU', 'X',
'FID', 'X',
'FII', 'X',
'FIP', 'X',
'FK5', 'X',
'FKA', 'X',
'FKI', 'X',
'FKP', 'X',
'FL2', 'X',
'FL9', 'X',
'FLA', 'A',
'FLC', 'X',
'FLD', 'X',
'FLE', 'L',
'FLF', 'X',
'FLO', 'X',
'FLP', 'X',
'FLT', 'Y',
'FLU', 'X',
'FLX', 'X',
'FM1', 'X',
'FM2', 'X',
'FMA', 'X',
'FMB', 'X',
'FMC', 'X',
'FME', 'M',
'FMN', 'X',
'FMP', 'X',
'FMR', 'X',
'FMS', 'X',
'FMT', 'X',
'FNE', 'X',
'FNP', 'X',
'FNS', 'X',
'FOC', 'X',
'FOE', 'X',
'FOG', 'F',
'FOH', 'X',
'FOK', 'X',
'FOL', 'X',
'FON', 'X',
'FOP', 'X',
'FOR', 'X',
'FOS', 'X',
'FPA', 'X',
'FPC', 'X',
'FPI', 'X',
'FPO', 'X',
'FPP', 'X',
'FPT', 'X',
'FQP', 'X',
'FRA', 'X',
'FRD', 'F',
'FRU', 'X',
'FS3', 'X',
'FS4', 'X',
'FSB', 'X',
'FSO', 'X',
'FSX', 'X',
'FTC', 'X',
'FTP', 'X',
'FTR', 'W',
'FTT', 'X',
'FTY', 'Y',
'FUA', 'X',
'FUC', 'X',
'FUM', 'X',
'FUP', 'X',
'FVF', 'X',
'FXP', 'X',
'FXV', 'X',
'FYA', 'F',
'G16', 'X',
'G1P', 'X',
'G20', 'X',
'G21', 'X',
'G23', 'X',
'G26', 'X',
'G28', 'X',
'G2F', 'X',
'G37', 'X',
'G39', 'X',
'G3H', 'X',
'G3P', 'X',
'G4D', 'X',
'G6D', 'X',
'G6P', 'X',
'G6Q', 'X',
'G7M', 'X',
'GA2', 'X',
'GAA', 'X',
'GAB', 'X',
'GAC', 'X',
'GAI', 'X',
'GAL', 'X',
'GAM', 'X',
'GAN', 'X',
'GAO', 'X',
'GAP', 'X',
'GAR', 'G',
'GAS', 'X',
'GAT', 'X',
'GBC', 'X',
'GBI', 'X',
'GBP', 'X',
'GBS', 'X',
'GBX', 'X',
'GC4', 'X',
'GCA', 'X',
'GCD', 'X',
'GCG', 'G',
'GCH', 'G',
'GCK', 'X',
'GCL', 'X',
'GCM', 'X',
'GCN', 'X',
'GCO', 'X',
'GCP', 'X',
'GCR', 'X',
'GCS', 'X',
'GCU', 'X',
'GD3', 'X',
'GDB', 'X',
'GDM', 'X',
'GDN', 'X',
'GDP', 'X',
'GDS', 'X',
'GDU', 'X',
'GE1', 'X',
'GE2', 'X',
'GE3', 'X',
'GEA', 'X',
'GEL', 'X',
'GEM', 'X',
'GEN', 'X',
'GEP', 'X',
'GER', 'X',
'GFP', 'X',
'GGB', 'X',
'GGL', 'E',
'GGP', 'X',
'GHP', 'G',
'GIP', 'X',
'GIS', 'X',
'GKR', 'X',
'GL2', 'X',
'GL3', 'G',
'GL4', 'X',
'GL5', 'X',
'GL7', 'X',
'GL9', 'X',
'GLA', 'X',
'GLB', 'X',
'GLC', 'X',
'GLD', 'X',
'GLE', 'X',
'GLF', 'X',
'GLG', 'X',
'GLH', 'Q',
'GLI', 'X',
'GLL', 'X',
'GLM', 'G',
'GLN', 'Q',
'GLO', 'X',
'GLP', 'X',
'GLR', 'X',
'GLS', 'X',
'GLT', 'X',
'GLU', 'E',
'GLV', 'X',
'GLW', 'X',
'GLY', 'G',
'GLZ', 'X',
'GM1', 'X',
'GMA', 'X',
'GMC', 'X',
'GMH', 'X',
'GMP', 'X',
'GMY', 'X',
'GN7', 'X',
'GNA', 'X',
'GNB', 'X',
'GNH', 'X',
'GNP', 'X',
'GNT', 'X',
'GOA', 'X',
'GOL', 'X',
'GOX', 'X',
'GP1', 'X',
'GP3', 'X',
'GP4', 'X',
'GP6', 'X',
'GP8', 'X',
'GPB', 'E',
'GPC', 'X',
'GPE', 'X',
'GPG', 'X',
'GPI', 'X',
'GPJ', 'X',
'GPL', 'K',
'GPM', 'X',
'GPN', 'G',
'GPP', 'X',
'GPR', 'X',
'GPS', 'X',
'GPX', 'X',
'GR1', 'X',
'GR3', 'X',
'GR4', 'X',
'GSA', 'X',
'GSB', 'X',
'GSC', 'G',
'GSE', 'S',
'GSH', 'X',
'GSP', 'X',
'GSR', 'X',
'GSS', 'X',
'GT9', 'C',
'GTA', 'X',
'GTB', 'X',
'GTD', 'X',
'GTE', 'X',
'GTH', 'T',
'GTN', 'X',
'GTO', 'X',
'GTP', 'X',
'GTR', 'X',
'GTS', 'X',
'GTT', 'X',
'GTX', 'X',
'GTZ', 'X',
'GU7', 'X',
'GUA', 'X',
'GUD', 'X',
'GUM', 'X',
'GUN', 'X',
'GUP', 'X',
'GUR', 'X',
'GW3', 'X',
'GZZ', 'X',
'H2B', 'X',
'H2P', 'H',
'H2S', 'X',
'H2U', 'X',
'H4B', 'X',
'H5M', 'P',
'H5P', 'X',
'HAA', 'X',
'HAB', 'X',
'HAC', 'A',
'HAD', 'X',
'HAE', 'X',
'HAG', 'X',
'HAI', 'X',
'HAM', 'X',
'HAP', 'X',
'HAQ', 'X',
'HAR', 'R',
'HAS', 'X',
'HAV', 'V',
'HAX', 'X',
'HAZ', 'X',
'HBA', 'X',
'HBC', 'X',
'HBD', 'X',
'HBI', 'X',
'HBO', 'X',
'HBU', 'X',
'HBY', 'X',
'HC0', 'X',
'HC1', 'X',
'HC4', 'X',
'HCA', 'X',
'HCC', 'X',
'HCI', 'X',
'HCS', 'X',
'HDA', 'X',
'HDD', 'X',
'HDF', 'X',
'HDN', 'X',
'HDS', 'X',
'HDZ', 'X',
'HE1', 'X',
'HE6', 'X',
'HEA', 'X',
'HEB', 'X',
'HEC', 'X',
'HED', 'X',
'HEE', 'X',
'HEF', 'X',
'HEG', 'X',
'HEM', 'X',
'HEN', 'X',
'HEO', 'X',
'HEP', 'X',
'HEU', 'X',
'HEV', 'X',
'HEX', 'X',
'HEZ', 'X',
'HF1', 'X',
'HFA', 'X',
'HFP', 'X',
'HGA', 'Q',
'HGB', 'X',
'HGC', 'X',
'HGI', 'X',
'HGU', 'X',
'HHO', 'X',
'HHP', 'X',
'HIB', 'X',
'HIC', 'H',
'HII', 'X',
'HIN', 'X',
'HIO', 'X',
'HIP', 'H',
'HIS', 'H',
'HLE', 'X',
'HLT', 'X',
'HMA', 'A',
'HMB', 'X',
'HMC', 'X',
'HMD', 'X',
'HMF', 'A',
'HMG', 'X',
'HMH', 'X',
'HMI', 'L',
'HMM', 'X',
'HMN', 'X',
'HMO', 'X',
'HMP', 'X',
'HMR', 'R',
'HNI', 'X',
'HNP', 'X',
'HOA', 'X',
'HOE', 'X',
'HOH', 'X',
'HOM', 'X',
'HOP', 'X',
'HOQ', 'X',
'HP1', 'A',
'HP2', 'A',
'HP3', 'X',
'HPA', 'X',
'HPB', 'X',
'HPC', 'X',
'HPD', 'X',
'HPE', 'A',
'HPG', 'X',
'HPH', 'F',
'HPP', 'X',
'HPQ', 'F',
'HPR', 'X',
'HPT', 'X',
'HPY', 'X',
'HQO', 'X',
'HQQ', 'X',
'HQU', 'X',
'HRG', 'R',
'HRI', 'X',
'HSA', 'X',
'HSE', 'S',
'HSF', 'X',
'HSM', 'X',
'HSO', 'H',
'HSP', 'X',
'HT1', 'X',
'HT2', 'X',
'HTA', 'X',
'HTL', 'X',
'HTO', 'X',
'HTP', 'X',
'HTR', 'W',
'HUP', 'X',
'HUX', 'X',
'HV5', 'A',
'HV7', 'X',
'HV8', 'X',
'HXA', 'X',
'HXC', 'X',
'HXP', 'X',
'HY1', 'X',
'HYA', 'X',
'HYB', 'X',
'HYD', 'X',
'HYG', 'X',
'HYP', 'P',
'I06', 'X',
'I10', 'X',
'I11', 'X',
'I17', 'X',
'I2P', 'X',
'I3N', 'X',
'I3P', 'X',
'I40', 'X',
'I48', 'X',
'I4B', 'X',
'I52', 'X',
'I5P', 'X',
'I84', 'G',
'IAG', 'G',
'IAS', 'X',
'IB2', 'X',
'IBB', 'X',
'IBP', 'X',
'IBR', 'X',
'IBS', 'X',
'IBZ', 'X',
'IC1', 'X',
'ICA', 'X',
'ICI', 'X',
'ICL', 'X',
'ICP', 'X',
'ICT', 'X',
'ICU', 'X',
'ID2', 'X',
'IDC', 'X',
'IDG', 'X',
'IDH', 'X',
'IDM', 'X',
'IDO', 'X',
'IDP', 'X',
'IDR', 'X',
'IDS', 'X',
'IDT', 'X',
'IDU', 'X',
'IFG', 'X',
'IFP', 'X',
'IGL', 'X',
'IGN', 'X',
'IGP', 'X',
'IGU', 'X',
'IH1', 'X',
'IH2', 'X',
'IH3', 'X',
'IHB', 'X',
'IHN', 'X',
'IHP', 'X',
'IIC', 'X',
'IIL', 'I',
'IIP', 'X',
'IK2', 'X',
'IKT', 'X',
'ILA', 'I',
'ILE', 'I',
'ILG', 'X',
'ILO', 'X',
'ILX', 'I',
'IM1', 'X',
'IM2', 'X',
'IMC', 'X',
'IMD', 'X',
'IME', 'X',
'IMF', 'X',
'IMG', 'X',
'IMH', 'X',
'IMI', 'X',
'IML', 'I',
'IMM', 'X',
'IMN', 'X',
'IMO', 'X',
'IMP', 'X',
'IMR', 'X',
'IMU', 'X',
'IN0', 'D',
'IN1', 'R',
'IN2', 'K',
'IN3', 'L',
'IN4', 'X',
'IN5', 'A',
'IN6', 'L',
'IN7', 'X',
'IN8', 'X',
'IN9', 'X',
'INA', 'L',
'INB', 'X',
'INC', 'X',
'IND', 'X',
'INE', 'X',
'INF', 'F',
'ING', 'F',
'INH', 'R',
'INI', 'X',
'INJ', 'X',
'INK', 'X',
'INL', 'X',
'INM', 'X',
'INN', 'A',
'INO', 'X',
'INP', 'X',
'INQ', 'X',
'INR', 'X',
'INS', 'X',
'INT', 'V',
'INU', 'X',
'INV', 'X',
'INW', 'X',
'INX', 'X',
'INY', 'X',
'INZ', 'X',
'IOA', 'X',
'IOB', 'X',
'IOC', 'X',
'IOD', 'X',
'IOE', 'X',
'IOF', 'X',
'IOH', 'X',
'IOL', 'X',
'IOP', 'X',
'IP1', 'X',
'IP2', 'X',
'IP3', 'X',
'IP4', 'X',
'IPA', 'X',
'IPB', 'X',
'IPD', 'X',
'IPG', 'G',
'IPH', 'X',
'IPL', 'X',
'IPM', 'X',
'IPN', 'X',
'IPO', 'F',
'IPP', 'X',
'IPS', 'X',
'IPT', 'X',
'IPU', 'X',
'IPY', 'A',
'IQB', 'X',
'IQP', 'X',
'IQS', 'X',
'IR3', 'X',
'IRI', 'X',
'IRP', 'X',
'ISA', 'X',
'ISF', 'X',
'ISO', 'X',
'ISP', 'X',
'ISQ', 'X',
'ISU', 'X',
'ITM', 'X',
'ITP', 'X',
'ITR', 'W',
'ITS', 'X',
'ITU', 'X',
'IU5', 'X',
'IUM', 'X',
'IUR', 'X',
'IVA', 'X',
'IYG', 'G',
'IYR', 'Y',
'J77', 'X',
'J78', 'X',
'J80', 'X',
'JE2', 'X',
'JEN', 'X',
'JST', 'X',
'K21', 'X',
'KAH', 'X',
'KAI', 'X',
'KAM', 'X',
'KAN', 'X',
'KAP', 'X',
'KCP', 'X',
'KCX', 'K',
'KDO', 'X',
'KEF', 'X',
'KET', 'X',
'KGR', 'X',
'KH1', 'X',
'KIF', 'X',
'KIV', 'V',
'KNI', 'X',
'KPH', 'K',
'KTH', 'X',
'KTN', 'X',
'KTP', 'X',
'KWT', 'X',
'L04', 'X',
'L1P', 'X',
'L24', 'E',
'L2P', 'X',
'L34', 'E',
'L37', 'E',
'L3P', 'X',
'L4P', 'X',
'L75', 'X',
'LAC', 'X',
'LAD', 'X',
'LAK', 'X',
'LAM', 'X',
'LAR', 'X',
'LAT', 'X',
'LAX', 'X',
'LCO', 'X',
'LCP', 'X',
'LCS', 'X',
'LDA', 'X',
'LDO', 'L',
'LDP', 'X',
'LEA', 'X',
'LEO', 'X',
'LEU', 'L',
'LG2', 'X',
'LG6', 'X',
'LGC', 'X',
'LGP', 'X',
'LHG', 'X',
'LHY', 'F',
'LI1', 'X',
'LIG', 'X',
'LIL', 'X',
'LIM', 'X',
'LIN', 'X',
'LIO', 'X',
'LIP', 'X',
'LLA', 'X',
'LLP', 'K',
'LLY', 'K',
'LMG', 'X',
'LML', 'X',
'LMT', 'X',
'LMU', 'X',
'LMZ', 'X',
'LNK', 'X',
'LNL', 'X',
'LNO', 'X',
'LOF', 'X',
'LOL', 'L',
'LOM', 'X',
'LOR', 'X',
'LOS', 'X',
'LOV', 'L',
'LOX', 'X',
'LP1', 'X',
'LP2', 'R',
'LPA', 'X',
'LPC', 'X',
'LPF', 'X',
'LPL', 'X',
'LPM', 'X',
'LPP', 'X',
'LRB', 'X',
'LRU', 'X',
'LS1', 'X',
'LS2', 'X',
'LS3', 'X',
'LS4', 'X',
'LS5', 'X',
'LTA', 'X',
'LTL', 'X',
'LTR', 'W',
'LUM', 'X',
'LVS', 'L',
'LXC', 'X',
'LY2', 'X',
'LY3', 'X',
'LYA', 'X',
'LYB', 'X',
'LYC', 'X',
'LYD', 'X',
'LYM', 'K',
'LYN', 'X',
'LYS', 'K',
'LYT', 'X',
'LYW', 'X',
'LYZ', 'K',
'M1A', 'X',
'M1G', 'X',
'M2G', 'X',
'M3L', 'K',
'M6P', 'X',
'M6T', 'X',
'M7G', 'X',
'MA1', 'X',
'MA2', 'X',
'MA3', 'X',
'MA4', 'X',
'MA6', 'X',
'MAA', 'A',
'MAB', 'X',
'MAC', 'X',
'MAE', 'X',
'MAG', 'X',
'MAH', 'X',
'MAI', 'R',
'MAK', 'X',
'MAL', 'X',
'MAM', 'X',
'MAN', 'X',
'MAO', 'X',
'MAP', 'X',
'MAR', 'X',
'MAS', 'X',
'MAT', 'X',
'MAU', 'X',
'MAZ', 'X',
'MBA', 'X',
'MBD', 'X',
'MBG', 'X',
'MBH', 'X',
'MBN', 'X',
'MBO', 'X',
'MBR', 'X',
'MBS', 'X',
'MBV', 'X',
'MBZ', 'X',
'MCA', 'X',
'MCD', 'X',
'MCE', 'X',
'MCG', 'G',
'MCI', 'X',
'MCN', 'X',
'MCP', 'X',
'MCT', 'X',
'MCY', 'X',
'MD2', 'X',
'MDA', 'X',
'MDC', 'X',
'MDG', 'X',
'MDH', 'X',
'MDL', 'X',
'MDM', 'X',
'MDN', 'X',
'MDP', 'X',
'ME6', 'X',
'MEB', 'X',
'MEC', 'X',
'MEL', 'X',
'MEN', 'N',
'MEP', 'X',
'MER', 'X',
'MES', 'X',
'MET', 'M',
'MEV', 'X',
'MF2', 'X',
'MF3', 'M',
'MFB', 'X',
'MFD', 'X',
'MFU', 'X',
'MG7', 'X',
'MGA', 'X',
'MGB', 'X',
'MGD', 'X',
'MGG', 'R',
'MGL', 'X',
'MGN', 'Q',
'MGO', 'X',
'MGP', 'X',
'MGR', 'X',
'MGS', 'X',
'MGT', 'X',
'MGU', 'X',
'MGY', 'G',
'MHB', 'X',
'MHF', 'X',
'MHL', 'L',
'MHM', 'X',
'MHO', 'M',
'MHS', 'H',
'MHZ', 'X',
'MIA', 'X',
'MIC', 'X',
'MID', 'X',
'MIL', 'X',
'MIM', 'X',
'MIN', 'G',
'MIP', 'X',
'MIS', 'S',
'MIT', 'X',
'MJI', 'X',
'MK1', 'X',
'MKC', 'X',
'MLA', 'X',
'MLC', 'X',
'MLE', 'L',
'MLN', 'X',
'MLT', 'X',
'MLY', 'K',
'MLZ', 'K',
'MM3', 'X',
'MM4', 'X',
'MMA', 'X',
'MMC', 'X',
'MME', 'M',
'MMO', 'R',
'MMP', 'X',
'MMQ', 'X',
'MMT', 'X',
'MN1', 'X',
'MN2', 'X',
'MN3', 'X',
'MN5', 'X',
'MN7', 'X',
'MN8', 'X',
'MNA', 'X',
'MNB', 'X',
'MNC', 'X',
'MNG', 'X',
'MNL', 'L',
'MNO', 'X',
'MNP', 'X',
'MNQ', 'X',
'MNS', 'X',
'MNT', 'X',
'MNV', 'V',
'MO1', 'X',
'MO2', 'X',
'MO3', 'X',
'MO4', 'X',
'MO5', 'X',
'MO6', 'X',
'MOA', 'X',
'MOB', 'X',
'MOC', 'X',
'MOE', 'X',
'MOG', 'X',
'MOH', 'X',
'MOL', 'X',
'MOO', 'X',
'MOP', 'X',
'MOR', 'X',
'MOS', 'X',
'MOT', 'X',
'MOX', 'X',
'MP1', 'X',
'MP3', 'X',
'MPA', 'X',
'MPB', 'X',
'MPC', 'X',
'MPD', 'X',
'MPG', 'X',
'MPH', 'M',
'MPI', 'X',
'MPJ', 'M',
'MPL', 'X',
'MPN', 'X',
'MPO', 'X',
'MPP', 'X',
'MPQ', 'G',
'MPR', 'X',
'MPS', 'X',
'MQ0', 'X',
'MQ7', 'X',
'MQ8', 'X',
'MQ9', 'X',
'MQI', 'X',
'MR2', 'X',
'MRC', 'X',
'MRM', 'X',
'MRP', 'X',
'MS2', 'X',
'MSA', 'X',
'MSB', 'X',
'MSD', 'X',
'MSE', 'M',
'MSF', 'X',
'MSI', 'X',
'MSO', 'M',
'MSQ', 'X',
'MST', 'X',
'MSU', 'X',
'MTA', 'X',
'MTB', 'X',
'MTC', 'X',
'MTD', 'X',
'MTE', 'X',
'MTF', 'X',
'MTG', 'X',
'MTO', 'X',
'MTS', 'X',
'MTT', 'X',
'MTX', 'X',
'MTY', 'Y',
'MUG', 'X',
'MUP', 'X',
'MUR', 'X',
'MVA', 'V',
'MW1', 'X',
'MW2', 'X',
'MXA', 'X',
'MXY', 'X',
'MYA', 'X',
'MYC', 'X',
'MYG', 'X',
'MYR', 'X',
'MYS', 'X',
'MYT', 'X',
'MZM', 'X',
'N1T', 'X',
'N25', 'X',
'N2B', 'X',
'N3T', 'X',
'N4B', 'X',
'NA2', 'X',
'NA5', 'X',
'NA6', 'X',
'NAA', 'X',
'NAB', 'X',
'NAC', 'X',
'NAD', 'X',
'NAE', 'X',
'NAF', 'X',
'NAG', 'X',
'NAH', 'X',
'NAI', 'X',
'NAL', 'A',
'NAM', 'A',
'NAN', 'X',
'NAO', 'X',
'NAP', 'X',
'NAQ', 'X',
'NAR', 'X',
'NAS', 'X',
'NAU', 'X',
'NAV', 'X',
'NAW', 'X',
'NAX', 'X',
'NAY', 'X',
'NBA', 'X',
'NBD', 'X',
'NBE', 'X',
'NBG', 'X',
'NBN', 'X',
'NBP', 'X',
'NBS', 'X',
'NBU', 'X',
'NCA', 'X',
'NCB', 'A',
'NCD', 'X',
'NCH', 'X',
'NCM', 'X',
'NCN', 'X',
'NCO', 'X',
'NCR', 'X',
'NCS', 'X',
'ND4', 'X',
'NDA', 'X',
'NDC', 'X',
'NDD', 'X',
'NDO', 'X',
'NDP', 'X',
'NDT', 'X',
'NEA', 'X',
'NEB', 'X',
'NED', 'X',
'NEM', 'H',
'NEN', 'X',
'NEO', 'X',
'NEP', 'H',
'NEQ', 'X',
'NES', 'X',
'NET', 'X',
'NEV', 'X',
'NFA', 'F',
'NFE', 'X',
'NFG', 'X',
'NFP', 'X',
'NFS', 'X',
'NG6', 'X',
'NGA', 'X',
'NGL', 'X',
'NGM', 'X',
'NGO', 'X',
'NGP', 'X',
'NGT', 'X',
'NGU', 'X',
'NH2', 'X',
'NH3', 'X',
'NH4', 'X',
'NHD', 'X',
'NHE', 'X',
'NHM', 'X',
'NHP', 'X',
'NHR', 'X',
'NHS', 'X',
'NI1', 'X',
'NI2', 'X',
'NIC', 'X',
'NID', 'X',
'NIK', 'X',
'NIO', 'X',
'NIP', 'X',
'NIT', 'X',
'NIU', 'X',
'NIY', 'Y',
'NLA', 'X',
'NLE', 'L',
'NLG', 'X',
'NLN', 'L',
'NLP', 'L',
'NM1', 'X',
'NMA', 'A',
'NMB', 'X',
'NMC', 'G',
'NMD', 'X',
'NME', 'X',
'NMN', 'X',
'NMO', 'X',
'NMQ', 'X',
'NMX', 'X',
'NMY', 'X',
'NNH', 'R',
'NNO', 'X',
'NO2', 'X',
'NO3', 'X',
'NOA', 'X',
'NOD', 'X',
'NOJ', 'X',
'NON', 'X',
'NOP', 'X',
'NOR', 'X',
'NOS', 'X',
'NOV', 'X',
'NOX', 'X',
'NP3', 'X',
'NPA', 'X',
'NPC', 'X',
'NPD', 'X',
'NPE', 'X',
'NPF', 'X',
'NPH', 'C',
'NPI', 'X',
'NPL', 'X',
'NPN', 'X',
'NPO', 'X',
'NPP', 'X',
'NPT', 'X',
'NPY', 'X',
'NRG', 'R',
'NRI', 'X',
'NS1', 'X',
'NS5', 'X',
'NSP', 'X',
'NTA', 'X',
'NTB', 'X',
'NTC', 'X',
'NTH', 'X',
'NTM', 'X',
'NTP', 'X',
'NTS', 'X',
'NTU', 'X',
'NTZ', 'X',
'NU1', 'X',
'NVA', 'V',
'NVI', 'X',
'NVP', 'X',
'NW1', 'X',
'NYP', 'X',
'O4M', 'X',
'OAA', 'X',
'OAI', 'X',
'OAP', 'X',
'OAR', 'X',
'OAS', 'S',
'OBA', 'X',
'OBN', 'X',
'OC1', 'X',
'OC2', 'X',
'OC3', 'X',
'OC4', 'X',
'OC5', 'X',
'OC6', 'X',
'OC7', 'X',
'OCL', 'X',
'OCM', 'X',
'OCN', 'X',
'OCO', 'X',
'OCP', 'X',
'OCS', 'C',
'OCT', 'X',
'OCV', 'K',
'OCY', 'C',
'ODA', 'X',
'ODS', 'X',
'OES', 'X',
'OET', 'X',
'OF1', 'X',
'OF2', 'X',
'OF3', 'X',
'OFL', 'X',
'OFO', 'X',
'OHE', 'X',
'OHO', 'X',
'OHT', 'X',
'OIC', 'X',
'OIP', 'X',
'OKA', 'X',
'OLA', 'X',
'OLE', 'X',
'OLI', 'X',
'OLO', 'X',
'OMB', 'X',
'OMC', 'X',
'OMD', 'X',
'OME', 'X',
'OMG', 'X',
'OMP', 'X',
'OMT', 'M',
'OMU', 'X',
'ONE', 'X',
'ONL', 'L',
'ONP', 'X',
'OPA', 'X',
'OPD', 'X',
'OPE', 'X',
'OPG', 'X',
'OPH', 'X',
'OPN', 'X',
'OPP', 'X',
'OPR', 'R',
'ORN', 'X',
'ORO', 'X',
'ORP', 'X',
'OSB', 'X',
'OSS', 'X',
'OTA', 'X',
'OTB', 'X',
'OTE', 'X',
'OTG', 'X',
'OUT', 'X',
'OVA', 'X',
'OWQ', 'X',
'OXA', 'X',
'OXE', 'X',
'OXI', 'X',
'OXL', 'X',
'OXM', 'X',
'OXN', 'X',
'OXO', 'X',
'OXP', 'X',
'OXS', 'X',
'OXY', 'X',
'P11', 'A',
'P24', 'X',
'P28', 'X',
'P2P', 'X',
'P2U', 'X',
'P3M', 'X',
'P4C', 'X',
'P4P', 'X',
'P5P', 'X',
'P6G', 'X',
'PA1', 'X',
'PA2', 'X',
'PA3', 'X',
'PA4', 'X',
'PA5', 'X',
'PAA', 'X',
'PAB', 'X',
'PAC', 'X',
'PAD', 'X',
'PAE', 'X',
'PAG', 'X',
'PAH', 'X',
'PAI', 'X',
'PAL', 'D',
'PAM', 'X',
'PAN', 'X',
'PAO', 'X',
'PAP', 'A',
'PAQ', 'F',
'PAR', 'X',
'PAS', 'X',
'PAT', 'W',
'PBA', 'X',
'PBB', 'X',
'PBC', 'X',
'PBF', 'F',
'PBG', 'X',
'PBI', 'X',
'PBM', 'X',
'PBN', 'X',
'PBP', 'X',
'PBR', 'X',
'PBZ', 'X',
'PC2', 'X',
'PCA', 'E',
'PCB', 'X',
'PCD', 'X',
'PCE', 'X',
'PCG', 'X',
'PCH', 'X',
'PCL', 'X',
'PCM', 'X',
'PCP', 'X',
'PCR', 'X',
'PCS', 'X',
'PCU', 'X',
'PCV', 'X',
'PCY', 'X',
'PD1', 'X',
'PDA', 'X',
'PDC', 'X',
'PDD', 'A',
'PDE', 'A',
'PDI', 'X',
'PDL', 'A',
'PDN', 'X',
'PDO', 'X',
'PDP', 'X',
'PDT', 'X',
'PDU', 'X',
'PE2', 'X',
'PE6', 'X',
'PEA', 'X',
'PEB', 'X',
'PEC', 'X',
'PED', 'X',
'PEE', 'X',
'PEF', 'X',
'PEG', 'X',
'PEL', 'X',
'PEO', 'X',
'PEP', 'X',
'PEQ', 'X',
'PER', 'X',
'PET', 'X',
'PFB', 'X',
'PFC', 'X',
'PFG', 'X',
'PFL', 'X',
'PFM', 'X',
'PFZ', 'X',
'PG4', 'X',
'PG5', 'X',
'PG6', 'X',
'PGA', 'X',
'PGC', 'X',
'PGD', 'X',
'PGE', 'X',
'PGG', 'G',
'PGH', 'X',
'PGL', 'X',
'PGO', 'X',
'PGP', 'X',
'PGQ', 'X',
'PGR', 'X',
'PGS', 'X',
'PGU', 'X',
'PGX', 'X',
'PGY', 'G',
'PH1', 'X',
'PH2', 'X',
'PH3', 'X',
'PHA', 'F',
'PHB', 'X',
'PHC', 'X',
'PHD', 'X',
'PHE', 'F',
'PHG', 'X',
'PHH', 'X',
'PHI', 'F',
'PHL', 'F',
'PHM', 'X',
'PHN', 'X',
'PHO', 'X',
'PHP', 'X',
'PHQ', 'X',
'PHS', 'H',
'PHT', 'X',
'PHW', 'P',
'PHY', 'X',
'PI1', 'X',
'PI2', 'X',
'PI3', 'X',
'PI4', 'X',
'PI5', 'X',
'PI6', 'X',
'PI7', 'X',
'PI8', 'X',
'PI9', 'X',
'PIA', 'X',
'PIB', 'X',
'PIC', 'X',
'PID', 'X',
'PIG', 'X',
'PIH', 'X',
'PIM', 'X',
'PIN', 'X',
'PIO', 'X',
'PIP', 'X',
'PIQ', 'X',
'PIR', 'X',
'PIV', 'X',
'PKF', 'X',
'PL1', 'X',
'PL9', 'X',
'PLA', 'D',
'PLC', 'X',
'PLE', 'L',
'PLG', 'G',
'PLH', 'X',
'PLM', 'X',
'PLP', 'X',
'PLS', 'S',
'PLT', 'W',
'PLU', 'L',
'PLY', 'X',
'PMA', 'X',
'PMB', 'X',
'PMC', 'X',
'PME', 'F',
'PML', 'X',
'PMM', 'X',
'PMO', 'X',
'PMP', 'X',
'PMS', 'X',
'PMY', 'X',
'PN2', 'X',
'PNA', 'X',
'PNB', 'X',
'PNC', 'G',
'PND', 'X',
'PNE', 'A',
'PNF', 'X',
'PNG', 'X',
'PNI', 'X',
'PNL', 'X',
'PNM', 'X',
'PNN', 'X',
'PNO', 'X',
'PNP', 'X',
'PNQ', 'X',
'PNS', 'X',
'PNT', 'X',
'PNU', 'X',
'PO2', 'X',
'PO4', 'X',
'POB', 'X',
'POC', 'X',
'POL', 'X',
'POM', 'P',
'PON', 'X',
'POP', 'X',
'POR', 'X',
'POS', 'X',
'PP1', 'X',
'PP2', 'X',
'PP3', 'A',
'PP4', 'X',
'PP5', 'X',
'PP6', 'X',
'PP7', 'X',
'PP8', 'N',
'PP9', 'X',
'PPB', 'X',
'PPC', 'X',
'PPD', 'X',
'PPE', 'E',
'PPG', 'X',
'PPH', 'F',
'PPI', 'X',
'PPJ', 'V',
'PPL', 'X',
'PPM', 'X',
'PPN', 'A',
'PPO', 'X',
'PPP', 'X',
'PPQ', 'X',
'PPR', 'X',
'PPS', 'X',
'PPT', 'X',
'PPU', 'X',
'PPX', 'F',
'PPY', 'X',
'PPZ', 'X',
'PQ0', 'X',
'PQN', 'X',
'PQQ', 'X',
'PR1', 'X',
'PR2', 'X',
'PR3', 'X',
'PRA', 'X',
'PRB', 'X',
'PRC', 'X',
'PRD', 'X',
'PRE', 'X',
'PRF', 'X',
'PRH', 'X',
'PRI', 'P',
'PRL', 'X',
'PRN', 'X',
'PRO', 'P',
'PRP', 'X',
'PRR', 'A',
'PRS', 'P',
'PRZ', 'X',
'PS0', 'X',
'PSA', 'X',
'PSD', 'X',
'PSE', 'X',
'PSF', 'S',
'PSG', 'X',
'PSI', 'X',
'PSO', 'X',
'PSQ', 'X',
'PSS', 'X',
'PST', 'X',
'PSU', 'X',
'PT1', 'X',
'PT3', 'X',
'PTA', 'X',
'PTC', 'X',
'PTD', 'X',
'PTE', 'X',
'PTH', 'Y',
'PTL', 'X',
'PTM', 'Y',
'PTN', 'X',
'PTO', 'X',
'PTP', 'X',
'PTR', 'Y',
'PTS', 'X',
'PTT', 'X',
'PTU', 'X',
'PTY', 'X',
'PUA', 'X',
'PUB', 'X',
'PUR', 'X',
'PUT', 'X',
'PVA', 'X',
'PVB', 'X',
'PVH', 'H',
'PVL', 'X',
'PXA', 'X',
'PXF', 'X',
'PXG', 'X',
'PXP', 'X',
'PXY', 'X',
'PXZ', 'X',
'PY2', 'X',
'PY4', 'X',
'PY5', 'X',
'PY6', 'X',
'PYA', 'A',
'PYC', 'X',
'PYD', 'X',
'PYE', 'X',
'PYL', 'X',
'PYM', 'X',
'PYO', 'X',
'PYP', 'X',
'PYQ', 'X',
'PYR', 'X',
'PYS', 'X',
'PYT', 'X',
'PYX', 'X',
'PYY', 'X',
'PYZ', 'X',
'PZQ', 'X',
'Q82', 'X',
'QNC', 'X',
'QND', 'X',
'QSI', 'Q',
'QTR', 'X',
'QUA', 'X',
'QUE', 'X',
'QUI', 'X',
'QUO', 'X',
'R11', 'X',
'R12', 'X',
'R13', 'X',
'R18', 'X',
'R1P', 'X',
'R56', 'X',
'R5P', 'X',
'RA2', 'X',
'RAD', 'X',
'RAI', 'X',
'RAL', 'X',
'RAM', 'X',
'RAN', 'X',
'RAP', 'X',
'RBF', 'X',
'RBU', 'X',
'RCA', 'X',
'RCL', 'X',
'RCO', 'X',
'RDC', 'X',
'RDF', 'W',
'RE9', 'X',
'REA', 'X',
'RED', 'K',
'REO', 'X',
'REP', 'X',
'RET', 'X',
'RFA', 'X',
'RFB', 'X',
'RFL', 'X',
'RFP', 'X',
'RG1', 'X',
'RGS', 'X',
'RH1', 'X',
'RHA', 'X',
'RHC', 'X',
'RHD', 'X',
'RHM', 'X',
'RHO', 'X',
'RHQ', 'X',
'RHS', 'X',
'RIA', 'X',
'RIB', 'X',
'RIC', 'X',
'RIF', 'X',
'RIN', 'X',
'RIP', 'X',
'RIT', 'X',
'RMB', 'X',
'RMN', 'X',
'RMP', 'X',
'RNG', 'X',
'RNS', 'X',
'RNT', 'X',
'RO2', 'X',
'RO4', 'X',
'ROC', 'N',
'ROI', 'X',
'ROM', 'X',
'RON', 'V',
'ROP', 'X',
'ROS', 'X',
'ROX', 'X',
'RPA', 'X',
'RPD', 'X',
'RPH', 'X',
'RPL', 'X',
'RPP', 'X',
'RPR', 'X',
'RPX', 'X',
'RQ3', 'X',
'RR1', 'X',
'RR6', 'X',
'RRS', 'X',
'RS1', 'X',
'RS2', 'X',
'RS7', 'X',
'RSS', 'X',
'RTA', 'X',
'RTB', 'X',
'RTC', 'X',
'RTL', 'X',
'RUB', 'X',
'RUN', 'X',
'RWJ', 'X',
'RXP', 'X',
'S02', 'X',
'S11', 'X',
'S1H', 'S',
'S27', 'X',
'S2C', 'C',
'S3P', 'X',
'S4U', 'X',
'S57', 'X',
'S58', 'X',
'S5H', 'X',
'S6G', 'X',
'S80', 'X',
'SAA', 'X',
'SAB', 'X',
'SAC', 'S',
'SAD', 'X',
'SAE', 'X',
'SAF', 'X',
'SAH', 'C',
'SAI', 'C',
'SAL', 'X',
'SAM', 'M',
'SAN', 'X',
'SAP', 'X',
'SAR', 'X',
'SAS', 'X',
'SB1', 'X',
'SB2', 'X',
'SB3', 'X',
'SB4', 'X',
'SB5', 'X',
'SB6', 'X',
'SBA', 'L',
'SBB', 'X',
'SBD', 'A',
'SBI', 'X',
'SBL', 'A',
'SBN', 'X',
'SBO', 'X',
'SBR', 'X',
'SBS', 'X',
'SBT', 'X',
'SBU', 'X',
'SBX', 'X',
'SC4', 'X',
'SCA', 'X',
'SCC', 'X',
'SCD', 'X',
'SCH', 'C',
'SCI', 'X',
'SCL', 'X',
'SCM', 'X',
'SCN', 'X',
'SCO', 'X',
'SCP', 'S',
'SCR', 'X',
'SCS', 'X',
'SCV', 'C',
'SCY', 'C',
'SD8', 'X',
'SDK', 'X',
'SDZ', 'X',
'SE4', 'X',
'SEA', 'X',
'SEB', 'S',
'SEC', 'X',
'SEG', 'A',
'SEI', 'X',
'SEL', 'S',
'SEM', 'X',
'SEO', 'X',
'SEP', 'S',
'SER', 'S',
'SES', 'X',
'SET', 'S',
'SEU', 'X',
'SF4', 'X',
'SFG', 'X',
'SFN', 'X',
'SFO', 'X',
'SGA', 'X',
'SGC', 'X',
'SGL', 'X',
'SGM', 'X',
'SGN', 'X',
'SGP', 'X',
'SHA', 'X',
'SHC', 'X',
'SHF', 'X',
'SHH', 'X',
'SHP', 'G',
'SHR', 'E',
'SHT', 'T',
'SHU', 'X',
'SI2', 'X',
'SIA', 'X',
'SIF', 'X',
'SIG', 'X',
'SIH', 'X',
'SIM', 'X',
'SIN', 'X',
'SKD', 'X',
'SKF', 'X',
'SLB', 'X',
'SLE', 'X',
'SLZ', 'K',
'SMA', 'X',
'SMC', 'C',
'SME', 'M',
'SML', 'X',
'SMM', 'M',
'SMN', 'X',
'SMP', 'X',
'SMS', 'X',
'SN1', 'X',
'SN6', 'X',
'SN7', 'X',
'SNC', 'C',
'SNN', 'X',
'SNP', 'X',
'SO1', 'X',
'SO2', 'X',
'SO3', 'X',
'SO4', 'X',
'SOA', 'X',
'SOC', 'C',
'SOM', 'X',
'SOR', 'X',
'SOT', 'X',
'SOX', 'X',
'SPA', 'X',
'SPB', 'X',
'SPC', 'X',
'SPD', 'X',
'SPE', 'X',
'SPG', 'X',
'SPH', 'X',
'SPI', 'X',
'SPK', 'X',
'SPM', 'X',
'SPN', 'X',
'SPO', 'X',
'SPP', 'X',
'SPS', 'X',
'SPY', 'X',
'SQU', 'X',
'SRA', 'X',
'SRB', 'X',
'SRD', 'X',
'SRL', 'X',
'SRM', 'X',
'SRS', 'X',
'SRY', 'X',
'SSA', 'X',
'SSB', 'X',
'SSG', 'X',
'SSP', 'X',
'ST1', 'X',
'ST2', 'X',
'ST3', 'X',
'ST4', 'X',
'ST5', 'X',
'ST6', 'X',
'STA', 'X',
'STB', 'X',
'STE', 'X',
'STG', 'X',
'STI', 'X',
'STL', 'X',
'STN', 'X',
'STO', 'X',
'STP', 'X',
'STR', 'X',
'STU', 'X',
'STY', 'Y',
'SU1', 'X',
'SU2', 'X',
'SUC', 'X',
'SUI', 'X',
'SUL', 'X',
'SUR', 'X',
'SVA', 'S',
'SWA', 'X',
'T16', 'X',
'T19', 'X',
'T23', 'X',
'T29', 'X',
'T33', 'X',
'T3P', 'X',
'T42', 'A',
'T44', 'X',
'T5A', 'X',
'T6A', 'T',
'T6P', 'X',
'T80', 'X',
'T87', 'X',
'TA1', 'X',
'TAA', 'X',
'TAB', 'X',
'TAC', 'X',
'TAD', 'X',
'TAF', 'X',
'TAM', 'X',
'TAP', 'X',
'TAR', 'X',
'TAS', 'X',
'TAU', 'X',
'TAX', 'X',
'TAZ', 'X',
'TB9', 'X',
'TBA', 'X',
'TBD', 'X',
'TBG', 'G',
'TBH', 'X',
'TBM', 'T',
'TBO', 'X',
'TBP', 'X',
'TBR', 'X',
'TBS', 'X',
'TBT', 'X',
'TBU', 'X',
'TBZ', 'X',
'TC4', 'X',
'TCA', 'X',
'TCB', 'X',
'TCH', 'X',
'TCK', 'X',
'TCL', 'X',
'TCM', 'X',
'TCN', 'X',
'TCP', 'X',
'TCR', 'W',
'TCS', 'X',
'TCZ', 'X',
'TDA', 'X',
'TDB', 'X',
'TDG', 'X',
'TDP', 'X',
'TDR', 'X',
'TDX', 'X',
'TEA', 'X',
'TEM', 'X',
'TEN', 'X',
'TEO', 'X',
'TEP', 'X',
'TER', 'X',
'TES', 'X',
'TET', 'X',
'TFA', 'X',
'TFB', 'X',
'TFH', 'X',
'TFI', 'X',
'TFK', 'X',
'TFP', 'X',
'THA', 'X',
'THB', 'X',
'THC', 'T',
'THD', 'X',
'THE', 'X',
'THF', 'X',
'THJ', 'X',
'THK', 'X',
'THM', 'X',
'THN', 'X',
'THO', 'T',
'THP', 'X',
'THQ', 'X',
'THR', 'T',
'THS', 'X',
'THT', 'X',
'THU', 'X',
'THX', 'X',
'THZ', 'X',
'TI1', 'X',
'TI2', 'X',
'TI3', 'P',
'TIA', 'X',
'TIH', 'A',
'TK4', 'X',
'TLA', 'X',
'TLC', 'X',
'TLM', 'X',
'TLN', 'X',
'TLX', 'X',
'TM5', 'X',
'TM6', 'X',
'TMA', 'X',
'TMB', 'T',
'TMC', 'X',
'TMD', 'T',
'TME', 'X',
'TMF', 'X',
'TML', 'K',
'TMM', 'X',
'TMN', 'X',
'TMP', 'X',
'TMQ', 'X',
'TMR', 'X',
'TMT', 'X',
'TMZ', 'X',
'TNB', 'C',
'TND', 'X',
'TNK', 'X',
'TNP', 'X',
'TNT', 'X',
'TOA', 'X',
'TOB', 'X',
'TOC', 'X',
'TOL', 'X',
'TOP', 'X',
'TOS', 'X',
'TOT', 'X',
'TP1', 'G',
'TP2', 'P',
'TP3', 'E',
'TP4', 'E',
'TP7', 'T',
'TPA', 'X',
'TPE', 'X',
'TPF', 'X',
'TPI', 'X',
'TPL', 'W',
'TPM', 'X',
'TPN', 'G',
'TPO', 'T',
'TPP', 'X',
'TPQ', 'A',
'TPR', 'P',
'TPS', 'X',
'TPT', 'X',
'TPV', 'X',
'TPX', 'X',
'TPY', 'X',
'TQ3', 'X',
'TQ4', 'X',
'TQ5', 'X',
'TQ6', 'X',
'TR1', 'X',
'TRA', 'X',
'TRB', 'X',
'TRC', 'X',
'TRD', 'X',
'TRE', 'X',
'TRF', 'W',
'TRG', 'K',
'TRH', 'X',
'TRI', 'X',
'TRJ', 'X',
'TRM', 'X',
'TRN', 'W',
'TRO', 'W',
'TRP', 'W',
'TRQ', 'X',
'TRS', 'X',
'TRX', 'W',
'TRZ', 'X',
'TS2', 'X',
'TS3', 'X',
'TS4', 'X',
'TS5', 'X',
'TSA', 'X',
'TSB', 'X',
'TSI', 'X',
'TSM', 'X',
'TSN', 'X',
'TSP', 'X',
'TSU', 'X',
'TTA', 'X',
'TTE', 'X',
'TTN', 'X',
'TTO', 'X',
'TTP', 'X',
'TTX', 'X',
'TXL', 'X',
'TYA', 'Y',
'TYB', 'Y',
'TYD', 'X',
'TYI', 'Y',
'TYL', 'X',
'TYM', 'W',
'TYN', 'Y',
'TYQ', 'Y',
'TYR', 'Y',
'TYS', 'Y',
'TYV', 'X',
'TYY', 'A',
'TZB', 'X',
'TZC', 'X',
'TZE', 'X',
'TZL', 'X',
'TZO', 'X',
'TZP', 'X',
'U01', 'X',
'U02', 'X',
'U03', 'X',
'U04', 'X',
'U05', 'X',
'U0E', 'X',
'U10', 'X',
'U18', 'X',
'U2G', 'X',
'U3P', 'X',
'U49', 'X',
'U55', 'X',
'U5P', 'X',
'U66', 'X',
'U89', 'X',
'U8U', 'X',
'UAA', 'X',
'UAG', 'A',
'UAP', 'X',
'UAR', 'X',
'UC1', 'X',
'UC2', 'X',
'UC3', 'X',
'UC4', 'X',
'UD1', 'X',
'UD2', 'X',
'UDP', 'X',
'UDX', 'X',
'UFG', 'X',
'UFM', 'X',
'UFP', 'X',
'UGA', 'X',
'UIN', 'X',
'UKP', 'A',
'UM3', 'X',
'UMA', 'A',
'UMG', 'X',
'UMP', 'X',
'UNA', 'X',
'UND', 'X',
'UNI', 'X',
'UNK', 'X',
'UNN', 'X',
'UNX', 'X',
'UP5', 'X',
'UP6', 'X',
'UPA', 'X',
'UPF', 'X',
'UPG', 'X',
'UPP', 'X',
'UQ1', 'X',
'UQ2', 'X',
'UQ6', 'X',
'UR2', 'X',
'URA', 'X',
'URE', 'X',
'URF', 'X',
'URI', 'X',
'URS', 'X',
'UTP', 'X',
'UVC', 'X',
'UVW', 'X',
'V35', 'X',
'V36', 'X',
'V4O', 'X',
'V7O', 'X',
'VAA', 'V',
'VAC', 'X',
'VAD', 'V',
'VAF', 'V',
'VAG', 'X',
'VAL', 'V',
'VAN', 'X',
'VAS', 'X',
'VAX', 'X',
'VDX', 'X',
'VDY', 'X',
'VG1', 'X',
'VIB', 'X',
'VIR', 'X',
'VIT', 'X',
'VK3', 'X',
'VO3', 'X',
'VO4', 'X',
'VS1', 'F',
'VS2', 'F',
'VS3', 'F',
'VS4', 'F',
'VXA', 'X',
'W01', 'X',
'W02', 'X',
'W03', 'X',
'W11', 'X',
'W33', 'X',
'W35', 'X',
'W42', 'X',
'W43', 'X',
'W54', 'X',
'W56', 'X',
'W59', 'X',
'W71', 'X',
'W84', 'X',
'W8R', 'X',
'W91', 'X',
'WAY', 'X',
'WCC', 'X',
'WO2', 'X',
'WO4', 'X',
'WRB', 'X',
'WRR', 'X',
'WRS', 'X',
'WW7', 'X',
'X2F', 'X',
'X7O', 'X',
'XAA', 'X',
'XAN', 'X',
'XAO', 'X',
'XBB', 'X',
'XBP', 'X',
'XDN', 'X',
'XDP', 'X',
'XIF', 'X',
'XIM', 'X',
'XK2', 'X',
'XL1', 'X',
'XLS', 'X',
'XMP', 'X',
'XN1', 'X',
'XN2', 'X',
'XN3', 'X',
'XUL', 'X',
'XV6', 'X',
'XYD', 'X',
'XYH', 'X',
'XYL', 'X',
'XYP', 'X',
'XYS', 'X',
'YOF', 'Y',
'YRR', 'X',
'YT3', 'X',
'YZ9', 'X',
'Z34', 'G',
'Z5A', 'X',
'ZAF', 'X',
'ZAP', 'X',
'ZEB', 'X',
'ZEN', 'X',
'ZES', 'X',
'ZID', 'X',
'ZMR', 'X',
'ZN3', 'X',
'ZNH', 'X',
'ZNO', 'X',
'ZO3', 'X',
'ZPR', 'P',
'ZRA', 'A',
'ZST', 'X',
'ZYA', 'A',


'ASN','N');
} 


sub file2head
      {
	my $file = shift;
	my $size = shift;
	my $f= new FileHandle;
	my $line;
	open ($f,$file);
	read ($f,$line, $size);
	close ($f);
	return $line;
      }
sub file2tail
      {
	my $file = shift;
	my $size = shift;
	my $f= new FileHandle;
	my $line;
	
	open ($f,$file);
	seek ($f,$size*-1, 2);
	read ($f,$line, $size);
	close ($f);
	return $line;
      }


sub vtmpnam
      {
	my $r=rand(100000);
	my $f="file.$r.$$";
	while (-e $f)
	  {
	    $f=vtmpnam();
	  }
	push (@TMPFILE_LIST, $f);
	return $f;
      }

sub myexit
  {
    my $code=@_[0];
    if ($CLEAN_EXIT_STARTED==1){return;}
    else {$CLEAN_EXIT_STARTED=1;}
    ### ONLY BARE EXIT
    exit ($code);
  }
sub set_error_lock
    {
      my $name = shift;
      my $pid=$$;

      
      &lock4tc ($$,"LERROR", "LSET", "$$ -- ERROR: $name $PROGRAM\n");
      return;
    }
sub set_lock
  {
    my $pid=shift;
    my $msg= shift;
    my $p=getppid();
    &lock4tc ($pid,"LLOCK","LRESET","$p$msg\n");
  }
sub unset_lock
   {
     
    my $pid=shift;
    &lock4tc ($pid,"LLOCK","LRELEASE","");
  }
sub shift_lock
  {
    my $from=shift;
    my $to=shift;
    my $from_type=shift;
    my $to_type=shift;
    my $action=shift;
    my $msg;
    
    if (!&lock4tc($from, $from_type, "LCHECK", "")){return 0;}
    $msg=&lock4tc ($from, $from_type, "LREAD", "");
    &lock4tc ($from, $from_type,"LRELEASE", $msg);
    &lock4tc ($to, $to_type, $action, $msg);
    return;
  }
sub isshellpid
  {
    my $p=shift;
    if (!lock4tc ($p, "LLOCK", "LCHECK")){return 0;}
    else
      {
	my $c=lock4tc($p, "LLOCK", "LREAD");
	if ( $c=~/-SHELL-/){return 1;}
      }
    return 0;
  }
sub isrootpid
  {
    if(lock4tc (getppid(), "LLOCK", "LCHECK")){return 0;}
    else {return 1;}
  }
sub lock4tc
	{
	  my ($pid,$type,$action,$value)=@_;
	  my $fname;
	  my $host=hostname;
	  
	  if ($type eq "LLOCK"){$fname="$LOCKDIR/.$pid.$host.lock4tcoffee";}
	  elsif ( $type eq "LERROR"){ $fname="$LOCKDIR/.$pid.$host.error4tcoffee";}
	  elsif ( $type eq "LWARNING"){ $fname="$LOCKDIR/.$pid.$host.warning4tcoffee";}
	  
	  if ($debug_lock)
	    {
	      print STDERR "\n\t---lock4tc(tcg): $action => $fname =>$value (RD: $LOCKDIR)\n";
	    }

	  if    ($action eq "LCHECK") {return -e $fname;}
	  elsif ($action eq "LREAD"){return file2string($fname);}
	  elsif ($action eq "LSET") {return string2file ($value, $fname, ">>");}
	  elsif ($action eq "LRESET") {return string2file ($value, $fname, ">");}
	  elsif ($action eq "LRELEASE") 
	    {
	      if ( $debug_lock)
		{
		  my $g=new FileHandle;
		  open ($g, ">>$fname");
		  print $g "\nDestroyed by $$\n";
		  close ($g);
		  safe_system ("mv $fname $fname.old");
		}
	      else
		{
		  unlink ($fname);
		}
	    }
	  return "";
	}
	
sub file2string
	{
	  my $file=@_[0];
	  my $f=new FileHandle;
	  my $r;
	  open ($f, "$file");
	  while (<$f>){$r.=$_;}
	  close ($f);
	  return $r;
	}
sub string2file 
    {
    my ($s,$file,$mode)=@_;
    my $f=new FileHandle;
    
    open ($f, "$mode$file");
    print $f  "$s";
    close ($f);
  }

BEGIN
    {
      srand;
    
      $SIG{'SIGUP'}='signal_cleanup';
      $SIG{'SIGINT'}='signal_cleanup';
      $SIG{'SIGQUIT'}='signal_cleanup';
      $SIG{'SIGILL'}='signal_cleanup';
      $SIG{'SIGTRAP'}='signal_cleanup';
      $SIG{'SIGABRT'}='signal_cleanup';
      $SIG{'SIGEMT'}='signal_cleanup';
      $SIG{'SIGFPE'}='signal_cleanup';
      
      $SIG{'SIGKILL'}='signal_cleanup';
      $SIG{'SIGPIPE'}='signal_cleanup';
      $SIG{'SIGSTOP'}='signal_cleanup';
      $SIG{'SIGTTIN'}='signal_cleanup';
      $SIG{'SIGXFSZ'}='signal_cleanup';
      $SIG{'SIGINFO'}='signal_cleanup';
      
      $SIG{'SIGBUS'}='signal_cleanup';
      $SIG{'SIGALRM'}='signal_cleanup';
      $SIG{'SIGTSTP'}='signal_cleanup';
      $SIG{'SIGTTOU'}='signal_cleanup';
      $SIG{'SIGVTALRM'}='signal_cleanup';
      $SIG{'SIGUSR1'}='signal_cleanup';


      $SIG{'SIGSEGV'}='signal_cleanup';
      $SIG{'SIGTERM'}='signal_cleanup';
      $SIG{'SIGCONT'}='signal_cleanup';
      $SIG{'SIGIO'}='signal_cleanup';
      $SIG{'SIGPROF'}='signal_cleanup';
      $SIG{'SIGUSR2'}='signal_cleanup';

      $SIG{'SIGSYS'}='signal_cleanup';
      $SIG{'SIGURG'}='signal_cleanup';
      $SIG{'SIGCHLD'}='signal_cleanup';
      $SIG{'SIGXCPU'}='signal_cleanup';
      $SIG{'SIGWINCH'}='signal_cleanup';
      
      $SIG{'INT'}='signal_cleanup';
      $SIG{'TERM'}='signal_cleanup';
      $SIG{'KILL'}='signal_cleanup';
      $SIG{'QUIT'}='signal_cleanup';
      
      our $debug_lock=$ENV{"DEBUG_LOCK"};
      
      
      
      
      foreach my $a (@ARGV){$CL.=" $a";}
      if ( $debug_lock ){print STDERR "\n\n\n********** START PG: $PROGRAM *************\n";}
      if ( $debug_lock ){print STDERR "\n\n\n**********(tcg) LOCKDIR: $LOCKDIR $$ *************\n";}
      if ( $debug_lock ){print STDERR "\n --- $$ -- $CL\n";}
      
	     
      
      
    }
sub flush_error
  {
    my $msg=shift;
    return add_error ($EXIT_FAILURE,$$, $$,getppid(), $msg, $CL);
  }
sub add_error 
  {
    my $code=shift;
    my $rpid=shift;
    my $pid=shift;
    my $ppid=shift;
    my $type=shift;
    my $com=shift;
    
    $ERROR_DONE=1;
    lock4tc ($rpid, "LERROR","LSET","$pid -- ERROR: $type\n");
    lock4tc ($$, "LERROR","LSET", "$pid -- COM: $com\n");
    lock4tc ($$, "LERROR","LSET", "$pid -- STACK: $ppid -> $pid\n");
   
    return $code;
  }
sub add_warning 
  {
    my $rpid=shift;
    my $pid =shift;
    my $command=shift;
    my $msg="$$ -- WARNING: $command\n";
    print STDERR "$msg";
    lock4tc ($$, "LWARNING", "LSET", $msg);
  }

sub signal_cleanup
  {
    print dtderr "\n**** $$ (tcg) was killed\n";
    &cleanup;
    exit ($EXIT_FAILURE);
  }
sub clean_dir
  {
    my $dir=@_[0];
    if ( !-d $dir){return ;}
    elsif (!($dir=~/tmp/)){return ;}#safety check 1
    elsif (($dir=~/\*/)){return ;}#safety check 2
    else
      {
	`rm -rf $dir`;
      }
    return;
  }
sub cleanup
  {
    #print stderr "\n----tc: $$ Kills $PIDCHILD\n";
    #kill (SIGTERM,$PIDCHILD);
    my $p=getppid();
    $CLEAN_EXIT_STARTED=1;
    
    
    
    if (&lock4tc($$,"LERROR", "LCHECK", ""))
      {
	my $ppid=getppid();
	if (!$ERROR_DONE) 
	  {
	    &lock4tc($$,"LERROR", "LSET", "$$ -- STACK: $p -> $$\n");
	    &lock4tc($$,"LERROR", "LSET", "$$ -- COM: $CL\n");
	  }
      }
    my $warning=&lock4tc($$, "LWARNING", "LREAD", "");
    my $error=&lock4tc($$,  "LERROR", "LREAD", "");
    #release error and warning lock if root
    
    if (isrootpid() && ($warning || $error) )
      {
	
	print STDERR "**************** Summary *************\n$error\n$warning\n";

	&lock4tc($$,"LERROR","RELEASE","");
	&lock4tc($$,"LWARNING","RELEASE","");
      } 
    
    
    foreach my $f (@TMPFILE_LIST)
      {
	if (-e $f){unlink ($f);} 
      }
    foreach my $d (@TMPDIR_LIST)
      {
	clean_dir ($d);
      }
    #No More Lock Release
    #&lock4tc($$,"LLOCK","LRELEASE",""); #release lock 

    if ( $debug_lock ){print STDERR "\n\n\n********** END PG: $PROGRAM ($$) *************\n";}
    if ( $debug_lock ){print STDERR "\n\n\n**********(tcg) LOCKDIR: $LOCKDIR $$ *************\n";}
  }
END 
  {
    
    &cleanup();
  }
   

sub safe_system 
{
  my $com=shift;
  my $ntry=shift;
  my $ctry=shift;
  my $pid;
  my $status;
  my $ppid=getppid();
  if ($com eq ""){return 1;}
  
  

  if (($pid = fork ()) < 0){return (-1);}
  if ($pid == 0)
    {
      set_lock($$, " -SHELL- $com (tcg)");
      exec ($com);
    }
  else
    {
      lock4tc ($$, "LLOCK", "LSET", "$pid\n");#update parent
      $PIDCHILD=$pid;
    }
  if ($debug_lock){printf STDERR "\n\t .... safe_system (fasta_seq2hmm)  p: $$ c: $pid COM: $com\n";}

  waitpid ($pid,WTERMSIG);

  shift_lock ($pid,$$, "LWARNING","LWARNING", "LSET");

  if ($? == $EXIT_FAILURE || lock4tc($pid, "LERROR", "LCHECK", ""))
    {
      if ($ntry && $ctry <$ntry)
	{
	  add_warning ($$,$$,"$com failed [retry: $ctry]");
	  lock4tc ($pid, "LRELEASE", "LERROR", "");
	  return safe_system ($com, $ntry, ++$ctry);
	}
      elsif ($ntry == -1)
	{
	  if (!shift_lock ($pid, $$, "LERROR", "LWARNING", "LSET"))
	    {
	      add_warning ($$,$$,"$com failed");
	    }
	  else
	    {
	      lock4tc ($pid, "LRELEASE", "LERROR", "");
	    }
	  return $?;}
      else
	{
	  if (!shift_lock ($pid,$$, "LERROR","LERROR", "LSET"))
	    {
	      myexit(add_error ($EXIT_FAILURE,$$,$pid,getppid(), "UNSPECIFIED system", $com));
	    }
	}
    }
  return $?;
}

sub check_configuration 
    {
      my @l=@_;
      my $v;
      foreach my $p (@l)
	{
	  
	  if   ( $p eq "EMAIL")
	    { 
	      if ( !($EMAIL=~/@/))
		{
		add_warning($$,$$,"Could Not Use EMAIL");
		myexit(add_error ($EXIT_FAILURE,$$,$$,getppid(),"EMAIL","$CL"));
	      }
	    }
	  elsif( $p eq "INTERNET")
	    {
	      if ( !&check_internet_connection())
		{
		  myexit(add_error ($EXIT_FAILURE,$$,$$,getppid(),"INTERNET","$CL"));
		}
	    }
	  elsif( $p eq "wget")
	    {
	      if (!&pg_is_installed ("wget") && !&pg_is_installed ("curl"))
		{
		  myexit(add_error ($EXIT_FAILURE,$$,$$,getppid(),"PG_NOT_INSTALLED:wget","$CL"));
		}
	    }
	  elsif( !(&pg_is_installed ($p)))
	    {
	      myexit(add_error ($EXIT_FAILURE,$$,$$,getppid(),"PG_NOT_INSTALLED:$p","$CL"));
	    }
	}
      return 1;
    }
sub pg_is_installed
  {
    my @ml=@_;
    my $r, $p, $m;
    my $supported=0;
    
    my $p=shift (@ml);
    if ($p=~/::/)
      {
	if (safe_system ("perl -M$p -e 1")==$EXIT_SUCCESS){return 1;}
	else {return 0;}
      }
    else
      {
	$r=`which $p 2>/dev/null`;
	if ($r eq ""){return 0;}
	else {return 1;}
      }
  }



sub check_internet_connection
  {
    my $internet;
    my $tmp;
    &check_configuration ( "wget"); 
    
    $tmp=&vtmpnam ();
    
    if     (&pg_is_installed    ("wget")){`wget www.google.com -O$tmp >/dev/null 2>/dev/null`;}
    elsif  (&pg_is_installed    ("curl")){`curl www.google.com -o$tmp >/dev/null 2>/dev/null`;}
    
    if ( !-e $tmp || -s $tmp < 10){$internet=0;}
    else {$internet=1;}
    if (-e $tmp){unlink $tmp;}

    return $internet;
  }
sub check_pg_is_installed
  {
    my @ml=@_;
    my $r=&pg_is_installed (@ml);
    if (!$r && $p=~/::/)
      {
	print STDERR "\nYou Must Install the perl package $p on your system.\nRUN:\n\tsudo perl -MCPAN -e 'install $pg'\n";
      }
    elsif (!$r)
      {
	myexit(flush_error("\nProgram $p Supported but Not Installed on your system"));
      }
    else
      {
	return 1;
      }
  }


sub remote_is_pdb_name_deprecated
{
    my $in=@_[0];
    my ($ref_file, $pdb);
    my ($value,$value1,$value2);
    my $max=2;
    
    
    
    $ref_file="$cache/pdb_entry_type.txt";
    
    if ( $in=~/[^\w\d\:\_]/){return 0;}
    elsif ($no_remote_pdb_dir==1)
      {
	my $pdbdir=$ENV{'PDB_DIR'};
	
	my $r1="$pdbdir/derived_data/pdb_entry_type.txt";
	my $r2=$ref_file;
	if    (-e $r1){$ref_file=$r1;}
	elsif (-e $r2){$ref_file=$r2;}
	else
	  {
	    my $p=substr ($in,0, 4);
	    add_warning ($$, $$, "Cannot find pdb_entry_type.txt;  $p is assumed to be valid; add ftp://ftp.wwpdb.org/pub/pdb/derived_data/pdb_entry_type.txt in $cache to check name status");
	  }
      }
    elsif ( !-e $ref_file || (-M $ref_file)>$max || -z $ref_file)
      {
	&url2file("ftp://ftp.wwpdb.org/pub/pdb/derived_data/pdb_entry_type.txt", $ref_file);
      }
    $pdb=substr ($in,0, 4);
    chomp(($value1=`grep -c $pdb $ref_file`));
    $pdb=lc($pdb);
    chomp(($value2=`grep -c $pdb $ref_file`));
    $value=($value1 || $value2)?1:0;
    $value=($value>0)?1:0;
    
    return $value;
  }

</content>
</file>
<file>
<stream>output</stream>
<name>install.pl</name>
<content>#!/usr/bin/env perl
use Cwd;
use Env;
use File::Path;
use FileHandle;
use strict;


our (%MODE, %PG, %ENV_SET, %SUPPORTED_OS);

our $VERSION="0"; #_#UPDATE_VERSION

our $EXIT_SUCCESS=0;
our $EXIT_FAILURE=1;
our $INTERNET=0;

our $CP="cp "; #was causing a crash on MacOSX
our $SILENT=">/dev/null 2>/dev/null";
our $WEB_BASE="http://www.tcoffee.org";
our $TCLINKDB_ADDRESS="$WEB_BASE/Resources/tclinkdb.txt";
our $OS=get_os();
our $ROOT=&get_root();
our $CD=cwd();
our $CDIR=$CD;
our $HOME=$ENV{'HOME'};

our $OSNAME=$ENV{'OSNAME'};
our $OSARCH=$ENV{'OSARCH'};
our $REPO_ROOT="";

our $TCDIR;
our $TCCACHE;
our $TCTMP;
our $TCM;
our $TCMETHODS;
our $TCPLUGINS;
our $PLUGINS_DIR="";
our $INSTALL_DIR="";
our $email;
our $recompile;

our $CXX="g++";
our $CXXFLAGS="";

our $CPP="g++";
our $CPPFLAGS="";

our $CC="gcc";
our $CFLAGS=$ENV{'CFLAGS'};

our $FC="f77";
our $FFLAGS="";

my $install="all";
my $default_update_action="no_update";
my @required_applications=("wget_OR_curl");
my @smode=("all", "clean", "install");

&initialize_PG();
my $cl=join( " ", @ARGV);
if ($#ARGV==-1 || ($cl=~/-h/) ||($cl=~/-H/) )
  {
     print "\n!!!!!!! ./install  t_coffee             --> installs t_coffee only";
     print "\n!!!!!!! ./install  all                  --> installs all the modes [mcoffee, expresso, psicoffee,rcoffee..]";
     print "\n!!!!!!! ./install  [mcoffee|rcoffee|..] --> installs the specified mode";
     print "\n!!!!!!! ./install  -h                   --> print usage\n\n";
     if ( $#ARGV==-1){exit ($EXIT_FAILURE);}
   }
     
if (($cl=~/-h/) ||($cl=~/-H/) )
  {
    my $m;
    print "\n\n!!!!!!! advanced mode\n";
    foreach $m ((keys (%MODE)),@smode)
      {
	print "!!!!!!!       ./install $m\n";
      }
    
    print "!!!!!!! ./install [target:package|mode|] [-update|-force|-exec=dir|-dis=dir|-root|-tclinkdb=file|-] [CC=|FCC=|CXX=|CFLAGS=|CXXFLAGS=]\n";
    print "!!!!!!! ./install clean    [removes all executables]\n";
    print "!!!!!!! ./install [optional:target] -update               [updates package already installed]\n";
    print "!!!!!!! ./install [optional:target] -recompile            [forces the recompilation of T-Coffee]\n";

    print "!!!!!!! ./install [optional:target] -force                [Forces recompilation over everything]\n";
    
    print "!!!!!!! ./install [optional:target] -root                 [You are running as root]\n";
    print "!!!!!!! ./install [optional:target] -exec=/foo/bar/       [address for the T-Coffee executable]\n";
    print "!!!!!!! ./install [optional:target] -dis=/foo/bar/        [Address where distributions should be stored]\n";
    print "!!!!!!! ./install [optional:target] -tclinkdb=foo|update  [file containing all the packages to be installed]\n";
    print "!!!!!!! ./install [optional:target] -clean                [clean everything]\n";
    print "!!!!!!! ./install [optional:target] -plugins              [plugins directory]\n";
    print "!!!!!!! ./install [optional:target] -tcdir=/foor/bar      [base path where T-Coffee will be installed - default ~/.t_coffee]\n";
    print "!!!!!!! ./install [optional:target] -repo=/path/to/repo   [binaries repository root directory]\n";
    print "!!!!!!! ./install [optional:target] -email=<your email>   [needed for remote BLAST]\n";
    print "!!!!!!! ./install [optional:target] -proxy=<proxy>   [may be needed to access remote services]\n";
    
    print "!!!!!!! mode:";
    foreach $m (keys(%MODE)){print "$m ";}
    print "\n";
    print "!!!!!!! Packages:";
    foreach $m (keys (%PG)){print "$m ";}
    print "\n";
    
    print "\n\n";
    exit ($EXIT_FAILURE);
  }



my (@argl)=($cl=~/(\S+=[^=]+)\s\w+=/g);
push (@argl, ($cl=~/(\S+=[^=]+\S)\s*$/g));

foreach $a (@argl)
  {
    if ( ($cl=~/CXX=(.*)/)){$CXX=$1;}
    if ( ($cl=~/-CC=(.*)/    )){$CC=$1;}
    if ( ($cl=~/-FC=(.*)/    )){$FC=$1;}
    if ( ($cl=~/-CFLAGS=(.*)/)){$CFLAGS=$1;}
    if ( ($cl=~/-CXXFLAGS=(.*)/)){$CXXFLAGS=$1;}
  }
our ($ROOT_INSTALL, $NO_QUESTION, $default_update_action,$BINARIES_ONLY,$force, $default_update_action, $INSTALL_DIR, $PLUGINS_DIR, $DISTRIBUTIONS,$tclinkdb, $proxy, $clean);
if ( ($cl=~/-root/)){$ROOT_INSTALL=1;}
if ( ($cl=~/-no_question/)){$NO_QUESTION=1;}
if ( ($cl=~/-update/)){$default_update_action="update";}
if ( ($cl=~/-recompile/)){$recompile=1;}


$BINARIES_ONLY=1;

if ( ($cl=~/-nobinaries/)){$BINARIES_ONLY=0;}
if ( ($cl=~/-force/)){$force=1;$default_update_action="update"}
if ( ($cl=~/-exec=\s*(\S+)/)){$INSTALL_DIR=$1;}
if ( ($cl=~/-plugins=\s*(\S+)/)){$PLUGINS_DIR=$1;}
if ( ($cl=~/-dis=\s*(\S+)/)){$DISTRIBUTIONS=$1;}

if ( ($cl=~/-tclinkdb=\s*(\S+)/)){$tclinkdb=$1;}
if ( ($cl=~/-proxy=\s*(\S+)/)){$proxy=$1;}
if ( ($cl=~/-clean/)){$clean=1;}
if ( ($cl=~/-repo=\s*(\S+)/)){ $REPO_ROOT=$1; }
if ( ($cl=~/-tcdir=\s*(\S+)/)){ $TCDIR=$1; }

if ( ($cl=~/-email=\s*(\S+)/)){$email=$1;}


if ($tclinkdb){&update_tclinkdb ($tclinkdb);}


if( $REPO_ROOT ne "" ) {
	if( $OSNAME eq "" ) { print "You have specified the repository folder but the required \"OSNAME\" enviroment variable is missing. \n"; exit 1; } 
	if( $OSARCH eq "" ) { print "You have specified the repository folder but the required \"OSARCH\" enviroment variable is missing. \n"; exit 1; } 
}


if(!$TCDIR) { $TCDIR="$HOME/.t_coffee"; }
&add_dir ($TCDIR);
&add_dir ($TCCACHE="$TCDIR/cache");
&add_dir ($TCTMP="$CDIR/tmp");
&add_dir ($TCM="$TCDIR/mcoffee");
&add_dir ($TCMETHODS="$TCDIR/methods");
&add_dir ($TCPLUGINS="$TCDIR/plugins/$OS");


our $BASE="$CD/bin";
our $BIN="$BASE/cache/binaries/$OS";
our $DOWNLOAD_DIR="$BASE/cache/download";
our $DOWNLOAD_FILE="$DOWNLOAD_DIR/files";
our $TMP="$BASE/cache/tmp";

&add_dir($BASE);
&add_dir($BIN);
&add_dir($DOWNLOAD_DIR);
&add_dir($DOWNLOAD_FILE);
if (!$DISTRIBUTIONS){$DISTRIBUTIONS="$DOWNLOAD_DIR/distributions";}
&add_dir ($DISTRIBUTIONS);
&add_dir ($TMP);


if    (!$PLUGINS_DIR && !$ROOT_INSTALL){$PLUGINS_DIR=$TCPLUGINS;}
elsif (!$PLUGINS_DIR &&  $ROOT_INSTALL){$PLUGINS_DIR="/usr/local/bin/";}

if    (!$INSTALL_DIR && !$ROOT_INSTALL){$INSTALL_DIR="$TCDIR/bin/$OS";mkpath ($INSTALL_DIR);}
elsif (!$INSTALL_DIR &&  $ROOT_INSTALL){$INSTALL_DIR="/usr/local/bin/";}

if (-d "mcoffee"){`cp mcoffee/* $TCM`;}


our $ENV_FILE="$TCDIR/.t_coffee_env";
unlink ($ENV_FILE);
&add2env_file ($ENV_FILE,"EMAIL_4_TCOFFEE", $email);
&add2env_file ($ENV_FILE,"http_proxy_4_TCOFFEE", $proxy);
&env_file2putenv ($ENV_FILE);
&set_proxy($proxy);



my ($target, $p, $r);
$target=$p;

foreach $p (  ((keys (%PG)),(keys(%MODE)),(@smode)) )
  {
    if ($ARGV[0] eq $p && $target eq ""){$target=$p;}
  }
if ($target eq ""){exit ($EXIT_FAILURE);}


foreach $r (@required_applications)
  {
    my @app_list;
    my $i;
    $i=0;
    
    @app_list=split (/_OR_/, $r);
    foreach my $pg (@app_list)
      {
	$i+=&pg_is_installed ($pg);
      }
    if ($i==0)
      {
      print "One of the following packages must be installed to proceed: ";
      foreach my $pg (@app_list)
	{
	  print ("$pg ");
	}
      die;
    }
  }






&sign_license_ni();


$PG{C}{compiler}=get_C_compiler($CC);
$PG{Fortran}{compiler}=get_F_compiler($FC);
$PG{CXX}{compiler}=$PG{CPP}{compiler}=$PG{GPP}{compiler}=get_CXX_compiler($CXX);
if ($CXXFLAGS){$PG{CPP}{options}=$PG{GPP}{options}=$PG{CXX}{options}=$CXXFLAGS;}
if ($CFLAGS ne "" ){$PG{C}{options}=$CFLAGS;}
foreach my $c (keys(%PG))
  {
    my $arguments;
    if ($PG{$c}{compiler})
      {
	$arguments="$PG{$c}{compiler_flag}=$PG{$c}{compiler} ";
	if ($PG{$c}{options})
	  {
	    $arguments.="$PG{$c}{options_flag}='" . $PG{$c}{options} . "' ";
	  }
	$PG{$c}{arguments}=$arguments;
      }
  }

if ($PG{$target}){$PG{$target}{install}=1;}
else
  {
    foreach my $pg (keys(%PG))
      {
	if ( $target eq "all" || ($PG{$pg}{mode}=~/$target/))
	  {
	    $PG{$pg} {install}=1;
	  }
      }
  }

foreach my $pg (keys(%PG))
  {
    if (!$PG{$pg}{update_action}){$PG{$pg}{update_action}=$default_update_action;}
    elsif ($PG{$pg}{update_action} eq "never"){$PG{$pg}{install}=0;}
    if ( $force && $PG{$pg}{install})
      {
	`rm $BIN/$pg $BIN/$pg.exe $SILENT`;
      }
    if ($PG{$pg}{update_action} eq "update" && $PG{$pg}{install}){$PG{$pg}{update}=1;}
  }

if (($target=~/clean/))
  {
    print "------- cleaning executables -----\n";
    `rm bin/* $SILENT`;
    exit ($EXIT_SUCCESS);
  }

if ( !$PG{$target}){print "------- Installing T-Coffee Modes\n";}

foreach my $m (keys(%MODE))
  {
    if ( $target eq "all" || $target eq $m)
      {
	print "\n------- The installer will now install the $m components $MODE{$m}{description}\n";
	foreach my $pg (keys(%PG))
	  {
	    if ( $PG{$pg}{mode} =~/$m/ && $PG{$pg}{install})
	      {
		if ($PG{$pg}{touched}){print "------- $PG{$pg}{dname}: already processed\n";}
		else {$PG{$pg}{success}=&install_pg($pg);$PG{$pg}{touched}=1;}
	      }
	  }
      }
  }

if ( $PG{$target}){print "------- Installing Individual Package\n";}
foreach my $pg (keys (%PG))
  {
    
    if ( $PG{$pg}{install} && !$PG{$pg}{touched})
      {
	print "\n------- Install $pg\n";
	$PG{$pg}{success}=&install_pg($pg);$PG{$pg}{touched}=1;
      }
  }
print "------- Finishing The installation\n";
my $final_report=&install ($INSTALL_DIR);

print "\n";
print "*********************************************************************\n";
print "********              INSTALLATION SUMMARY          *****************\n";
print "*********************************************************************\n";
print "------- SUMMARY package Installation:\n";
print "-------   Executable Installed in: $PLUGINS_DIR\n";

foreach my $pg (keys(%PG))
  {
    if ( $PG{$pg}{install})
      {
	my $bin_status=($PG{$pg}{from_binary} && $PG{$pg}{success})?"[from binary]":"";
	if     ( $PG{$pg}{new} && !$PG{$pg}{old})                     {print "*------        $PG{$pg}{dname}: installed $bin_status\n"; $PG{$pg}{status}=1;}
	elsif  ( $PG{$pg}{new} &&  $PG{$pg}{old})                     {print "*------        $PG{$pg}{dname}: updated $bin_status\n"  ; $PG{$pg}{status}=1;} 
	elsif  (!$PG{$pg}{new} &&  $PG{$pg}{old} && !$PG{$pg}{update}){print "*------        $PG{$pg}{dname}: previous\n" ; $PG{$pg}{status}=1;}
	elsif  (!$PG{$pg}{new} &&  $PG{$pg}{old} &&  $PG{$pg}{update}){print "*------        $PG{$pg}{dname}: failed update (previous installation available)\n";$PG{$pg}{status}=0;}
	else                                                          {print "*------        $PG{$pg}{dname}: failed installation\n";$PG{$pg}{status}=0;}
      }
  }
my $failure;

if ( !$PG{$target}){print "*------ SUMMARY mode Installation:\n";}
foreach my $m (keys(%MODE))
  {
  
    if ( $target eq "all" || $target eq $m)
      {
	my $succesful=1;
	foreach my $pg (keys(%PG))
	  {
	    if (($PG{$pg}{mode}=~/$m/) && $PG{$pg}{install} && $PG{$pg}{status}==0)
	      {
		$succesful=0;
		print "*!!!!!!       $PG{$pg}{dname}: Missing\n";
	      }
	  }
	if ( $succesful)
	  {
	    $MODE{$m}{status}=1;
	    print "*------       MODE $MODE{$m}{dname} SUCCESSFULLY installed\n";
	  }
	else
	  {
	    $failure++;
	    $MODE{$m}{status}=0;
	    print "*!!!!!!       MODE $MODE{$m}{dname} UNSUCCESSFULLY installed\n";
	  }
      }
  }

    
      
if ($clean==1 && ($BASE=~/install4tcoffee/) ){print "*------ Clean Installation Directory: $BASE\n";`rm -rf $BASE`;}
foreach my $pg (keys(%PG)){if ($PG{$pg}{install} && $PG{$pg}{status}==0){exit ($EXIT_FAILURE);}}

if ($failure)
  {
    print "*********************************************************************\n";
    print "********     SOME PACKAGES FAILED TO INSTALL        *****************\n";
    print "*********************************************************************\n";
    print "\nSome of the reported failures may be due to connectivity problems";
    print "\nRerun the installation and the installer will specifically try to install the missing packages";
    print "\nIf this Fails, go to the original website and install the package manually";
  }

print "*********************************************************************\n";
print "********              FINALIZE YOUR INSTALLATION    *****************\n";
print "*********************************************************************\n";
print "------- Your third party executables are in:\n"; 
print "-------       $PLUGINS_DIR:\n";
print "------- Your t_coffee exccutable is in\n";
print "-------       $INSTALL_DIR:\n";
print "------- In order to make your installation permanent add these two lines\n";
print "-------       export PATH=$INSTALL_DIR:\$PATH\n";
print "-------       export PLUGINS_4_TCOFFEE=$PLUGINS_DIR:\n";
if ($OS eq "linux")
  {
    print "-------       to the file: $HOME/.bashrc\n";
  }
else 
  {
    print "-------       to the file: $HOME/.profile\n";
  }
exit ($EXIT_SUCCESS);  
  
sub get_CXX_compiler
  {
    my $c=@_[0];
    my (@clist)=("g++");
    
    return get_compil ($c, @clist);
 }
sub get_C_compiler
  {
    my $c=@_[0];
    my (@clist)=("gcc", "cc", "icc");
    
    return get_compil ($c, @clist);
 }

sub get_F_compiler
  {
    my ($c)=@_[0];
    my @clist=("f77", "g77","g95", "gfortran", "ifort");
    return get_compil ($c, @clist);
  } 
       
sub get_compil
  {
    my ($fav,@clist)=(@_);
    
    #return the first compiler found installed in the system. Check first the favorite
    foreach my $c ($fav,@clist)
      {
	if  (&pg_is_installed ($c)){return $c;}
      }
    return "";
  }
sub exit_if_pg_not_installed
  {
    my (@arg)=(@_);
    
    foreach my $p (@arg)
      {
	if ( !&pg_is_installed ($p))
	  {
	    print "!!!!!!!! The $p utility must be installed for this installation to proceed [FATAL]\n";
	    die;
	  }
      }
    return 1;
  }
sub set_proxy
  {
    my ($proxy)=(@_);
    my (@list,$p);
    
    @list= ("HTTP_proxy", "http_proxy", "HTTP_PROXY", "ALL_proxy", "all_proxy","HTTP_proxy_4_TCOFFEE","http_proxy_4_TCOFFEE");
    
    if (!$proxy)
      {
	foreach my $p (@list)
	  {
	    if ( ($ENV_SET{$p}) || $ENV{$p}){$proxy=$ENV{$p};}
	  }
      }
    foreach my $p(@list){$ENV{$p}=$proxy;}
  }
	
sub check_internet_connection
  {
    my $internet;
    
    if ( -e "x"){unlink ("x");}
    if     (&pg_is_installed    ("wget")){`wget www.google.com -Ox >/dev/null 2>/dev/null`;}
    elsif  (&pg_is_installed    ("curl")){`curl www.google.com -ox >/dev/null 2>/dev/null`;}
    else
      {
	printf stderr "\nERROR: No pg for remote file fetching [wget or curl][FATAL]\n";
	exit ($EXIT_FAILURE);
      }
    
    if ( !-e "x" || -s "x" < 10){$internet=0;}
    else {$internet=1;}
    if (-e "x"){unlink "x";}
    return $internet;
  }
sub url2file
  {
    my ($cmd, $file,$wget_arg, $curl_arg)=(@_);
    my ($exit,$flag, $pg, $arg);
    
    if ($INTERNET || check_internet_connection ()){$INTERNET=1;}
    else
      {
	print STDERR "ERROR: No Internet Connection [FATAL:install.pl]\n";
	exit ($EXIT_FAILURE);
      }
    
    if     (&pg_is_installed    ("wget")){$pg="wget"; $flag="-O";$arg="--tries=2 --connect-timeout=10 --no-check-certificate $wget_arg";}
    elsif  (&pg_is_installed    ("curl")){$pg="curl"; $flag="-o";$arg=$curl_arg;}
    else
      {
	printf stderr "\nERROR: No pg for remote file fetching [wget or curl][FATAL]\n";
	exit ($EXIT_FAILURE);
      }
    
    
    if (-e $file){unlink($file);}
    $exit=system "$pg $cmd $flag$file $arg";
    return $exit;
  }

sub pg_is_installed
  {
    my ($p, $dir)=(@_);
    my ($r,$m, $ret);
    my ($supported, $language, $compil);
    
  
    if ( $PG{$p})
      {
	$language=$PG{$p}{language2};
	$compil=$PG{$language}{compiler};
      }
    
    if ( $compil eq "CPAN")
      {
	if ( system ("perl -M$p -e 1")==$EXIT_SUCCESS){$ret=1;}
	else {$ret=0;}
      }
    elsif ($dir)
      {
	if (-e "$dir/$p" || -e "$dir/$p\.exe"){$ret=1;}
	else {$ret=0;}
      }
    elsif (-e "$PLUGINS_DIR/$p" || -e "$PLUGINS_DIR/$p.exe"){$ret=1;}
    else
      {
	$r=`which $p 2>/dev/null`;
	if ($r eq ""){$ret=0;}
	else {$ret=1;}
      }
   
    return $ret;
  }
sub install
  {
    my ($new_bin)=(@_);
    my ($copied, $report);

    
    if (!$ROOT_INSTALL)
      {
	`$CP $BIN/* $PLUGINS_DIR`;
	if (-e "$BIN/t_coffee")
	  {
	    `$CP $BIN/t_coffee $INSTALL_DIR`;
	      unlink("$PLUGINS_DIR/t_coffee");
	  }
	$copied=1;
      }
    else
      {
	$copied=&root_run ("You must be root to finalize the installation", "$CP $BIN/* $PLUGINS_DIR $SILENT");
	if (-e "$BIN/t_coffee")
	  {
	    &root_run ("You must be root to finalize the installation", "$CP $BIN/t_coffee $INSTALL_DIR");
	    &root_run ("You must be root to finalize the installation", "rm  $PLUGINS_DIR/t_coffee");
	  }
      }
    
     
  if ( !$copied)
    {
      $report="*!!!!!! Installation unsuccesful. The executables have been left in $BASE/bin\n";
    }
  elsif ( $copied && $ROOT)
    {
      $report="*------ Installation succesful. Your executables have been copied in $new_bin and are on your PATH\n";
    }
  elsif ( $copied && !$ROOT)
    {
      $report= "*!!!!!! T-Coffee has been installed in $INSTALL_DIR\n";
      $report= "*!!!!!! T-Coffee and associated packages have been copied in: $PLUGINS_DIR\n";
      $report.="*!!!!!! This T-Coffee location is NOT on your PATH sytem variable\n";
      if ( $OS eq "linux")
	{
	  $report.="*!!!!!! You can do so by adding the following line in your ~/.bashrc file:\n";
	}
      else
	{
	  $report.="*!!!!!! You can do so by adding the following line in your ~/.profile file:\n";
	}
      $report.="*!!!!!! export PATH=$INSTALL_DIR:\$PATH\n";
    }
  return $report;
}

sub sign_license_ni
  {
    my $F=new FileHandle;
    open ($F, "license.txt");
    while (<$F>)
      {
	print "$_";
      }
    close ($F);
    
    return;
  }

sub install_pg
  {
    my ($pg)=(@_);
    my ($report, $previous, $language, $compiler, $return);
    
    if (!$PG{$pg}{install}){return 1;}
    
    $previous=&pg_is_installed ($pg);
    
    if ($PG{$pg}{update_action} eq "no_update" && $previous)
      {
	$PG{$pg}{old}=1;
	$PG{$pg}{new}=0;
	$return=1;
      }
    else
      {
	$PG{$pg}{old}=$previous;
	
	if ($PG{$pg} {language2} eq "Perl"){&install_perl_package ($pg);}
	elsif ($BINARIES_ONLY && &install_binary_package ($pg)){$PG{$pg}{from_binary}=1;}
	elsif (&install_source_package ($pg)){;}
	else 
	  {
	    
	    if (!&supported_os($OS))
	      {
		print "!!!!!!!! $pg compilation failed, binary unsupported for $OS\n"; 
	      }
	    elsif (!($PG{$pg}{from_binary}=&install_binary_package ($pg)))
	      {
		print "!!!!!!!! $pg compilation and  binary installation failed\n";
	      }
	  }
	$PG{$pg}{new}=$return=&pg_is_installed ($pg,$BIN);
      }

    
    return $return;
  }
sub install_perl_package
  {
    my ($pg)=(@_);
    my ($report, $language, $compiler);
    
    $language=$PG{$pg} {language2};
    $compiler=$PG{$language}{compiler};
    
    if (!&pg_is_installed ($pg))
      {
	if ( $OS eq "windows"){`perl -M$compiler -e 'install $pg'`;}
	elsif ( $ROOT eq "sudo"){system ("sudo perl -M$compiler -e 'install $pg'");}
	else {system ("su root -c perl -M$compiler -e 'install $pg'");}
      }
    return &pg_is_installed ($pg);
  }



sub install_source_package
  {
    my ($pg)=(@_);
    my ($report, $download, $arguments, $language, $address, $name, $ext, $main_dir, $distrib);
    my $wget_tmp="$TMP/wget.tmp";
    my (@fl);
    if ( $default_update_action ne "update" && (-e "$BIN/$pg" || -e "$BIN/$pg.exe" )  ){return 1;}
    
    #
    # check if the module exists in the repository cache 
    #
	if( repo_load($pg) ) {
		return 1;
	}
    
    if ($pg eq "t_coffee")  {return   &install_t_coffee_source ($pg);}
    elsif ($pg eq "TMalign"){return   &install_TMalign ($pg);}
    
    chdir $DISTRIBUTIONS;
    
    $download=$PG{$pg}{source};
    
    if (($download =~/tgz/))
      {
	($address,$name,$ext)=($download=~/(.+\/)([^\/]+)(\.tgz).*/);
      }
    elsif (($download=~/tar\.gz/))
      {
	($address,$name,$ext)=($download=~/(.+\/)([^\/]+)(\.tar\.gz).*/);
      }
    elsif (($download=~/tar/))
      {
	($address,$name,$ext)=($download=~/(.+\/)([^\/]+)(\.tar).*/);
      }
    else
      {
	($address,$name)=($download=~/(.+\/)([^\/]+)/);
	$ext="";
      }
    $distrib="$name$ext";
    
    if ( !-d $pg){mkdir $pg;}
    chdir $pg;
   
    #get the distribution if available
    if ( -e "$DOWNLOAD_DIR/$distrib")
      {
	`$CP $DOWNLOAD_DIR/$distrib .`;
      }
    #UNTAR and Prepare everything
    if (!-e "$name.tar" && !-e "$name")
      {
	&check_rm ($wget_tmp);
	print "\n------- Downloading/Installing $pg\n";
	
	if (!-e $distrib && &url2file ("$download", "$wget_tmp")==$EXIT_SUCCESS)
	  {
	    
	    `mv $wget_tmp $distrib`;
	    `$CP $distrib $DOWNLOAD_DIR/`;
	  }

	if (!-e $distrib)
	  {
	    print "!!!!!!! Download of $pg distribution failed\n";
	    print "!!!!!!! Check Address: $PG{$pg}{source}\n";
	    return 0;
	  }
	print "\n------- unzipping/untaring $name\n";
	if (($ext =~/z/))
	  { 
	    &flush_command ("gunzip -f $name$ext");
	    
	  }
	if (($ext =~/tar/) || ($ext =~/tgz/))
	  {
	    &flush_command("tar -xvf $name.tar");
	  }
      }
    #Guess and enter the distribution directory
    @fl=ls($p);
    foreach my $f (@fl)
      {
	if (-d $f)
	  {
	    $main_dir=$f;
	  }
      }
    if (-d $main_dir)
	  
      {
	chdir $main_dir;}
    else
      {
	print "Error: $main_dir does not exist";
      }
    print "\n------- Compiling/Installing $pg\n";
    `make clean $SILENT`;
    
    
    #
    # SAP module
    #
    if ($pg eq "sap")
      {
	if (-e "./configure")
	  {
	    #new sap distribution
	    
	    &flush_command ("./configure");
	    &flush_command ("make clean");
	    &flush_command ("make");
	    &check_cp ("./src/$pg", "$BIN");
	    repo_store("./src/$pg");
	  }
	else
	  {
	    #old style distribution
	    `rm *.o sap  sap.exe ./util/aa/*.o  ./util/wt/.o $SILENT`;
	    &flush_command ("make $arguments sap");
	    &check_cp ($pg, "$BIN");
	    repo_store($pg);
	  }
      }
    
    #
    # CLUSTALW2 module
    #
    elsif ($pg eq "clustalw2")
      {
	&flush_command("./configure");
	&flush_command("make $arguments");
	&check_cp ("./src/$pg", "$BIN");
	repo_store("./src/$pg");
      }

    #
    # CLUSTAL-OMEGA module
    #
    elsif ($pg eq "clustalo")
      {
	&flush_command("./configure");
	&flush_command("make $arguments");
	&check_cp ("./src/$pg", "$BIN");
	repo_store("./src/$pg");
      }

    #
    # STRIKE module
    #
    elsif ($pg eq "strike")
      {
	&flush_command("make $arguments");
	&check_cp ("./bin/$pg", "$BIN");
	repo_store("./bin/$pg");
      }
    
    #
    # FSA module
    # 
    elsif ($pg eq "fsa")
      {
	&flush_command("./configure --prefix=$BIN");
	&flush_command("make $arguments");
	&flush_command ("make install");

	repo_store("fsa", "$BIN/bin");
	`mv $BIN/bin/* $BIN`;
	`rmdir $BIN/bin`;
      }
    
    #
    # CLUSTALW module
    #
    elsif ($pg eq "clustalw")
      {
	&flush_command("make $arguments clustalw");
	`$CP $pg $BIN $SILENT`;
	repo_store($pg);
      }
    
    #
    # MAFFT module
    #
    elsif ($pg eq "mafft")
      {
	my $base=cwd();
	my $c;
	
	#compile core
	mkpath ("./mafft/bin");
	mkpath ("./mafft/lib");
	chdir "$base/core";
	`make clean $SILENT`;
	&flush_command ("make $arguments");
	&flush_command ("make install LIBDIR=../mafft/lib BINDIR=../mafft/bin");
	
	#compile extension
	chdir "$base/extensions";
	`make clean $SILENT`;
	&flush_command ("make $arguments");
	&flush_command ("make install LIBDIR=../mafft/lib BINDIR=../mafft/bin");
	
	#put everything in mafft and copy the compiled stuff in bin
	chdir "$base";
	if ($ROOT_INSTALL)
	  {
	    &root_run ("You Must be Root to Install MAFFT\n", "mkdir /usr/local/mafft/;$CP mafft/lib/* /usr/local/mafft;$CP mafft/lib/mafft* /usr/local/bin ;$CP mafft/bin/mafft /usr/local/bin/; ");
	  }
	else
	  {
	    `$CP mafft/lib/*  $BIN`;
	    `$CP mafft/bin/mafft  $BIN`;
	  }
	`tar -cvf mafft.tar mafft`;
	`gzip mafft.tar`;
	`mv mafft.tar.gz $BIN`;
	
	repo_store("mafft/bin/mafft", "mafft/lib/", "$BIN/mafft.tar.gz");
      }
      
    #
    # DIALIGN-TX module
    #
    elsif ( $pg eq "dialign-tx" )
      {
	my $f;
	my $base=cwd();

	chdir "./source";
	if ($OS eq "macosx"){&flush_command ("cp makefile.MAC_OS makefile");}

	&flush_command (" make CPPFLAGS='-O3 -funroll-loops' all");
	
	chdir "..";
	&check_cp ("./source/$pg", "$BIN");
	repo_store("./source/$pg");
      }
      
    #
    # DIALIGN-T module 
    # (is the same as dialign-tx, but it is mantained for backward name compatibility with tcoffee)
    #
    elsif ( $pg eq "dialign-t" )
      {
	my $f;
	my $base=cwd();

	chdir "./source";
	if ($OS eq "macosx"){&flush_command ("cp makefile.MAC_OS makefile");}

	&flush_command (" make CPPFLAGS='-O3 -funroll-loops' all");
	
	chdir "..";
	&check_cp ("./source/dialign-tx", "$BIN/dialign-t");
	repo_store("$BIN/dialign-t");	
      }      
      
    #
    # POA module
    #
    elsif ($pg eq "poa")
      {
	&flush_command ("make $arguments poa");
	&check_cp ("$pg", "$BIN");
	repo_store("$pg");
      }
     
     
    #
    # PROBCONS module
    #
    elsif ( $pg eq "probcons")
      {
	&add_C_libraries("./ProbabilisticModel.h", "list", "cstring");
	
	`rm *.exe $SILENT`;
	&flush_command ("make $arguments probcons");
	&check_cp("$pg", "$BIN/$pg");
	repo_store("$pg");
      }
      
    #
    # PROBCONS RNA module
    #
    elsif ( $pg eq "probconsRNA")
      {
	&add_C_libraries("./ProbabilisticModel.h", "list", "cstring");
	&add_C_libraries("./Main.cc", "iomanip", "cstring","climits");
	`rm *.exe $SILENT`;
	&flush_command ("make $arguments probcons");
	&check_cp("probcons", "$BIN/$pg");
	repo_store("$BIN/$pg");
      }

	#
	# MUSCLE module
	#
    elsif (  $pg eq "muscle")
      {	
	`rm *.o muscle muscle.exe $SILENT`;
	if ($OS eq "macosx" || $OS eq "linux")
	  {
	    &replace_line_in_file ("./Makefile", "LDLIBS = -lm -static",  "LDLIBS = -lm");
	  }
	elsif ($OS eq "windows")
	  {
	    &replace_line_in_file ("./intmath.cpp",  "double log2e",      "double cedric_log");
	    &replace_line_in_file ("./intmath.cpp",  "double log2",       "double log_notuse");
	    &replace_line_in_file ("./intmath.cpp",  "double cedric_log", "double log2e");
	  }
	&flush_command ("make $arguments all");
	&check_cp("$pg", "$BIN");
	repo_store("$pg");	
      }
      
     #
     # MUS4 module
     #
     elsif (  $pg eq "mus4")
      {
	`rm *.o muscle muscle.exe $SILENT`;
	&flush_command ("./mk");
	&check_cp("$pg", "$BIN");
	repo_store("$pg");	
      }
      
    #
    # PCMA module
    #
    elsif ( $pg eq "pcma")
      {
	if ($OS eq "macosx")
	  {
	    &replace_line_in_file ("./alcomp2.c", "malloc.h",  "");
	  }
	&flush_command ("make $arguments pcma");
	&check_cp("$pg", "$BIN");
	repo_store("$pg");	
      }
      
    #
    # KALIGN module
    #
    elsif ($pg eq "kalign")
      {
	&flush_command ("./configure");
	&flush_command("make $arguments");
	&check_cp ("$pg",$BIN);
	repo_store("$pg");	
      }
      
    #
    # AMAP module
    #
    elsif ( $pg eq "amap")
      {
	&add_C_libraries("./Amap.cc", "iomanip", "cstring","climits");	
	`make clean $SILENT`;
	&flush_command ("make $arguments all");
	&check_cp ("$pg", $BIN);
	repo_store("$pg");	
      }
      
    #
    # PRODA module
    #
    elsif ( $pg eq "proda")
      {
	`sed -i '' 's/int errno = 0;/int errno; errno = 0;/' Main.cc`;
	&add_C_libraries("AlignedFragment.h", "vector", "iostream", "cstring","cstdlib");
	&add_C_libraries("Main.cc", "vector", "climits");	
	&add_C_libraries("Sequence.cc", "stdlib.h", "cstdio");	
	&flush_command ("make $arguments all");
	&check_cp ("$pg", $BIN);
	repo_store("$pg");	
      }
      
    #
    # PRANK module
    #
    elsif ( $pg eq "prank")
      {
	&flush_command ("make $arguments all");
	&check_cp ("$pg", $BIN);
	repo_store("$pg");	
      }
      
    #
    # !!!! MUSTANG module
    #
     elsif ( $pg eq "mustang")
      {
	&flush_command ("rm ./bin/*");
	&flush_command ("make $arguments all");

	if ( $OS=~/windows/){&flush_command("cp ./bin/* $BIN/mustang.exe");}
	else {&flush_command("cp ./bin/* $BIN/mustang");}
	
	repo_store("$BIN/mustang");
      }

	#
	# RNAplfold module
	#
    elsif ( $pg eq "RNAplfold")
      {
	&flush_command("./configure");
	&flush_command ("make $arguments all");
	&check_cp("./Progs/RNAplfold", "$BIN");
	&check_cp("./Progs/RNAalifold", "$BIN");
	&check_cp("./Progs/RNAfold", "$BIN");
	
	repo_store("./Progs/RNAplfold", "./Progs/RNAalifold", "./Progs/RNAfold");
      }
      
    #
    # !!! RETREE module
    #
    elsif ( $pg eq "retree")
      {
	chdir "src";
	&flush_command ("cp Makefile.unx Makefile");
	&flush_command ("make $arguments all");
	&flush_command ("make put");
	system "cp ../exe/* $BIN";
	
	repo_store("retree", "../exe");
      }
	
    chdir $CDIR;
    return &pg_is_installed ($pg, $BIN);
  }

sub install_t_coffee_source
  {
    my ($pg)=(@_);
    my ($report,$cflags, $arguments, $language, $compiler) ;

    #1-Install T-Coffee
    chdir "t_coffee_source";
    &flush_command ("make clean");
    print "\n------- Compiling T-Coffee\n";
    $language=$PG{$pg} {language2};
    $arguments=$PG{$language}{arguments};
    
    if ( $CC ne "")
      {
	print "make -i $arguments t_coffee \n";
	&flush_command ("make -i $arguments t_coffee");
      }
    &check_cp ($pg, $BIN);
    
    chdir $CDIR;
    return &pg_is_installed ($pg, $BIN);
  }
sub install_TMalign
  {
    my ($pg)=(@_);
    my $report;
    chdir "t_coffee_source";
    print "\n------- Compiling TMalign\n";
    `rm TMalign TMalign.exe $SILENT`;
    if ( $FC ne ""){&flush_command ("make -i $PG{Fortran}{arguments} TMalign");}
    &check_cp ($pg, $BIN);
    repo_store($pg);

    if ( !-e "$BIN/$pg" && pg_has_binary_distrib ($pg))
      {
	print "!!!!!!! Compilation of $pg impossible. Will try to install from binary\n";
	return &install_binary_package ($pg);
      }
    chdir $CDIR;
    return &pg_is_installed ($pg, $BIN);
  }

sub pg_has_binary_distrib
  {
    my ($pg)=(@_);
    if ($PG{$pg}{windows}){return 1;}
    elsif ($PG{$pg}{osx}){return 1;}
    elsif ($PG{$pg}{macosx}){return 1;}

    elsif ($PG{$pg}{linux}){return 1;}
    return 0;
  }
sub install_binary_package
  {
    my ($pg)=(@_);
    my ($base,$report,$name, $download, $arguments, $language, $dir);
    my $isdir;
    &input_os();
    
    #
    # - paolodt - Check if the module exists in the repository cache 
    #
	if( repo_load($pg) ) {
	    $PG{$pg}{from_binary}=1;
		return 1;
	}
    # - paolodt - end 
    
    if (!&supported_os($OS)){return 0;}
    if ( $PG{$pg}{binary}){$name=$PG{$pg}{binary};}
    else {$name=$pg;}
    if ($name eq "t_coffee")
      {
	#check if local bin is there
	if (-e "./bin/$OS/t_coffee")
	  {
	    print "\n------- Installing  T-Coffee from Pre-Compiled/Pre-Downloaded $OS binary\n";
	    print "\n------- If you want to trigger a fresh compilation use -recompile\n";
	    &check_cp ("./bin/$OS/t_coffee", $BIN);
	    return &pg_is_installed ($pg, $BIN);
	  }
	#try to get precompiled binary -- available from MAC is distribution from MAC
	else
	  {
	    $download="$WEB_BASE/Packages/Binaries/tcoffee/$OS/$name.$VERSION";
	  }
      }
    else
      {
	$download="$WEB_BASE/Packages/Binaries/plugins/$OS/$name";
      }
    
    $base=cwd();
    chdir $TMP;
    
    if (!-e $name)
      {
	`rm x $SILENT`;
	if ( url2file("$download","x")==$EXIT_SUCCESS)
	  {
	    `mv x $name`;
	  }
      }
    
    if (!-e $name)
      {
	print "!!!!!!! $PG{$pg}{dname}: Download of $pg binary failed\n";
	print "!!!!!!! $PG{$pg}{dname}: Check Address: $download\n";
	chdir $base;
	return 0;
      }
    print "\n------- Installing $pg\n";
    
    if ($name =~/tar\.gz/)
      {
	`gunzip  -f $name`;
	`tar -xvf $pg.tar`;
	chdir $pg;
	`chmod u+x *`;
 	`mv * $BIN`;
	#if (!($pg=~/\*/)){`rm -rf $pg`;}
      }
    else
      {
	&check_cp ("$pg", "$BIN");
	`chmod u+x $BIN/$pg`; 
	unlink ($pg);
      }
    chdir $base;
    $PG{$pg}{from_binary}=1;

    return &pg_is_installed ($pg, $BIN);
  }

	
sub add_dir
  {
    my $dir=@_[0];
    
    if (!-e $dir && !-d $dir)
      {
	my @l;
	umask (0000);
	@l=mkpath ($dir,{mode => 0777});
	
      }
    else
      {
	return 0;
      }
  }
sub check_rm 
  {
    my ($file)=(@_);
    
    if ( -e $file)
      {
	return unlink($file);
      }
    return 0;
  }
sub check_cp
  {
    my ($from, $to)=(@_);
    if ( !-e $from && -e "$from\.exe"){$from="$from\.exe";}
    if ( !-e $from){return 0;}
        
    `$CP $from $to`;
    return 1;
  }

sub repo_store 
{
   # check that all required data are available
   if( $REPO_ROOT eq "" ) { return; }


    # extract the package name from the specified path
    my $pg =`basename $_[0]`;
    chomp($pg);
	
    my $VER = $PG{$pg}{version};
    my $CACHE = "$REPO_ROOT/$pg/$VER/$OSNAME-$OSARCH"; 
    
    print "-------- Storing package: \"$pg\" to path: $CACHE\n";
    
    # clean the cache path if exists and create it again
    `rm -rf $CACHE`;
    `mkdir -p $CACHE`;
    
 	for my $path (@_) {

	    # check if it is a single file 
	 	if( -f $path ) {
	    	`cp $path $CACHE`;
		}
		# .. or a directory, in this case copy all the content 
		elsif( -d $path ) {
			opendir(IMD, $path);
			my @thefiles= readdir(IMD);
			closedir(IMD);
			
			for my $_file (@thefiles) {
				if( $_file ne "." && $_file ne "..") {
	    			`cp $path/$_file $CACHE`;
				}
			}
		} 
	}	   
    
	
}   

sub repo_load 
{
    my ($pg)=(@_);

    #Bypass the Repository Cache
    return 0;
    # check that all required data are available
    if( $REPO_ROOT eq "" ) { return 0; }

    my $VER = $PG{$pg}{version};
    my $CACHE = "$REPO_ROOT/$pg/$VER/$OSNAME-$OSARCH"; 
    if( !-e "$CACHE/$pg" ) {
   	 	print "-------- Module \"$pg\" NOT found on repository cache.\n";
    	return 0;
    }
    
    print "-------- Module \"$pg\" found on repository cache. Using copy on path: $CACHE\n";
    `cp $CACHE/* $BIN`;
    return 1;
}

sub check_file_list_exists 
  {
    my ($base, @flist)=(@_);
    my $f;

    foreach $f (@flist)
      {
	if ( !-e "$base/$f"){return 0;}
      }
    return 1;
  }
sub ls
  {
    my $f=@_[0];
    my @fl;
    chomp(@fl=`ls -1 $f`);
    return @fl;
  }
sub flush_command
  {
    my $command=@_[0];
    my $F=new FileHandle;
    open ($F, "$command|");
    while (<$F>){print "    --- $_";}
    close ($F);
  }    

sub input_installation_directory
  {
    my $dir=@_[0];
    my $new;
    
    print "------- The current installation directory is: [$dir]\n";
    print "??????? Return to keep the default or new value:";
   
    if ($NO_QUESTION==0)
      {
	chomp ($new=<stdin>);
	while ( $new ne "" && !input_yes ("You have entered $new. Is this correct? ([y]/n):"))
	  {
	    print "???????New installation directory:";
	    chomp ($new=<stdin>);
	  }
	$dir=($new eq "")?$dir:$new;
	$dir=~s/\/$//;
      }
    
    if ( -d $dir){return $dir;}
    elsif (&root_run ("You must be root to create $dir","mkdir $dir")==$EXIT_SUCCESS){return $dir;}
    else
      {
	print "!!!!!!! $dir could not be created\n";
	if ( $NO_QUESTION)
	  {
	    return "";
	  }
	elsif ( &input_yes ("??????? Do you want to provide a new directory([y]/n)?:"))
	  {
	    return input_installation_directory ($dir);
	  }
	else
	  {
	    return "";
	  }
      }
    
  }
sub input_yes
  {
    my $question =@_[0];
    my $answer;

    if ($NO_QUESTION==1){return 1;}
    
    if ($question eq ""){$question="??????? Do you wish to proceed ([y]/n)?:";}
    print $question;
    chomp($answer=lc(<STDIN>));
    if (($answer=~/^y/) || $answer eq ""){return 1;}
    elsif ( ($answer=~/^n/)){return 0;}
    else
      {
	return input_yes($question);
      }
  }
sub root_run
  {
    my ($txt, $cmd)=(@_);
    
    if ( system ($cmd)==$EXIT_SUCCESS){return $EXIT_SUCCESS;}
    else 
      {
	print "------- $txt\n";
	if ( $ROOT eq "sudo"){return system ("sudo $cmd");}
	else {return system ("su root -c \"$cmd\"");}
      }
  }
sub get_root
  {
    if (&pg_is_installed ("sudo")){return "sudo";}
    else {return "su";}
  }

sub get_os
  {
    my $raw_os=`uname`;
    my $os;

    $raw_os=lc ($raw_os);
    
    if ($raw_os =~/cygwin/){$os="windows";}
    elsif ($raw_os =~/linux/){$os="linux";}
    elsif ($raw_os =~/osx/){$os="macosx";}
    elsif ($raw_os =~/darwin/){$os="macosx";}
    else
      {
	$os=$raw_os;
      }
    return $os;
  }
sub input_os
  {
    my $answer;
    if ($OS) {return $OS;}
    
    print "??????? which os do you use: [w]indows, [l]inux, [m]acosx:?";
    $answer=lc(<STDIN>);

    if (($answer=~/^m/)){$OS="macosx";}
    elsif ( ($answer=~/^w/)){$OS="windows";}
    elsif ( ($answer=~/^linux/)){$OS="linux";}
    
    else
      {
	return &input_os();
      }
    return $OS;
  }

sub supported_os
  {
    my ($os)=(@_[0]);
    return $SUPPORTED_OS{$os};
  }

sub add2env_file
  {
    my ($env, $var, $value)=(@_);
    my $F = new FileHandle;
    my $t;
    if (!$value){return;}
    #make sure new variables do not get duplicated
    if ( -e $env)
      {
	open ($F, "$env");
	while (<$F>)
	  {
	    my $line=$_;
	    if (!($line=~/$var/)){$t.=$line;}
	  }
	close ($F);
      }
    $t.="$var=$value\n";
    open ($F, ">$env");
    print $F "$t";
    $ENV{$var}=$value;
    close ($F);
  }    
    


sub update_tclinkdb 
  {
    my $file =@_[0];
    my $name;
    my $F=new FileHandle;
    my ($download, $address, $name, $l, $db);
    
    if ( $file eq "update"){$file=$TCLINKDB_ADDRESS;}
    
    if ( $file =~/http:\/\// || $file =~/ftp:\/\//)
      {
	($address, $name)=($download=~/(.*)\/([^\/]+)$/);
	`rm x $SILENT`;
	if (&url2file ($file,"x")==$EXIT_SUCCESS)
	  {
	    print "------- Susscessful upload of $name";
	    `mv x $name`;
	    $file=$name;
	  }
      }
    open ($F, "$file");
    while (<$F>)
      {
	my $l=$_;
	if (($l =~/^\/\//) || ($db=~/^#/)){;}
	elsif ( !($l =~/\w/)){;}
	else
	  {
	    my @v=split (/\s+/, $l);
	    if ( $l=~/^MODE/)
	      {
		$MODE{$v[1]}{$v[2]}=$v[3];
	      }
	    elsif ($l=~/^PG/)
	      {
		$PG{$v[1]}{$v[2]}=$v[3];
	      }
	  }
      }
    close ($F);
    &post_process_PG();
    return;
  }



sub initialize_PG
  {

$PG{"t_coffee"}{"4_TCOFFEE"}="TCOFFEE";
$PG{"t_coffee"}{"type"}="sequence_multiple_aligner";
$PG{"t_coffee"}{"ADDRESS"}="http://www.tcoffee.org";
$PG{"t_coffee"}{"language"}="C++";
$PG{"t_coffee"}{"language2"}="CXX";
$PG{"t_coffee"}{"source"}="http://www.tcoffee.org/Packages/sources/tcoffee/stable/T-COFFEE_distribution.tar.gz";
$PG{"t_coffee"}{"update_action"}="always";
$PG{"t_coffee"}{"binary"}="t_coffee";
$PG{"t_coffee"}{"mode"}="tcoffee,mcoffee,rcoffee,expresso,3dcoffee";
$PG{"clustalo"}{"4_TCOFFEE"}="CLUSTALO";
$PG{"clustalo"}{"type"}="sequence_multiple_aligner";
$PG{"clustalo"}{"ADDRESS"}="http://www.clustal.org/omega/";
$PG{"clustalo"}{"language"}="C++";
$PG{"clustalo"}{"language2"}="C++";
$PG{"clustalo"}{"source"}="http://www.clustal.org/omega/clustal-omega-1.2.4.tar.gz";
$PG{"clustalo"}{"mode"}="mcoffee";
$PG{"clustalo"}{"binary"}="clustalo";
$PG{"clustalo"}{"version"}="1.2.4";
$PG{"strike"}{"4_TCOFFEE"}="STRIKE";
$PG{"strike"}{"type"}="sequence_alignment_scoring";
$PG{"strike"}{"ADDRESS"}="http://www.tcoffee.org/Projects/strike/index.html";
$PG{"strike"}{"language"}="C++";
$PG{"strike"}{"language2"}="CXX";
$PG{"strike"}{"source"}="http://www.tcoffee.org/Projects/strike/strike_v1.2.tar.bz2";
$PG{"strike"}{"mode"}="tcoffee,expresso";
$PG{"strike"}{"version"}="1.2";
$PG{"strike"}{"binary"}="strike";
$PG{"clustalw2"}{"4_TCOFFEE"}="CLUSTALW2";
$PG{"clustalw2"}{"type"}="sequence_multiple_aligner";
$PG{"clustalw2"}{"ADDRESS"}="http://www.clustal.org";
$PG{"clustalw2"}{"language"}="C++";
$PG{"clustalw2"}{"language2"}="CXX";
$PG{"clustalw2"}{"source"}="http://www.clustal.org/download/2.0.10/clustalw-2.0.10-src.tar.gz";
$PG{"clustalw2"}{"mode"}="mcoffee,rcoffee";
$PG{"clustalw2"}{"binary"}="clustalw2";
$PG{"clustalw2"}{"version"}="2.0.10";
$PG{"clustalw"}{"4_TCOFFEE"}="CLUSTALW";
$PG{"clustalw"}{"type"}="sequence_multiple_aligner";
$PG{"clustalw"}{"ADDRESS"}="http://www.clustal.org";
$PG{"clustalw"}{"language"}="C";
$PG{"clustalw"}{"language2"}="C";
$PG{"clustalw"}{"source"}="http://www.clustal.org/download/1.X/ftp-igbmc.u-strasbg.fr/pub/ClustalW/clustalw1.82.UNIX.tar.gz";
$PG{"clustalw"}{"mode"}="mcoffee,rcoffee";
$PG{"clustalw"}{"version"}="1.82";
$PG{"clustalw"}{"binary"}="clustalw";
$PG{"dialign-t"}{"4_TCOFFEE"}="DIALIGNT";
$PG{"dialign-t"}{"type"}="sequence_multiple_aligner";
$PG{"dialign-t"}{"ADDRESS"}="http://dialign-tx.gobics.de/";
$PG{"dialign-t"}{"DIR"}="/usr/share/dialign-tx/";
$PG{"dialign-t"}{"language"}="C";
$PG{"dialign-t"}{"language2"}="C";
$PG{"dialign-t"}{"source"}="http://dialign-tx.gobics.de/DIALIGN-TX_1.0.2.tar.gz";
$PG{"dialign-t"}{"mode"}="mcoffee";
$PG{"dialign-t"}{"binary"}="dialign-t";
$PG{"dialign-t"}{"version"}="1.0.2";
$PG{"dialign-tx"}{"4_TCOFFEE"}="DIALIGNTX";
$PG{"dialign-tx"}{"type"}="sequence_multiple_aligner";
$PG{"dialign-tx"}{"ADDRESS"}="http://dialign-tx.gobics.de/";
$PG{"dialign-tx"}{"DIR"}="/usr/share/dialign-tx/";
$PG{"dialign-tx"}{"language"}="C";
$PG{"dialign-tx"}{"language2"}="C";
$PG{"dialign-tx"}{"source"}="http://dialign-tx.gobics.de/DIALIGN-TX_1.0.2.tar.gz";
$PG{"dialign-tx"}{"mode"}="mcoffee";
$PG{"dialign-tx"}{"binary"}="dialign-tx";
$PG{"dialign-tx"}{"version"}="1.0.2";
$PG{"poa"}{"4_TCOFFEE"}="POA";
$PG{"poa"}{"type"}="sequence_multiple_aligner";
$PG{"poa"}{"ADDRESS"}="http://www.bioinformatics.ucla.edu/poa/";
$PG{"poa"}{"language"}="C";
$PG{"poa"}{"language2"}="C";
$PG{"poa"}{"source"}="http://downloads.sourceforge.net/poamsa/poaV2.tar.gz";
$PG{"poa"}{"DIR"}="/usr/share/";
$PG{"poa"}{"FILE1"}="blosum80.mat";
$PG{"poa"}{"mode"}="mcoffee";
$PG{"poa"}{"binary"}="poa";
$PG{"poa"}{"version"}="2.0";
$PG{"probcons"}{"4_TCOFFEE"}="PROBCONS";
$PG{"probcons"}{"type"}="sequence_multiple_aligner";
$PG{"probcons"}{"ADDRESS"}="http://probcons.stanford.edu/";
$PG{"probcons"}{"language2"}="CXX";
$PG{"probcons"}{"language"}="C++";
$PG{"probcons"}{"source"}="http://probcons.stanford.edu/probcons_v1_12.tar.gz";
$PG{"probcons"}{"mode"}="mcoffee";
$PG{"probcons"}{"binary"}="probcons";
$PG{"probcons"}{"version"}="1.12";
$PG{"msaprobs"}{"4_TCOFFEE"}="MSAPROBS";
$PG{"msaprobs"}{"type"}="sequence_multiple_aligner";
$PG{"msaprobs"}{"ADDRESS"}="http://msaprobs.sourceforge.net/homepage.htm#latest";
$PG{"msaprobs"}{"language2"}="CXX";
$PG{"msaprobs"}{"language"}="C++";
$PG{"msaprobs"}{"source"}="https://sourceforge.net/projects/msaprobs/files/MSAProbs-MPI/MSAProbs-MPI_rel1.0.5.tar.gz";
$PG{"msaprobs"}{"mode"}="mcoffee";
$PG{"msaprobs"}{"binary"}="msaprobs";
$PG{"msaprobs"}{"version"}="1.05";
$PG{"msaprobs"}{"update_action"}="never";
$PG{"upp"}{"4_TCOFFEE"}="UPP";
$PG{"upp"}{"type"}="sequence_multiple_aligner";
$PG{"upp"}{"ADDRESS"}="http://www.cs.utexas.edu/users/phylo/software/upp/";
$PG{"upp"}{"language2"}="CXX";
$PG{"upp"}{"language"}="C++";
$PG{"upp"}{"source"}="https://github.com/smirarab/pasta/archive/upp.zip";
$PG{"upp"}{"mode"}="mcoffee";
$PG{"upp"}{"binary"}="upp";
$PG{"upp"}{"version"}="1";
$PG{"upp"}{"update_action"}="never";
$PG{"mafft"}{"4_TCOFFEE"}="MAFFT";
$PG{"mafft"}{"type"}="sequence_multiple_aligner";
$PG{"mafft"}{"ADDRESS"}="http://align.bmr.kyushu-u.ac.jp/mafft/online/server/";
$PG{"mafft"}{"language"}="C";
$PG{"mafft"}{"language"}="C";
$PG{"mafft"}{"source"}="http://mafft.cbrc.jp/alignment/software/mafft-7.310-with-extensions-src.tgz";
$PG{"mafft"}{"mode"}="mcoffee,rcoffee";
$PG{"mafft"}{"binary"}="mafft.tar.gz";
$PG{"mafft"}{"version"}="7.310";
$PG{"msa"}{"4_TCOFFEE"}="MSA";
$PG{"msa"}{"type"}="sequence_multiple_aligner";
$PG{"msa"}{"ADDRESS"}="https://www.ncbi.nlm.nih.gov/CBBresearch/Schaffer/msa.html";
$PG{"msa"}{"language"}="C";
$PG{"msa"}{"language"}="C";
$PG{"msa"}{"source"}="ftp://ftp.ncbi.nih.gov/pub/msa/msa.tar.Z";
$PG{"msa"}{"mode"}="mcoffee";
$PG{"msa"}{"binary"}="msa.pl";
$PG{"msa"}{"version"}="1.0";
$PG{"msa"}{"update_action"}="never";
$PG{"dca"}{"4_TCOFFEE"}="DCA";
$PG{"dca"}{"type"}="sequence_multiple_aligner";
$PG{"dca"}{"ADDRESS"}="https://bibiserv2.cebitec.uni-bielefeld.de/dca";
$PG{"dca"}{"language"}="C";
$PG{"dca"}{"language"}="C";
$PG{"dca"}{"source"}="https://bibiserv2.cebitec.uni-bielefeld.de/applications/dca/resources/downloads/dca-1.1-src.tar.gz";
$PG{"dca"}{"mode"}="mcoffee";
$PG{"dca"}{"binary"}="dca.pl";
$PG{"dca"}{"version"}="1.1";
$PG{"dca"}{"update_action"}="never";
$PG{"muscle"}{"4_TCOFFEE"}="MUSCLE";
$PG{"muscle"}{"type"}="sequence_multiple_aligner";
$PG{"muscle"}{"ADDRESS"}="http://www.drive5.com/muscle/";
$PG{"muscle"}{"language"}="C++";
$PG{"muscle"}{"language2"}="GPP";
$PG{"muscle"}{"source"}="http://www.drive5.com/muscle/downloads3.7/muscle3.7_src.tar.gz";
$PG{"muscle"}{"windows"}="http://www.drive5.com/muscle/downloads3.7/muscle3.7_win32.zip";
$PG{"muscle"}{"linux"}="http://www.drive5.com/muscle/downloads3.7/muscle3.7_linux_ia32.tar.gz";
$PG{"muscle"}{"mode"}="mcoffee,rcoffee";
$PG{"muscle"}{"version"}="3.7";
$PG{"pcma"}{"4_TCOFFEE"}="PCMA";
$PG{"pcma"}{"type"}="sequence_multiple_aligner";
$PG{"pcma"}{"ADDRESS"}="http://prodata.swmed.edu/pcma/pcma.php";
$PG{"pcma"}{"language"}="C";
$PG{"pcma"}{"language2"}="C";
$PG{"pcma"}{"source"}="http://prodata.swmed.edu/download/pub/PCMA/pcma.tar.gz";
$PG{"pcma"}{"mode"}="mcoffee";
$PG{"pcma"}{"version"}="1.0";
$PG{"kalign"}{"4_TCOFFEE"}="KALIGN";
$PG{"kalign"}{"type"}="sequence_multiple_aligner";
$PG{"kalign"}{"ADDRESS"}="http://msa.cgb.ki.se";
$PG{"kalign"}{"language"}="C";
$PG{"kalign"}{"language2"}="C";
$PG{"kalign"}{"source"}="http://msa.cgb.ki.se/downloads/kalign/current.tar.gz";
$PG{"kalign"}{"mode"}="mcoffee";
$PG{"kalign"}{"version"}="1.0";
$PG{"amap"}{"4_TCOFFEE"}="AMAP";
$PG{"amap"}{"type"}="sequence_multiple_aligner";
$PG{"amap"}{"ADDRESS"}="http://bio.math.berkeley.edu/amap/";
$PG{"amap"}{"language"}="C++";
$PG{"amap"}{"language2"}="CXX";
$PG{"amap"}{"source"}="https://github.com/mes5k/amap-align/archive/amap.zip";
$PG{"amap"}{"mode"}="mcoffee";
$PG{"amap"}{"version"}="2.0";
$PG{"amap"}{"update_action"}="never";
$PG{"proda"}{"4_TCOFFEE"}="PRODA";
$PG{"proda"}{"type"}="sequence_multiple_aligner";
$PG{"proda"}{"ADDRESS"}="http://proda.stanford.edu";
$PG{"proda"}{"language"}="C++";
$PG{"proda"}{"language2"}="CXX";
$PG{"proda"}{"source"}="http://proda.stanford.edu/proda_1_0.tar.gz";
$PG{"proda"}{"mode"}="mcoffee";
$PG{"proda"}{"version"}="1.0";
$PG{"prank"}{"4_TCOFFEE"}="PRANK";
$PG{"prank"}{"type"}="sequence_multiple_aligner";
$PG{"prank"}{"ADDRESS"}="http://www.ebi.ac.uk/goldman-srv/prank/";
$PG{"prank"}{"language"}="C++";
$PG{"prank"}{"language2"}="CXX";
$PG{"prank"}{"source"}="http://www.ebi.ac.uk/goldman-srv/prank/src/prank/prank.src.100802.tgz";
$PG{"prank"}{"mode"}="mcoffee";
$PG{"prank"}{"version"}="100303";
$PG{"sap"}{"4_TCOFFEE"}="SAP";
$PG{"sap"}{"type"}="structure_pairwise_aligner";
$PG{"sap"}{"ADDRESS"}="https://mathbio.crick.ac.uk/wiki/Software#SAP";
$PG{"sap"}{"language"}="C";
$PG{"sap"}{"language2"}="C";
$PG{"sap"}{"source"}="https://github.com/jkleinj/SAP/archive/v.1.1.3.tar.gz";
$PG{"sap"}{"mode"}="expresso,3dcoffee";
$PG{"sap"}{"version"}="1.1.3";
$PG{"sap"}{"binary"}="sap";
$PG{"TMalign"}{"4_TCOFFEE"}="TMALIGN";
$PG{"TMalign"}{"type"}="structure_pairwise_aligner";
$PG{"TMalign"}{"ADDRESS"}="http://zhanglab.ccmb.med.umich.edu/TM-align/TMalign.f";
$PG{"TMalign"}{"language"}="Fortran";
$PG{"TMalign"}{"language2"}="Fortran";
$PG{"TMalign"}{"source"}="http://zhanglab.ccmb.med.umich.edu/TM-align/TMalign.f";
$PG{"TMalign"}{"linux"}="http://zhanglab.ccmb.med.umich.edu/TM-align/TMalign_32.gz";
$PG{"TMalign"}{"mode"}="expresso,3dcoffee";
$PG{"TMalign"}{"version"}="2013.05.11";
$PG{"mustang"}{"4_TCOFFEE"}="MUSTANG";
$PG{"mustang"}{"type"}="structure_pairwise_aligner";
$PG{"mustang"}{"ADDRESS"}="http://lcb.infotech.monash.edu.au/mustang/";
$PG{"mustang"}{"language"}="C++";
$PG{"mustang"}{"language2"}="CXX";
$PG{"mustang"}{"source"}="http://lcb.infotech.monash.edu.au/mustang/mustang_v3.2.3.tgz";
$PG{"mustang"}{"mode"}="expresso,3dcoffee";
$PG{"mustang"}{"version"}="3.2.3";
$PG{"lsqman"}{"4_TCOFFEE"}="LSQMAN";
$PG{"lsqman"}{"type"}="structure_pairwise_aligner";
$PG{"lsqman"}{"ADDRESS"}="empty";
$PG{"lsqman"}{"language"}="empty";
$PG{"lsqman"}{"language2"}="empty";
$PG{"lsqman"}{"source"}="empty";
$PG{"lsqman"}{"update_action"}="never";
$PG{"lsqman"}{"mode"}="expresso,3dcoffee";
$PG{"align_pdb"}{"4_TCOFFEE"}="ALIGN_PDB";
$PG{"align_pdb"}{"type"}="structure_pairwise_aligner";
$PG{"align_pdb"}{"ADDRESS"}="empty";
$PG{"align_pdb"}{"language"}="empty";
$PG{"align_pdb"}{"language2"}="empty";
$PG{"align_pdb"}{"source"}="empty";
$PG{"align_pdb"}{"update_action"}="never";
$PG{"align_pdb"}{"mode"}="expresso,3dcoffee";
$PG{"fugueali"}{"4_TCOFFEE"}="FUGUE";
$PG{"fugueali"}{"type"}="structure_pairwise_aligner";
$PG{"fugueali"}{"ADDRESS"}="http://mizuguchilab.org/fugue/";
$PG{"fugueali"}{"language"}="empty";
$PG{"fugueali"}{"language2"}="empty";
$PG{"fugueali"}{"source"}="empty";
$PG{"fugueali"}{"update_action"}="never";
$PG{"fugueali"}{"mode"}="expresso,3dcoffee";
$PG{"dalilite.pl"}{"4_TCOFFEE"}="DALILITEc";
$PG{"dalilite.pl"}{"type"}="structure_pairwise_aligner";
$PG{"dalilite.pl"}{"ADDRESS"}="built_in";
$PG{"dalilite.pl"}{"ADDRESS2"}="http://www.ebi.ac.uk/Tools/webservices/services/dalilite";
$PG{"dalilite.pl"}{"language"}="Perl";
$PG{"dalilite.pl"}{"language2"}="Perl";
$PG{"dalilite.pl"}{"source"}="empty";
$PG{"dalilite.pl"}{"update_action"}="never";
$PG{"dalilite.pl"}{"mode"}="expresso,3dcoffee";
$PG{"probconsRNA"}{"4_TCOFFEE"}="PROBCONSRNA";
$PG{"probconsRNA"}{"type"}="RNA_multiple_aligner";
$PG{"probconsRNA"}{"ADDRESS"}="http://probcons.stanford.edu/";
$PG{"probconsRNA"}{"language"}="C++";
$PG{"probconsRNA"}{"language2"}="CXX";
$PG{"probconsRNA"}{"source"}="http://probcons.stanford.edu/probconsRNA.tar.gz";
$PG{"probconsRNA"}{"mode"}="mcoffee,rcoffee";
$PG{"probconsRNA"}{"version"}="1.0";
$PG{"sfold"}{"4_TCOFFEE"}="CONSAN";
$PG{"sfold"}{"type"}="RNA_pairwise_aligner";
$PG{"sfold"}{"ADDRESS"}="http://selab.janelia.org/software/consan/";
$PG{"sfold"}{"language"}="empty";
$PG{"sfold"}{"language2"}="empty";
$PG{"sfold"}{"source"}="empty";
$PG{"sfold"}{"update_action"}="never";
$PG{"sfold"}{"mode"}="rcoffee";
$PG{"RNAplfold"}{"4_TCOFFEE"}="RNAPLFOLD";
$PG{"RNAplfold"}{"type"}="RNA_secondarystructure_predictor";
$PG{"RNAplfold"}{"ADDRESS"}="http://www.tbi.univie.ac.at/RNA/";
$PG{"RNAplfold"}{"language"}="C";
$PG{"RNAplfold"}{"language2"}="C";
$PG{"RNAplfold"}{"source"}="http://www.tbi.univie.ac.at/RNA/packages/source/ViennaRNA-2.1.9.tar.gz";
$PG{"RNAplfold"}{"mode"}="rcoffee,";
$PG{"RNAplfold"}{"binary"}="RNAplfold.tar.gz";
$PG{"RNAplfold"}{"version"}="2.1.9";
$PG{"retree"}{"4_TCOFFEE"}="PHYLIP";
$PG{"retree"}{"type"}="Phylogeny";
$PG{"retree"}{"ADDRESS"}="http://evolution.gs.washington.edu/phylip/";
$PG{"retree"}{"language"}="C";
$PG{"retree"}{"language2"}="C";
$PG{"retree"}{"source"}="http://www.tcoffee.org/Packages/mirrors/source/phylip-3.66.tar.gz";
$PG{"retree"}{"mode"}="trmsd,";
$PG{"retree"}{"binary"}="retree.tar.gz";
$PG{"retree"}{"version"}="3.66";
$PG{"hmmtop"}{"4_TCOFFEE"}="HMMTOP";
$PG{"hmmtop"}{"type"}="protein_secondarystructure_predictor";
$PG{"hmmtop"}{"ADDRESS"}="www.enzim.hu/hmmtop/";
$PG{"hmmtop"}{"language"}="C";
$PG{"hmmtop"}{"language2"}="C";
$PG{"hmmtop"}{"source"}="http://www.tcoffee.org/Packages/mirrors/hmmtop2.1.tgz";
$PG{"hmmtop"}{"binary"}="hmmtop";
$PG{"hmmtop"}{"update_action"}="never";
$PG{"hmmtop"}{"mode"}="psicoffee";
$PG{"hmmtop"}{"version"}="2.1";
$PG{"gorIV"}{"4_TCOFFEE"}="GOR4";
$PG{"gorIV"}{"type"}="protein_secondarystructure_predictor";
$PG{"gorIV"}{"ADDRESS"}="http://mig.jouy.inra.fr/logiciels/gorIV/";
$PG{"gorIV"}{"language"}="C";
$PG{"gorIV"}{"language2"}="C";
$PG{"gorIV"}{"source"}="http://www.tcoffee.org/Packages/mirrors/GOR_IV.tar.gz";
$PG{"gorIV"}{"update_action"}="never";
$PG{"gorIV"}{"mode"}="tcoffee";
$PG{"wublast.pl"}{"4_TCOFFEE"}="EBIWUBLASTc";
$PG{"wublast.pl"}{"type"}="protein_homology_predictor";
$PG{"wublast.pl"}{"ADDRESS"}="built_in";
$PG{"wublast.pl"}{"ADDRESS2"}="http://www.ebi.ac.uk/Tools/webservices/services/wublast";
$PG{"wublast.pl"}{"language"}="Perl";
$PG{"wublast.pl"}{"language2"}="Perl";
$PG{"wublast.pl"}{"source"}="empty";
$PG{"wublast.pl"}{"update_action"}="never";
$PG{"wublast.pl"}{"mode"}="psicoffee,expresso,accurate";
$PG{"blastpgp.pl"}{"4_TCOFFEE"}="EBIBLASTPGPc";
$PG{"blastpgp.pl"}{"type"}="protein_homology_predictor";
$PG{"blastpgp.pl"}{"ADDRESS"}="built_in";
$PG{"blastpgp.pl"}{"ADDRESS2"}="http://www.ebi.ac.uk/Tools/webservices/services/blastpgp";
$PG{"blastpgp.pl"}{"language"}="Perl";
$PG{"blastpgp.pl"}{"language2"}="Perl";
$PG{"blastpgp.pl"}{"source"}="empty";
$PG{"blastpgp.pl"}{"update_action"}="never";
$PG{"blastpgp.pl"}{"mode"}="psicoffee,expresso,accurate";
$PG{"blastall"}{"4_TCOFFEE"}="blastall";
$PG{"blastall"}{"type"}="protein_homology_predictor";
$PG{"blastall"}{"ADDRESS"}="ftp://ftp.ncbi.nih.gov/blast/executables/LATEST";
$PG{"blastall"}{"language"}="C";
$PG{"blastall"}{"language2"}="C";
$PG{"blastall"}{"source"}="ftp://ftp.ncbi.nlm.nih.gov/blast/executables/blast+/2.6.0/ncbi-blast-2.6.0+-src.tar.gz";
$PG{"blastall"}{"update_action"}="never";
$PG{"blastall"}{"mode"}="psicoffee,expresso,3dcoffee";
$PG{"legacy_blast.pl"}{"4_TCOFFEE"}="NCBIBLAST";
$PG{"legacy_blast.pl"}{"type"}="protein_homology_predictor";
$PG{"legacy_blast.pl"}{"ADDRESS"}="ftp://ftp.ncbi.nih.gov/blast/executables/LATEST";
$PG{"legacy_blast.pl"}{"language"}="C";
$PG{"legacy_blast.pl"}{"language2"}="C";
$PG{"legacy_blast.pl"}{"source"}="ftp://ftp.ncbi.nlm.nih.gov/blast/executables/blast+/2.6.0/ncbi-blast-2.6.0+-src.tar.gz";
$PG{"legacy_blast.pl"}{"update_action"}="never";
$PG{"legacy_blast.pl"}{"mode"}="psicoffee,expresso,3dcoffee";
$PG{"SOAP::Lite"}{"4_TCOFFEE"}="SOAPLITE";
$PG{"SOAP::Lite"}{"type"}="library";
$PG{"SOAP::Lite"}{"ADDRESS"}="http://cpansearch.perl.org/src/MKUTTER/SOAP-Lite-0.710.08/Makefile.PL";
$PG{"SOAP::Lite"}{"language"}="Perl";
$PG{"SOAP::Lite"}{"language2"}="Perl";
$PG{"SOAP::Lite"}{"source"}="empty";
$PG{"SOAP::Lite"}{"update_action"}="never";
$PG{"SOAP::Lite"}{"mode"}="none";
$PG{"XML::Simple"}{"4_TCOFFEE"}="XMLSIMPLE";
$PG{"XML::Simple"}{"type"}="library";
$PG{"XML::Simple"}{"ADDRESS"}="http://search.cpan.org/~grantm/XML-Simple-2.18/lib/XML/Simple.pm";
$PG{"XML::Simple"}{"language"}="Perl";
$PG{"XML::Simple"}{"language2"}="Perl";
$PG{"XML::Simple"}{"source"}="empty";
$PG{"XML::Simple"}{"mode"}="psicoffee,expresso,accurate";
$PG{"x3dna"}{"4_TCOFFEE"}="x3dna";
$PG{"x3dna"}{"type"}="RNA_secondarystructure_predictor";
$PG{"x3dna"}{"ADDRESS"}="http://x3dna.bio.columbia.edu/";
$PG{"x3dna"}{"source"}="http://www.tcoffee.org/Packages/mirrors/source/x3dna-v2.3-linux-64bit.tar.gz";
$PG{"x3dna"}{"mode"}="saracoffee";
$PG{"x3dna"}{"update_action"}="never";
$PG{"fsa"}{"4_TCOFFEE"}="FSA";
$PG{"fsa"}{"type"}="sequence_multiple_aligner";
$PG{"fsa"}{"ADDRESS"}="http://fsa.sourceforge.net/";
$PG{"fsa"}{"language"}="C++";
$PG{"fsa"}{"language2"}="CXX";
$PG{"fsa"}{"source"}="http://sourceforge.net/projects/fsa/files/fsa-1.15.3.tar.gz/download/";
$PG{"fsa"}{"mode"}="mcoffee";
$PG{"fsa"}{"version"}="1.15.3";
$PG{"fsa"}{"update_action"}="never";
$PG{"mus4"}{"4_TCOFFEE"}="MUS4";
$PG{"mus4"}{"type"}="sequence_multiple_aligner";
$PG{"mus4"}{"ADDRESS"}="http://www.drive5.com/muscle/";
$PG{"mus4"}{"language"}="C++";
$PG{"mus4"}{"language2"}="GPP";
$PG{"mus4"}{"source"}="http://www.drive5.com/muscle/muscle4.0_src.tar.gz";
$PG{"mus4"}{"mode"}="mcoffee,rcoffee";
$PG{"mus4"}{"version"}="4.0";
$PG{"mus4"}{"update_action"}="never";
$MODE{"tcoffee"}{"name"}="tcoffee";
$MODE{"rcoffee"}{"name"}="rcoffee";
$MODE{"3dcoffee"}{"name"}="3dcoffee";
$MODE{"mcoffee"}{"name"}="mcoffee";
$MODE{"expresso"}{"name"}="expresso";
$MODE{"trmsd"}{"name"}="trmsd";
$MODE{"accurate"}{"name"}="accurate";
$MODE{"seq_reformat"}{"name"}="seq_reformat";


$PG{C}{compiler}="gcc";
$PG{C}{compiler_flag}="CC";
$PG{C}{options}="";
$PG{C}{options_flag}="CFLAGS";
$PG{C}{type}="compiler";

$PG{"CXX"}{compiler}="g++";
$PG{"CXX"}{compiler_flag}="CXX";
$PG{"CXX"}{options}="";
$PG{"CXX"}{options_flag}="CXXFLAGS";
$PG{CXX}{type}="compiler";

$PG{"CPP"}{compiler}="g++";
$PG{"CPP"}{compiler_flag}="CPP";
$PG{"CPP"}{options}="";
$PG{"CPP"}{options_flag}="CPPFLAGS";
$PG{CPP}{type}="compiler";

$PG{"GPP"}{compiler}="g++";
$PG{"GPP"}{compiler_flag}="GPP";
$PG{"GPP"}{options}="";
$PG{"GPP"}{options_flag}="CFLAGS";
$PG{GPP}{type}="compiler";

$PG{Fortran}{compiler}="g77";
$PG{Fortran}{compiler_flag}="FCC";
$PG{Fortran}{type}="compiler";

$PG{Perl}{compiler}="CPAN";
$PG{Perl}{type}="compiler";

$SUPPORTED_OS{macosx}="Macintosh";
$SUPPORTED_OS{linux}="Linux";
$SUPPORTED_OS{windows}="Cygwin";



$MODE{t_coffee}{description}=" for regular multiple sequence alignments";
$MODE{rcoffee} {description}=" for RNA multiple sequence alignments";

$MODE{psicoffee} {description}=" for Homology Extended multiple sequence alignments";
$MODE{expresso}{description}=" for very accurate structure based multiple sequence alignments";
$MODE{"3dcoffee"}{description}=" for multiple structure alignments";
$MODE{mcoffee} {description}=" for combining alternative multiple sequence alignment packages\n------- into a unique meta-package. The installer will upload several MSA packages and compile them\n
";


&post_process_PG();
return;
}

sub post_process_PG
  {
    my $p;
    
    %PG=&name2dname (%PG);
    %MODE=&name2dname(%MODE);
    foreach $p (keys(%PG)){if ( $PG{$p}{type} eq "compiler"){$PG{$p}{update_action}="never";}}
    
  }

sub name2dname
  {
    my (%L)=(@_);
    my ($l, $ml);
    
    foreach my $pg (keys(%L))
      {
	$l=length ($pg);
	if ( $l>$ml){$ml=$l;}
      }
    $ml+=1;
    foreach my $pg (keys(%L))
      {
	my $name;
	$l=$ml-length ($pg);
	$name=$pg;
	for ( $b=0; $b<$l; $b++)
	  {
	    $name .=" ";
	  }
	$L{$pg}{dname}=$name;
      }
    return %L;
  }

sub env_file2putenv
  {
    my $f=@_[0];
    my $F=new FileHandle;
    my $n;
    
    open ($F, "$f");
    while (<$F>)
      {
	my $line=$_;
	my($var, $value)=($_=~/(\S+)\=(\S*)/);
	$ENV{$var}=$value;
	$ENV_SET{$var}=1;
	$n++;
      }
    close ($F);
    return $n;
  }

sub replace_line_in_file
  {
    my ($file, $wordin, $wordout)=@_;
    my $O=new FileHandle;
    my $I=new FileHandle;
    my $l;
    if (!-e $file){return;}
    
    system ("mv $file $file.old");
    open ($O, ">$file");
    open ($I, "$file.old");
    while (<$I>)
      {
	$l=$_;
	if (!($l=~/$wordin/)){print $O "$l";}
	elsif ( $wordout ne ""){$l=~s/$wordin/$wordout/g;print $O "$l";}
      }
    close ($O);
    close ($I);
    return;
  }

sub add_C_libraries
  {
   my ($file,$first,@list)=@_;
   
    my $O=new FileHandle;
    my $I=new FileHandle;
    my ($l,$anchor);
    if (!-e $file){return;}
   
    $anchor="#include <$first>";
	 
    system ("mv $file $file.old");
    open ($O, ">$file");
    open ($I, "$file.old");
    while (<$I>)
      {
	$l=$_;
	print $O "$l";
	if (!($l=~/$anchor/))
	   {
	    
	    foreach my $lib (@list)
	       {
                  print $O "#include <$lib>\n";
	       }
           }
      }
    close ($O);
    close ($I);
    return;
    }

</content>
</file>
<file>
<stream>output</stream>
<name>clean_cache.pl</name>
<content>#!/usr/bin/env perl
use Env;
use Cwd;
@suffix=("tmp", "temp", "cache", "t_coffee", "core", "tcoffee");

if ($#ARGV==-1)
  {
    print "clean_cache.pl -file <file to add in -dir> -dir=<dir> -size=<value in Mb>\n0: unlimited -1 always.\nWill only clean directories matching:[";
    foreach $k(@suffix){print "*$k* ";}
    print "]\n";
    exit (EXIT_FAILURE);
  }

$cl=join (" ",@ARGV);
if (($cl=~/\-no_action/))
  {
    exit (EXIT_SUCCESS);
  }

if (($cl=~/\-debug/))
  {
    $DEBUG=1;
  }
else
  {
    $DEBUG=0;
  }

if (($cl=~/\-dir=(\S+)/))
  {
    $dir=$1;
  }
else
  {
    $dir="./";
  }

if ($cl=~/\-file=(\S+)/)
  {
    $file=$1;
  }
else
  {
    $file=0;
  }

if ($cl=~/\-size=(\S+)/)
  {
    $max_size=$1;
  }
else
  {
    $max_size=0;#unlimited
  }
if ($cl=~/\-force/)
  {
    $force=1;
  }
else
  {
    $force=0;
  }

if ($cl=~/\-age=(\S+)/)
  {
    $max_age=$1;
  }
else
  {
    $max_age=0;#unlimited
  }

$max_size*=1000000;
if ( ! -d $dir)
  {
    print STDERR "\nCannot process $dir: does not exist \n";
    exit (EXIT_FAILURE);
  }

if ( !($dir=~/^\//))
  {
    $base=cwd();
    $dir="$base/$dir";
  }

$proceed=0;
foreach $s (@suffix)
  {
    
    if (($dir=~/$s/)){$proceed=1;}
    $s=uc ($s);
    if (($dir=~/$s/)){$proceed=1;}
  }
if ( $proceed==0)
  {
    print STDERR "Clean_cache.pl can only clean directories whose absolute path name contains the following strings:";
    foreach $w (@suffix) {print STDERR "$w ";$w=lc($w); print STDERR "$w ";}
    print STDERR "\nCannot process $dir\n";
    exit (EXIT_FAILURE);
  }

$name_file="$dir/name_file.txt";
$size_file="$dir/size_file.txt";
if ( $force){&create_ref_file ($dir,$name_file,$size_file);}
if ($file){&add_file ($dir, $name_file, $size_file, $file);}
&clean_dir ($dir, $name_file, $size_file, $max_size,$max_age);
exit (EXIT_SUCCESS);

sub clean_dir 
  {
    my ($dir, $name_file, $size_file, $max_size, $max_age)=@_;
    my ($tot_size, $size, $f, $s);

  
    $tot_size=&get_tot_size ($dir, $name_file, $size_file);

    if ( $tot_size<=$max_size){return ;}
    else {$max_size/=2;}
    
    #recreate the name file in case some temprary files have not been properly registered
    &create_ref_file ($dir, $name_file, $size_file, $max_age);
  
    $new_name_file=&vtmpnam();
    open (R, "$name_file");
    open (W, ">$new_name_file");
    while (<R>)
      {
	my $line=$_;
	
	($f, $s)=($line=~/(\S+) (\S+)/);
	if ( !($f=~/\S/)){next;}
	
	elsif ($max_size && $tot_size>=$max_size && !($f=~/name_file/))
	  {
	    remove ( "$dir/$f");
	    $tot_size-=$s;
	  }
	elsif ( $max_age && -M("$dir/$f")>=$max_age)
	  {
	    remove ( "$dir/$f");
	    $tot_size-=$s;
	  }
	else
	  {
	    print W "$f $s\n";
	  }
      }
    close (R);
    close (W);
    open (F, ">$size_file");
    print F "$tot_size";
    if ( -e $new_name_file){`mv $new_name_file $name_file`;}
    close (F);
  }
sub get_tot_size
  {
    my ($dir, $name_file, $size_file)=@_;
    my $size;
    
    if ( !-d $dir){return 0;}
    if ( !-e $name_file)
      {
	
	&create_ref_file ($dir, $name_file, $size_file);
      }
    open (F, "$size_file");
    $size=<F>;
    close (F);
    chomp ($size);
    return $size;
  }
sub size 
  {
    my $f=@_[0];

    if ( !-d $f){return -s($f);}
    else {return &dir2size($f);}
  }
sub dir2size
  {
    my $d=@_[0];
    my ($s, $f);
    
    if ( !-d $d) {return 0;}
    
    foreach $f (&dir2list ($d))
      {
	if ( -d $f){$s+=&dir2size ("$d/$f");}
	else {$s+= -s "$dir/$f";}
      }
    return $s;
  }

sub remove 
  {
    my $file=@_[0];
    my ($f);
    
    debug_print( "--- $file ---\n");
    if (($file eq ".") || ($file eq "..") || ($file=~/\*/)){return EXIT_FAILURE;}
    elsif ( !-d $file)
      {
	debug_print ("unlink $file\n");
	if (-e $file){unlink ($file);}
      }
    elsif ( -d $file)
      {
	debug_print ("++++++++ $file +++++++\n");
	foreach $f (&dir2list($file))
	  {
	    &remove ("$file/$f");
	  }
	debug_print ("rmdir $file\n");
	rmdir $file;
      }
    else
      {
	debug_print ("????????? $file ????????\n");
      }
    return EXIT_SUCCESS;
  }

sub dir2list
  {
    my $dir=@_[0];
    my (@list1, @list2,@list3, $l);

    opendir (DIR,$dir);
    @list1=readdir (DIR);
    closedir (DIR);
    
    foreach $l (@list1)
      {
	if ( $l ne "." && $l ne ".."){@list2=(@list2, $l);}
      }
    @list3 = sort { (-M "$dir/$list2[$b]") <=> (-M "$dir/$list2[$a]")} @list2;
    return @list3;
    
  }

sub debug_print
  {
    
    if ($DEBUG==1){print @_;}
    
  }
sub create_ref_file
  {
    my ($dir,$name_file,$size_file)=@_;
    my ($f, $s, $tot_size, @l);
    
    if ( !-d $dir){return;}
    
    @l=&dir2list ($dir);
    open (F, ">$name_file");
    foreach $f (@l)
      {
	$s=&size("$dir/$f");
	$tot_size+=$s;
	print F "$f $s\n";
      }
    &myecho ($tot_size, ">$size_file");
    close (F);
  }
sub add_file 
  {
    my ($dir,$name_file,$size_file,$file)=@_;
    my ($s, $tot_size);
    
    if ( !-d $dir)   {return;}
    if ( !-e "$dir/$file" ) {return;}
    if ( !-e $name_file){&create_ref_file ($dir,$name_file,$size_file);}
					    
    $s=&size("$dir/$file");
    open (F, ">>$name_file");
    print F "$file\n";
    close (F);

    $tot_size=&get_tot_size ($dir,$name_file,$size_file);
    $tot_size+=$s;
    &myecho ($tot_size, ">$size_file");
    
  }
	
sub myecho
  {
    my ($string, $file)=@_;
    open (ECHO, $file) || die;
    print ECHO "$string";
    close (ECHO);
  }
    
		
	
sub vtmpnam
  {
    my $tmp_file_name;
    $tmp_name_counter++;
    $tmp_file_name="tmp_file_for_clean_cache_pdb$$.$tmp_name_counter";
    $tmp_file_list[$ntmp_file++]=$tmp_file_name;
    if ( -e $tmp_file_name) {return &vtmpnam ();}
    else {return $tmp_file_name;}
  }

</content>
</file>
<file>
<stream>output</stream>
<name>nature_protocol.pl</name>
<content>#!/usr/bin/env perl

my $address="http://www.tcoffee.org/Data/Datasets/NatureProtocolsDataset.tar.gz";
my $out="NatureProtocolsDataset.tar.gz";
&url2file ($address,$out);

if ( -e $out)
  {
    
    system ("gunzip NatureProtocolsDataset.tar.gz");
    system ("tar -xvf NatureProtocolsDataset.tar");
  	system ("rm -rf NatureProtocolsDataset.tar");  
    print "Your Data Set is in the Folder 'NatureProtocolsDataset'\n";
  }
else 
  {
    print "Could not Download Dataset --- Web site may be down -- Try again later\n";
  }




sub url2file
{
    my ($address, $out, $wget_arg, $curl_arg)=(@_);
    my ($pg, $flag, $r, $arg, $count);
    
    if (!$CONFIGURATION){&check_configuration ("wget", "INTERNET", "gzip");$CONFIGURATION=1;}
    
    if (&pg_is_installed ("wget"))   {$pg="wget"; $flag="-O";$arg=$wget_arg;}
    elsif (&pg_is_installed ("curl")){$pg="curl"; $flag="-o";$arg=$curl_arg;}
    return system ("$pg $address $flag $out>/dev/null 2>/dev/null");

}

sub pg_is_installed
  {
    my @ml=@_;
    my $r, $p, $m;
    my $supported=0;
    
    my $p=shift (@ml);
    if ($p=~/::/)
      {
	if (system ("perl -M$p -e 1")==$EXIT_SUCCESS){return 1;}
	else {return 0;}
      }
    else
      {
	$r=`which $p 2>/dev/null`;
	if ($r eq ""){return 0;}
	else {return 1;}
      }
  }
sub check_configuration 
    {
      my @l=@_;
      my $v;
      foreach my $p (@l)
	{
	  
	  if   ( $p eq "EMAIL")
	    { 
	      if ( !($EMAIL=~/@/))
		{
		  exit (EXIT_FAILURE);
		}
	    }
	  elsif( $p eq "INTERNET")
	    {
	      if ( !&check_internet_connection())
		{
		  exit (EXIT_FAILURE);
		}
	    }
	  elsif( $p eq "wget")
	    {
	      if (!&pg_is_installed ("wget") && !&pg_is_installed ("curl"))
		{
		  exit (EXIT_FAILURE);
		}
	    }
	  elsif( !(&pg_is_installed ($p)))
	    {
	      exit (EXIT_FAILURE);
	    }
	}
      return 1;
    }
sub check_internet_connection
  {
    my $internet;
    my $tmp;
    &check_configuration ( "wget"); 
    
    $tmp=&vtmpnam ();
    
    if     (&pg_is_installed    ("wget")){`wget www.google.com -O$tmp >/dev/null 2>/dev/null`;}
    elsif  (&pg_is_installed    ("curl")){`curl www.google.com -o$tmp >/dev/null 2>/dev/null`;}
    
    if ( !-e $tmp || -s $tmp < 10){$internet=0;}
    else {$internet=1;}
    if (-e $tmp){unlink $tmp;}

    return $internet;
  }

sub vtmpnam
      {
	my $r=rand(100000);
	my $f="file.$r.$$";
	while (-e $f)
	  {
	    $f=vtmpnam();
	  }
	push (@TMPFILE_LIST, $f);
	return $f;
      }


</content>
</file>
<file>
<stream>output</stream>
<name>mocca</name>
<content>#!/usr/bin/env perl

$t_coffee="t_coffee";

foreach $value ( @ARGV)
  {
    $seq_file=$seq_file." ".$value;
  }

$name=$ARGV[0];
$name=~s/\.[^\.]*$//;
$lib_name="$name.mocca_lib";
$type=`t_coffee $seq_file -get_type -quiet`;
chop ($type);

if ( $type eq "PROTEIN"){$lib_mode="lalign_rs_s_pair -lalign_n_top 20";}
elsif ( $type eq"DNA"){$lib_mode="lalign_rs_s_dna_pair -lalign_n_top 40";}

if ( !(-e $lib_name))
  {
	  
  $command="$t_coffee -mocca -seq_weight=no -cosmetic_penalty=0 -mocca_interactive -in $lib_mode -out_lib $lib_name -infile $seq_file";
  
  }
elsif ( (-e $lib_name))
  {
  $command="$t_coffee -mocca -seq_weight=no -cosmetic_penalty=0 -mocca_interactive -in $lib_name -infile $seq_file";
  
  }

system ($command);

exit;


</content>
</file>
<file>
<stream>output</stream>
<name>dalilite.pl</name>
<content>#!/usr/bin/env perl
my $WSDL = 'http://www.ebi.ac.uk/Tools/webservices/wsdl/WSDaliLite.wsdl';

use SOAP::Lite;
use Data::Dumper;
use Getopt::Long qw(:config no_ignore_case bundling);
use File::Basename;

my $checkInterval = 5;

my %params=(
	    'async' => '1', # Use async mode and simulate sync mode in client
	    );
GetOptions(
    'pdb1=s'     => \$params{'sequence1'},
    'chainid1=s' => \$params{'chainid1'},
    'pdb2=s'     => \$params{'sequence2'},
    'chainid2=s' => \$params{'chainid2'},
    "help|h"	 => \$help, # Usage info
    "async|a"	 => \$async, # Asynchronous submission
    "polljob"	 => \$polljob, # Get results
    "status"	 => \$status, # Get status
    "jobid|j=s"  => \$jobid, # JobId
    "email|S=s"  => \$params{email}, # E-mail address
    "trace"      => \$trace, # SOAP messages
    "sequence=s" => \$sequence, # Input PDB
    );

my $scriptName = basename($0, ());
if($help) {
    &usage();
    exit(0);
}

if($trace) {
    print "Tracing active\n";
    SOAP::Lite->import(+trace => 'debug');
}

my $soap = SOAP::Lite
    ->service($WSDL)
    ->on_fault(sub {
        my $soap = shift;
        my $res = shift;
        # Throw an exception for all faults
        if(ref($res) eq '') {
            die($res);
        } else {
            die($res->faultstring);
        }
        return new SOAP::SOM;
    }
               );

if( !($polljob || $status) &&
    !( defined($params{'sequence1'}) && defined($params{'sequence2'}) )
    ) {
    print STDERR 'Error: bad option combination', "\n";
    &usage();
    exit(1);
}
elsif($polljob && defined($jobid)) {
    print "Getting results for job $jobid\n";
    getResults($jobid);
}
elsif($status && defined($jobid)) {
    print STDERR "Getting status for job $jobid\n";
    my $result = $soap->checkStatus($jobid);
    print STDOUT "$result", "\n";
    if($result eq 'DONE') {
	print STDERR "To get results: $scriptName --polljob --jobid $jobid\n";
    }
}
else {
    if(-f $params{'sequence1'}) {
	$params{'sequence1'} = read_file($params{'sequence1'});
    }
    if(-f $params{'sequence2'}) {
	$params{'sequence2'} = read_file($params{'sequence2'});
    }

    my $jobid;
    my $paramsData = SOAP::Data->name('params')->type(map=>\%params);
    # For SOAP::Lite 0.60 and earlier parameters are passed directly
    if($SOAP::Lite::VERSION eq '0.60' || $SOAP::Lite::VERSION =~ /0\.[1-5]/) {
        $jobid = $soap->runDaliLite($paramsData);
    }
    # For SOAP::Lite 0.69 and later parameter handling is different, so pass
    # undef's for templated params, and then pass the formatted args.
    else {
        $jobid = $soap->runDaliLite(undef,
				     $paramsData);
    }

    if (defined($async)) {
	print STDOUT $jobid, "\n";
        print STDERR "To check status: $scriptName --status --jobid $jobid\n";
    } else { # Synchronous mode
        print STDERR "JobId: $jobid\n";
        sleep 1;
        getResults($jobid);
    }
}

sub clientPoll($) {
    my $jobid = shift;
    my $result = 'PENDING';
    # Check status and wait if not finished
    #print STDERR "Checking status: $jobid\n";
    while($result eq 'RUNNING' || $result eq 'PENDING') {
        $result = $soap->checkStatus($jobid);
        print STDERR "$result\n";
        if($result eq 'RUNNING' || $result eq 'PENDING') {
            # Wait before polling again.
            sleep $checkInterval;
        }
    }
}

sub getResults($) {
    $jobid = shift;
    # Check status, and wait if not finished
    clientPoll($jobid);
    # Use JobId if output file name is not defined
    unless(defined($outfile)) {
        $outfile=$jobid;
    }
    # Get list of data types
    my $resultTypes = $soap->getResults($jobid);
    # Get the data and write it to a file
    if(defined($outformat)) { # Specified data type
        my $selResultType;
        foreach my $resultType (@$resultTypes) {
            if($resultType->{type} eq $outformat) {
                $selResultType = $resultType;
            }
        }
        $res=$soap->poll($jobid, $selResultType->{type});
        write_file($outfile.'.'.$selResultType->{ext}, $res);
    } else { # Data types available
        # Write a file for each output type
        for my $resultType (@$resultTypes){
            #print "Getting $resultType->{type}\n";
            $res=$soap->poll($jobid, $resultType->{type});
            write_file($outfile.'.'.$resultType->{ext}, $res);
        }
    }
}

sub read_file($) {
    my $filename = shift;
    open(FILE, $filename);
    my $content;
    my $buffer;
    while(sysread(FILE, $buffer, 1024)) {
	$content.= $buffer;
    }
    close(FILE);
    return $content;
}

sub write_file($$) {
    my ($tmp,$entity) = @_;
    print STDERR "Creating result file: ".$tmp."\n";
    unless(open (FILE, ">$tmp")) {
	return 0;
    }
    syswrite(FILE, $entity);
    close (FILE);
    return 1;
}

sub usage {
    print STDERR <<EOF
DaliLite
========

Pairwise comparison of protein structures

[Required]

  --pdb1                : str  : PDB ID for structure 1
  --pdb2                : str  : PDB ID for structure 2

[Optional]

  --chain1              : str  : Chain identifer in structure 1
  --chain2              : str  : Chain identifer in structure 2

[General]

  -h, --help            :      : prints this help text
  -S, --email           : str  : user email address
  -a, --async           :      : asynchronous submission
      --status          :      : poll for the status of a job
      --polljob         :      : poll for the results of a job
  -j, --jobid           : str  : jobid for an asynchronous job
  -O, --outfile         : str  : file name for results (default is jobid)
      --trace	        :      : show SOAP messages being interchanged 

Synchronous job:

  The results/errors are returned as soon as the job is finished.
  Usage: $scriptName --email <your\@email> [options] pdbFile [--outfile string]
  Returns: saves the results to disk

Asynchronous job:

  Use this if you want to retrieve the results at a later time. The results 
  are stored for up to 24 hours. 
  The asynchronous submission mode is recommended when users are submitting 
  batch jobs or large database searches	
  Usage: $scriptName --email <your\@email> --async [options] pdbFile
  Returns: jobid

  Use the jobid to query for the status of the job. 
  Usage: $scriptName --status --jobid <jobId>
  Returns: string indicating the status of the job:
    DONE - job has finished
    RUNNING - job is running
    NOT_FOUND - job cannot be found
    ERROR - the jobs has encountered an error

  When done, use the jobid to retrieve the status of the job. 
  Usage: $scriptName --polljob --jobid <jobId> [--outfile string]

[Help]

  For more detailed help information refer to
  http://www.ebi.ac.uk/DaliLite/
EOF
;
}

</content>
</file>
<file>
<stream>output</stream>
<name>wublast.pl</name>
<content>#!/usr/bin/env perl
my $WSDL = 'http://www.ebi.ac.uk/Tools/webservices/wsdl/WSWUBlast.wsdl';

use strict;
use SOAP::Lite;
use Getopt::Long qw(:config no_ignore_case bundling);
use File::Basename;

my $checkInterval = 15;

my $numOpts = scalar(@ARGV);
my ($outfile, $outformat, $help, $async, $polljob, $status, $ids, $jobid, $trace, $sequence);
my %params= ( # Defaults
	      'async' => 1, # Force into async mode
	      'exp' => 10.0, # E-value threshold
	      'numal' => 50, # Maximum number of alignments
	      'scores' => 100, # Maximum number of scores
            );
GetOptions( # Map the options into variables
    "program|p=s"     => \$params{program}, # BLAST program
    "database|D=s"    => \$params{database}, # Search database
    "matrix|m=s"      => \$params{matrix}, # Scoring matrix
    "exp|E=f"         => \$params{exp}, # E-value threshold
    "echofilter|e"    => \$params{echofilter}, # Display filtered sequence
    "filter|f=s"      => \$params{filter}, # Low complexity filter name
    "alignments|b=i"  => \$params{numal}, # Number of alignments
    "scores|s=i"      => \$params{scores}, # Number of scores
    "sensitivity|S=s" => \$params{sensitivity}, # Search sensitivity
    "sort|t=s"	      => \$params{sort}, # Sort hits by...
    "stats|T=s"       => \$params{stats}, # Scoring statistic to use
    "strand|d=s"      => \$params{strand}, # Strand to use in DNA vs. DNA search
    "topcombon|c=i"   => \$params{topcombon}, # Consistent sets of HSPs
    "outfile=s"       => \$outfile, # Output file
    "outformat|o=s"   => \$outformat, # Output format
    "help|h"	      => \$help, # Usage info
    "async|a"	      => \$async, # Asynchronous mode
    "polljob"	      => \$polljob, # Get results
    "status"	      => \$status, # Get job status
    "ids"             => \$ids, # Get ids from result
    "jobid|j=s"       => \$jobid, # JobId
    "email=s"         => \$params{email}, # E-mail address
    "trace"           => \$trace, # SOAP trace
    "sequence=s"      => \$sequence, # Query sequence
    );

my $scriptName = basename($0, ());
if($help || $numOpts == 0) {
    &usage();
    exit(0);
}

if($trace){
    print STDERR "Tracing active\n";
    SOAP::Lite->import(+trace => 'debug');
}

my $soap = SOAP::Lite
    ->service($WSDL)
    ->proxy('http://localhost/',
    #proxy => ['http' => 'http://your.proxy.server/'], # HTTP proxy
    timeout => 600, # HTTP connection timeout
    )
    ->on_fault(sub { # SOAP fault handler
        my $soap = shift;
        my $res = shift;
        # Throw an exception for all faults
        if(ref($res) eq '') {
            die($res);
        } else {
            die($res->faultstring);
        }
        return new SOAP::SOM;
    }
               );

if( !($polljob || $status || $ids) &&
    !( defined($ARGV[0]) || defined($sequence) )
    ) {
    print STDERR 'Error: bad option combination', "\n";
    &usage();
    exit(1);
}
elsif($polljob && defined($jobid)) {
    print "Getting results for job $jobid\n";
    getResults($jobid);
}
elsif($status && defined($jobid)) {
    print STDERR "Getting status for job $jobid\n";
    my $result = $soap->checkStatus($jobid);
    print STDOUT "$result\n";
    if($result eq 'DONE') {
	print STDERR "To get results: $scriptName --polljob --jobid $jobid\n";
    }
}  
elsif($ids && defined($jobid)) {
    print STDERR "Getting ids from job $jobid\n";
    getIds($jobid);
}
else {
    # Prepare input data
    my $content;
    my (@contents) = ();
    if(-f $ARGV[0] || $ARGV[0] eq '-') {	
	$content={type=>'sequence',content=>read_file($ARGV[0])};	
    }
    if($sequence) {	
	if(-f $sequence || $sequence eq '-') {	
	    $content={type=>'sequence',content=>read_file($ARGV[0])};	
	} else {
	    $content={type=>'sequence',content=>$sequence};
	}
    }
    push @contents, $content;

    # Submit the job
    my $paramsData = SOAP::Data->name('params')->type(map=>\%params);
    my $contentData = SOAP::Data->name('content')->value(\@contents);
    # For SOAP::Lite 0.60 and earlier parameters are passed directly
    if($SOAP::Lite::VERSION eq '0.60' || $SOAP::Lite::VERSION =~ /0\.[1-5]/) {
        $jobid = $soap->runWUBlast($paramsData, $contentData);
    }
    # For SOAP::Lite 0.69 and later parameter handling is different, so pass
    # undef's for templated params, and then pass the formatted args.
    else {
        $jobid = $soap->runWUBlast(undef, undef,
				   $paramsData, $contentData);
    }

    # Asynchronous mode: output jobid and exit.
    if (defined($async)) {
	print STDOUT $jobid, "\n";
        print STDERR "To check status: $scriptName --status --jobid $jobid\n";
    }
    # Synchronous mode: try to get results
    else {
        print STDERR "JobId: $jobid\n";
        sleep 1;
        getResults($jobid);
    }
}

sub getIds($) {
    my $jobid = shift;
    my $results = $soap->getIds($jobid);
    for my $result (@$results){
	print "$result\n";
    }
}

sub clientPoll($) {
    my $jobid = shift;
    my $result = 'PENDING';
    # Check status and wait if not finished
    while($result eq 'RUNNING' || $result eq 'PENDING') {
        $result = $soap->checkStatus($jobid);
        print STDERR "$result\n";
        if($result eq 'RUNNING' || $result eq 'PENDING') {
            # Wait before polling again.
            sleep $checkInterval;
        }
    }
}

sub getResults($) {
    my $jobid = shift;
    my $res;
    # Check status, and wait if not finished
    clientPoll($jobid);
    # Use JobId if output file name is not defined
    unless(defined($outfile)) {
        $outfile=$jobid;
    }
    # Get list of data types
    my $resultTypes = $soap->getResults($jobid);
    # Get the data and write it to a file
    if(defined($outformat)) { # Specified data type
	if($outformat eq 'xml') {$outformat = 'toolxml';}
	if($outformat eq 'txt') {$outformat = 'tooloutput';}
        my $selResultType;
        foreach my $resultType (@$resultTypes) {
            if($resultType->{type} eq $outformat) {
                $selResultType = $resultType;
            }
        }
        $res=$soap->poll($jobid, $selResultType->{type});
	if($outfile eq '-') {
	     write_file($outfile, $res);
	} else {
	    write_file($outfile.'.'.$selResultType->{ext}, $res);
	}
    } else { # Data types available
        # Write a file for each output type
        for my $resultType (@$resultTypes){
            #print STDERR "Getting $resultType->{type}\n";
            $res=$soap->poll($jobid, $resultType->{type});
	    if($outfile eq '-') {
		write_file($outfile, $res);
	    } else {
		write_file($outfile.'.'.$resultType->{ext}, $res);
	    }
        }
    }
}

sub read_file($) {
    my $filename = shift;
    my ($content, $buffer);
    if($filename eq '-') {
	while(sysread(STDIN, $buffer, 1024)) {
	    $content .= $buffer;
	}
    }
    else { # File
	open(FILE, $filename) or die "Error: unable to open input file";
	while(sysread(FILE, $buffer, 1024)) {
	    $content .= $buffer;
	}
	close(FILE);
    }
    return $content;
}

sub write_file($$) {
    my ($filename, $data) = @_;
    print STDERR 'Creating result file: ' . $filename . "\n";
    if($filename eq '-') {
	print STDOUT $data;
    }
    else {
	open(FILE, ">$filename") or die "Error: unable to open output file";
	syswrite(FILE, $data);
	close(FILE);
    }
}

sub usage {
    print STDERR <<EOF
WU-BLAST
========

Rapid sequence database search programs utilizing the BLAST algorithm.
   
[Required]

      --email       : str  : user email address 
  -p, --program	    : str  : BLAST program to use: blastn, blastp, blastx, 
                             tblastn or tblastx
  -D, --database    : str  : database to search
  seqFile           : file : query sequence data file ("-" for STDIN)

[Optional]

  -m, --matrix	    : str  : scoring matrix
  -E, --exp	    : real : 0<E<= 1000. Statistical significance threshold
                             for reporting database sequence matches.
  -e, --echofilter  :      : display the filtered query sequence in the output
  -f, --filter	    : str  : activates filtering of the query sequence
  -b, --alignments  : int  : number of alignments to be reported
  -s, --scores	    : int  : number of scores to be reported
  -S, --sensitivity : str  :
  -t, --sort	    : str  :
  -T, --stats       : str  :
  -d, --strand      : str  : DNA strand to search with in DNA vs. DNA searches 
  -c, --topcombon   :      :

[General]	

  -h, --help       :      : prints this help text
  -a, --async      :      : forces to make an asynchronous query
      --status     :      : poll for the status of a job
      --polljob    :      : poll for the results of a job
  -j, --jobid      : str  : jobid that was returned when an asynchronous job 
                            was submitted.
  -O, --outfile    : str  : name of the file results should be written to 
                            (default is based on the jobid; "-" for STDOUT)
  -o, --outformat  : str  : txt or xml output (no file is written)
      --trace	   :      : show SOAP messages being interchanged 

Synchronous job:

  The results/errors are returned as soon as the job is finished.
  Usage: $scriptName --email <your\@email> [options...] seqFile
  Returns: saves the results to disk

Asynchronous job:

  Use this if you want to retrieve the results at a later time. The results 
  are stored for up to 24 hours. 
  The asynchronous submission mode is recommended when users are submitting 
  batch jobs or large database searches	
  Usage: $scriptName --async --email <your\@email> [options...] seqFile
  Returns : jobid

  Use the jobid to query for the status of the job. 
  Usage: $scriptName --status --jobid <jobId>
  Returns : string indicating the status of the job:
    DONE - job has finished
    RUNNING - job is running
    NOT_FOUND - job cannot be found
    ERROR - the jobs has encountered an error

  When done, use the jobid to retrieve the status of the job. 
  Usage: $scriptName --polljob --jobid <jobId> [--outfile string]
  Returns: saves the results to disk

[Help]

For more detailed help information refer to 
http://www.ebi.ac.uk/blast2/WU-Blast2_Help_frame.html
 
EOF
;
}

</content>
</file>
<file>
<stream>output</stream>
<name>blastpgp.pl</name>
<content>#!/usr/bin/env perl

my $WSDL = 'http://www.ebi.ac.uk/Tools/webservices/wsdl/WSBlastpgp.wsdl';

use SOAP::Lite;
use Getopt::Long qw(:config no_ignore_case bundling);
use File::Basename;

my $checkInterval = 15;

my %params=(
	    'async' => '1', # Use async mode and simulate sync mode in client
	    );
GetOptions(
    "mode=s"           => \$params{mode}, # Search mode: PSI-Blast or PHI-Blast
    "database|d=s"     => \$params{database}, # Database to search
    "matrix|M=s"       => \$params{matrix},# Scoring maxtrix
    "exp|e=f"          => \$params{exp}, # E-value
    "expmulti|h=f"     => \$params{expmulti}, # E-value
    "filter|F=s"       => \$params{filter}, # Low complexity filter
    "dropoff|X=i"      => \$params{dropoff}, # Dropoff score
    "finaldropoff|Z=i" => \$params{finaldropoff}, # Final dropoff score
    "scores|v=i"       => \$params{scores}, # Max number of scores
    "align=i"          => \$params{align}, # Alignment view
    "startregion|S=i"  => \$params{startregion}, # Start of region in query
    "endregion|H=i"    => \$params{endregion}, # End of region in query
    "maxpasses|j=i"    => \$params{maxpasses}, # Number of PSI iterations
    "opengap|G=i"      => \$params{opengap}, # Gap open penalty
    "extendgap|E=i"    => \$params{extendgap}, # Gap extension penalty
    "pattern=s"        => \$params{pattern}, # PHI-BLAST pattern
    "usagemode|p=s"    => \$params{usagemode}, # PHI-BLAST program
    "appxml=s"         => \$params{appxml}, # Application XML
    "sequence=s"       => \$sequence, # Query sequence
    "help"	       => \$help, # Usage info
    "polljob"	       => \$polljob, # Get results
    "status"	       => \$status, # Get status
    "ids"      	       => \$ids, # Get ids from result
    "jobid=s"          => \$jobid, # JobId
    "outfile=s"        => \$outfile, # Output filename
    "outformat|o=s"    => \$outformat, # Output file format
    "async|a"	       => \$async, # Async submission
    "email=s"          => \$params{email}, # User e-mail address
    "trace"            => \$trace, # Show SOAP messages
    );

my $scriptName = basename($0, ());
if($help) {
    &usage();
    exit(0);
}

if ($trace){
    print "Tracing active\n";
    SOAP::Lite->import(+trace => 'debug');
}

my $soap = SOAP::Lite
    ->service($WSDL)
    ->on_fault(sub {
        my $soap = shift;
        my $res = shift;
        # Throw an exception for all faults
        if(ref($res) eq '') {
            die($res);
        } else {
            die($res->faultstring);
        }
        return new SOAP::SOM;
    }
               );

if( !($polljob || $status || $ids) &&
    !( (defined($ARGV[0]) && -f $ARGV[0]) || defined($sequence) )
    ) {
    print STDERR 'Error: bad option combination', "\n";
    &usage();
    exit(1);
}
elsif($polljob && defined($jobid)) {
    print "Getting results for job $jobid\n";
    getResults($jobid);
}
elsif($status && defined($jobid)) {
    print STDERR "Getting status for job $jobid\n";
    my $result = $soap->checkStatus($jobid);
    print STDOUT $result, "\n";
    if($result eq 'DONE') {
	print STDERR "To get results: $scriptName --polljob --jobid $jobid\n";
    }
}  
elsif($ids && defined($jobid)) {
    print STDERR "Getting ids from job $jobid\n";
    getIds($jobid);
}
else {
    if(-f $ARGV[0]) {	
	$content={type=>'sequence', content=>read_file($ARGV[0])};	
    }
    if($sequence) {	
	if(-f $sequence) {
	    $content={type=>'sequence', content=>read_file($sequence)};	
	} else {
	    $content={type=>'sequence', content=>$sequence};
	}
    }
    push @content, $content;

    my $jobid;
    my $paramsData = SOAP::Data->name('params')->type(map=>\%params);
    my $contentData = SOAP::Data->name('content')->value(\@content);
    # For SOAP::Lite 0.60 and earlier parameters are passed directly
    if($SOAP::Lite::VERSION eq '0.60' || $SOAP::Lite::VERSION =~ /0\.[1-5]/) {
        $jobid = $soap->runBlastpgp($paramsData, $contentData);
    }
    # For SOAP::Lite 0.69 and later parameter handling is different, so pass
    # undef's for templated params, and then pass the formatted args.
    else {
        $jobid = $soap->runBlastpgp(undef, undef,
				    $paramsData, $contentData);
    }

    if (defined($async)) {
	print STDOUT $jobid, "\n";
        print STDERR "To check status: $scriptName --status --jobid $jobid\n";
    } else { # Synchronous mode
        print STDERR "JobId: $jobid\n";
        sleep 1;
        getResults($jobid);
    }
}

sub getIds($) {
    $jobid = shift;
    my $results = $soap->getIds($jobid);
    for $result (@$results){
	print "$result\n";
    }
}

sub clientPoll($) {
    my $jobid = shift;
    my $result = 'PENDING';
    # Check status and wait if not finished
    #print STDERR "Checking status: $jobid\n";
    while($result eq 'RUNNING' || $result eq 'PENDING') {
        $result = $soap->checkStatus($jobid);
        print STDERR "$result\n";
        if($result eq 'RUNNING' || $result eq 'PENDING') {
            # Wait before polling again.
            sleep $checkInterval;
        }
    }
}

sub getResults($) {
    $jobid = shift;
    # Check status, and wait if not finished
    clientPoll($jobid);
    # Use JobId if output file name is not defined
    unless(defined($outfile)) {
        $outfile=$jobid;
    }
    # Get list of data types
    my $resultTypes = $soap->getResults($jobid);
    # Get the data and write it to a file
    if(defined($outformat)) { # Specified data type
        my $selResultType;
        foreach my $resultType (@$resultTypes) {
            if($resultType->{type} eq $outformat) {
                $selResultType = $resultType;
            }
        }
        $res=$soap->poll($jobid, $selResultType->{type});
        write_file($outfile.'.'.$selResultType->{ext}, $res);
    } else { # Data types available
        # Write a file for each output type
        for my $resultType (@$resultTypes){
            #print "Getting $resultType->{type}\n";
            $res=$soap->poll($jobid, $resultType->{type});
            write_file($outfile.'.'.$resultType->{ext}, $res);
        }
    }
}

sub read_file($) {
    my $filename = shift;
    open(FILE, $filename);
    my $content;
    my $buffer;
    while(sysread(FILE, $buffer, 1024)) {
	$content.= $buffer;
    }
    close(FILE);  
    return $content;
}

sub write_file($$) {
    my ($tmp,$entity) = @_;
    print STDERR "Creating result file: ".$tmp."\n";
    unless(open (FILE, ">$tmp")) {
	return 0;
    }
    syswrite(FILE, $entity);
    close (FILE);
    return 1;
}

sub usage {
    print STDERR <<EOF
Blastpgp
========
   
The blastpgp program implements the PSI-BLAST and PHI-BLAST variations
of NCBI BLAST.

For more detailed help information refer to
http://www.ebi.ac.uk/blastpgp/blastpsi_help_frame.html
 
Blastpgp specific options:

[Required]

      --mode            : str  : search mode to use: PSI-Blast or PHI-Blast
  -d, --database        : str  : protein database to search
  seqFile               : file : query sequence

[Optional]

  -M, --matrix          : str  : scoring matrix
  -e, --exp             : real : Expectation value
  -h, --expmulti        : real : threshold (multipass model)
  -F, --filter          : str  : filter query sequence with SEG [T,F]
  -m, --align           : int  : alignment view option:
                                 0 - pairwise, 1 - M/S identities,
                                 2 - M/S non-identities, 3 - Flat identities,
                                 4 - Flat non-identities
  -G, --opengap         : int  : cost to open a gap
  -E, --extendgap       : int  : cost to extend a gap
  -g, --gapalign        : str  : Gapped [T,F]
  -v, --scores          : int  : number of scores to be reported
  -j, --maxpasses       : int  : number of iterations
  -X, --dropoff         : int  : Dropoff score
  -Z, --finaldropoff    : int  : Dropoff for final alignment
  -S, --startregion     : int  : Start of required region in query
  -H, --endregion       : int  : End of required region in query
  -k, --pattern         : str  : Hit File (PHI-BLAST only)
  -p, --usagemode       : str  : Program option (PHI-BLAST only):
                                 blastpgp, patseedp, seedp

[General]

      --help            :      : prints this help text
  -a, --async           :      : forces to make an asynchronous query
      --status          :      : poll for the status of a job
      --polljob         :      : poll for the results of a job
      --jobid           : str  : jobid of an asynchronous job
      --ids             :      : get hit identifiers for result 
  -O, --outfile         : str  : name of the file results should be written to
                                 (default is based on the jobid)
  -o, --outformat       : str  : txt or xml output (no file is written)
      --trace           :      : show SOAP messages being interchanged

Synchronous job:

  The results/errors are returned as soon as the job is finished.
  Usage: blastpgp.pl --email <your@email> [options...] seqfile
  Returns: saves the results to disk

Asynchronous job:

  Use this if you want to retrieve the results at a later time. The results
  are stored for up to 24 hours.
  The asynchronous submission mode is recommended when users are submitting
  batch jobs or large database searches
  Usage: blastpgp.pl --email <your@email> --async [options...] seqFile
  Returns: jobid

  Use the jobid to query for the status of the job.
  Usage: blastpgp.pl --status --jobid <jobId>
  Returns: string indicating the status of the job
    DONE - job has finished
    RUNNING - job is running
    NOT_FOUND - job cannot be found
    ERROR - the jobs has encountered an error

  When done, use the jobid to retrieve the results of the job.
  Usage: blastpgp.pl --polljob --jobid <jobId> [--outfile <fileName>]
  Returns: saves the results to disk
EOF
;
}

</content>
</file>
<file>
<stream>output</stream>
<name>ncbiblast_lwp.pl</name>
<content>#!/usr/bin/env perl

=head1 NAME

ncbiblast_lwp.pl

=head1 DESCRIPTION

NCBI BLAST (REST) web service Perl client using L<LWP>.

Tested with:

=over

=item *
L<LWP> 5.79, L<XML::Simple> 2.12 and Perl 5.8.3

=item *
L<LWP> 5.808, L<XML::Simple> 2.18 and Perl 5.8.8 (Ubuntu 8.04 LTS)

=item *
L<LWP> 5.834, L<XML::Simple> 2.18 and Perl 5.10.1 (Ubuntu 10.04 LTS)

=item *
L<LWP> 6.03, L<XML::Simple> 2.18 and Perl 5.14.2 (Ubuntu 12.04 LTS)

=back

For further information see:

=over

=item *
L<http://www.ebi.ac.uk/Tools/webservices/services/sss/ncbi_blast_rest>

=item *
L<http://www.ebi.ac.uk/Tools/webservices/tutorials/perl>

=back

=head1 LICENSE

Copyright 2012-2013 EMBL - European Bioinformatics Institute

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

=head1 VERSION

$Id: ncbiblast_lwp.pl 2560 2013-03-20 12:56:31Z hpm $

=cut

use strict;
use warnings;

use English;
use LWP;
use XML::Simple;
use Getopt::Long qw(:config no_ignore_case bundling);
use File::Basename;
use Data::Dumper;

my $baseUrl = 'http://www.ebi.ac.uk/Tools/services/rest/ncbiblast';

my $checkInterval = 3;

my $outputLevel = 1;

my $numOpts = scalar(@ARGV);
my %params = ( 'debugLevel' => 0 );

my %tool_params = ();
GetOptions(

	# Tool specific options
	'program|p=s'  => \$tool_params{'program'},   # blastp, blastn, blastx, etc.
	'database|D=s' => \$params{'database'},       # Database(s) to search
	'matrix|m=s'   => \$tool_params{'matrix'},    # Scoring martix to use
	'exp|E=f'      => \$tool_params{'exp'},       # E-value threshold
	'filter|f=s'   => \$tool_params{'filter'},    # Low complexity filter
	'align|A=i'    => \$tool_params{'align'},     # Pairwise alignment format
	'scores|s=i'   => \$tool_params{'scores'},    # Number of scores
	'alignments|n=i' => \$tool_params{'alignments'},   # Number of alignments
	'dropoff|d=i'    => \$tool_params{'dropoff'},      # Dropoff score
	'match_scores=s' => \$tool_params{'match_scores'}, # Match/missmatch scores
	'match|u=i'      => \$params{'match'},             # Match score
	'mismatch|v=i'   => \$params{'mismatch'},          # Mismatch score
	'gapopen|o=i'    => \$tool_params{'gapopen'},      # Open gap penalty
	'gapext|x=i'     => \$tool_params{'gapext'},       # Gap extension penality
	'gapalign|g'     => \$tool_params{'gapalign'},     # Optimise gap alignments
	'stype=s' => \$tool_params{'stype'},    # Sequence type
	'seqrange=s' => \$tool_params{'seqrange'},    # Query subsequence
	'sequence=s' => \$params{'sequence'},         # Query sequence
	'multifasta' => \$params{'multifasta'},       # Multiple fasta input

	# Compatability options, old command-line
	'numal|n=i'     => \$params{'numal'},        # Number of alignments
	'opengap|o=i'   => \$params{'opengap'},      # Open gap penalty
	'extendgap|x=i' => \$params{'extendgap'},    # Gap extension penality
	
	# Generic options
	'email=s'       => \$params{'email'},          # User e-mail address
	'title=s'       => \$params{'title'},          # Job title
	'outfile=s'     => \$params{'outfile'},        # Output file name
	'outformat=s'   => \$params{'outformat'},      # Output file type
	'jobid=s'       => \$params{'jobid'},          # JobId
	'help|h'        => \$params{'help'},           # Usage help
	'async'         => \$params{'async'},          # Asynchronous submission
	'polljob'       => \$params{'polljob'},        # Get results
	'resultTypes'   => \$params{'resultTypes'},    # Get result types
	'status'        => \$params{'status'},         # Get status
	'params'        => \$params{'params'},         # List input parameters
	'paramDetail=s' => \$params{'paramDetail'},    # Get details for parameter
	'quiet'         => \$params{'quiet'},          # Decrease output level
	'verbose'       => \$params{'verbose'},        # Increase output level
	'debugLevel=i'  => \$params{'debugLevel'},     # Debug output level
	'baseUrl=s'     => \$baseUrl,                  # Base URL for service.
);
if ( $params{'verbose'} ) { $outputLevel++ }
if ( $params{'quiet'} )  { $outputLevel-- }

&print_debug_message( 'MAIN', 'LWP::VERSION: ' . $LWP::VERSION,
	1 );

&print_debug_message( 'MAIN', "params:\n" . Dumper( \%params ),           11 );
&print_debug_message( 'MAIN', "tool_params:\n" . Dumper( \%tool_params ), 11 );

my $ua;

my $scriptName = basename( $0, () );

if ( $params{'help'} || $numOpts == 0 ) {
	&usage();
	exit(0);
}

&print_debug_message( 'MAIN', 'baseUrl: ' . $baseUrl, 1 );

if (
	!(
		   $params{'polljob'}
		|| $params{'resultTypes'}
		|| $params{'status'}
		|| $params{'params'}
		|| $params{'paramDetail'}
	)
	&& !( defined( $ARGV[0] ) || defined( $params{'sequence'} ) )
  )
{

	# Bad argument combination, so print error message and usage
	print STDERR 'Error: bad option combination', "\n";
	&usage();
	exit(1);
}

elsif ( $params{'params'} ) {
	&print_tool_params();
}

elsif ( $params{'paramDetail'} ) {
	&print_param_details( $params{'paramDetail'} );
}

elsif ( $params{'status'} && defined( $params{'jobid'} ) ) {
	&print_job_status( $params{'jobid'} );
}

elsif ( $params{'resultTypes'} && defined( $params{'jobid'} ) ) {
	&print_result_types( $params{'jobid'} );
}

elsif ( $params{'polljob'} && defined( $params{'jobid'} ) ) {
	&get_results( $params{'jobid'} );
}

else {

	# Multiple input sequence mode, assume fasta format.
	if ( $params{'multifasta'} ) {
		&multi_submit_job();
	}

	# Entry identifier list file.
	elsif (( defined( $params{'sequence'} ) && $params{'sequence'} =~ m/^\@/ )
		|| ( defined( $ARGV[0] ) && $ARGV[0] =~ m/^\@/ ) )
	{
		my $list_filename = $params{'sequence'} || $ARGV[0];
		$list_filename =~ s/^\@//;
		&list_file_submit_job($list_filename);
	}

	# Default: single sequence/identifier.
	else {

		# Load the sequence data and submit.
		&submit_job( &load_data() );
	}
}

=head1 FUNCTIONS

=cut


=head2 rest_user_agent()

Get a LWP UserAgent to use to perform REST requests.

  my $ua = &rest_user_agent();

=cut

sub rest_user_agent() {
	print_debug_message( 'rest_user_agent', 'Begin', 21 );
	# Create an LWP UserAgent for making HTTP calls.
	my $ua = LWP::UserAgent->new();
	# Set 'User-Agent' HTTP header to identifiy the client.
	'$Revision: 2560 $' =~ m/(\d+)/;
	$ua->agent("EBI-Sample-Client/$1 ($scriptName; $OSNAME) " . $ua->agent());
	# Configure HTTP proxy support from environment.
	$ua->env_proxy;
	print_debug_message( 'rest_user_agent', 'End', 21 );
	return $ua;
}

=head2 rest_error()

Check a REST response for an error condition. An error is mapped to a die.

  &rest_error($response, $content_data);

=cut

sub rest_error() {
	print_debug_message( 'rest_error', 'Begin', 21 );
	my $response = shift;
	my $contentdata;
	if(scalar(@_) > 0) {
		$contentdata = shift;
	}
	if(!defined($contentdata) || $contentdata eq '') {
		$contentdata = $response->content();
	}
	# Check for HTTP error codes
	if ( $response->is_error ) {
		my $error_message = '';
		# HTML response.
		if(	$contentdata =~ m/<h1>([^<]+)<\/h1>/ ) {
			$error_message = $1;
		}
		#  XML response.
		elsif($contentdata =~ m/<description>([^<]+)<\/description>/) {
			$error_message = $1;
		}
		die 'http status: ' . $response->code . ' ' . $response->message . '  ' . $error_message;
	}
	print_debug_message( 'rest_error', 'End', 21 );
}

=head2 rest_request()

Perform a REST request (HTTP GET).

  my $response_str = &rest_request($url);

=cut

sub rest_request {
	print_debug_message( 'rest_request', 'Begin', 11 );
	my $requestUrl = shift;
	print_debug_message( 'rest_request', 'URL: ' . $requestUrl, 11 );

	# Get an LWP UserAgent.
	$ua = &rest_user_agent() unless defined($ua);
	# Available HTTP compression methods.
	my $can_accept;
	eval {
	    $can_accept = HTTP::Message::decodable();
	};
	$can_accept = '' unless defined($can_accept);
	# Perform the request
	my $response = $ua->get($requestUrl,
		'Accept-Encoding' => $can_accept, # HTTP compression.
	);
	print_debug_message( 'rest_request', 'HTTP status: ' . $response->code,
		11 );
	print_debug_message( 'rest_request',
		'response length: ' . length($response->content()), 11 );
	print_debug_message( 'rest_request',
		'request:' ."\n" . $response->request()->as_string(), 32 );
	print_debug_message( 'rest_request',
		'response: ' . "\n" . $response->as_string(), 32 );
	# Unpack possibly compressed response.
	my $retVal;
	if ( defined($can_accept) && $can_accept ne '') {
	    $retVal = $response->decoded_content();
	}
	# If unable to decode use orginal content.
	$retVal = $response->content() unless defined($retVal);
	# Check for an error.
	&rest_error($response, $retVal);
	print_debug_message( 'rest_request', 'retVal: ' . $retVal, 12 );
	print_debug_message( 'rest_request', 'End', 11 );

	# Return the response data
	return $retVal;
}

=head2 rest_get_parameters()

Get list of tool parameter names.

  my (@param_list) = &rest_get_parameters();

=cut

sub rest_get_parameters {
	print_debug_message( 'rest_get_parameters', 'Begin', 1 );
	my $url                = $baseUrl . '/parameters/';
	my $param_list_xml_str = rest_request($url);
	my $param_list_xml     = XMLin($param_list_xml_str);
	my (@param_list)       = @{ $param_list_xml->{'id'} };
	print_debug_message( 'rest_get_parameters', 'End', 1 );
	return (@param_list);
}

=head2 rest_get_parameter_details()

Get details of a tool parameter.

  my $paramDetail = &rest_get_parameter_details($param_name);

=cut

sub rest_get_parameter_details {
	print_debug_message( 'rest_get_parameter_details', 'Begin', 1 );
	my $parameterId = shift;
	print_debug_message( 'rest_get_parameter_details',
		'parameterId: ' . $parameterId, 1 );
	my $url                  = $baseUrl . '/parameterdetails/' . $parameterId;
	my $param_detail_xml_str = rest_request($url);
	my $param_detail_xml     = XMLin($param_detail_xml_str);
	print_debug_message( 'rest_get_parameter_details', 'End', 1 );
	return ($param_detail_xml);
}

=head2 rest_run()

Submit a job.

  my $job_id = &rest_run($email, $title, \%params );

=cut

sub rest_run {
	print_debug_message( 'rest_run', 'Begin', 1 );
	my $email  = shift;
	my $title  = shift;
	my $params = shift;
	print_debug_message( 'rest_run', 'email: ' . $email, 1 );
	if ( defined($title) ) {
		print_debug_message( 'rest_run', 'title: ' . $title, 1 );
	}
	print_debug_message( 'rest_run', 'params: ' . Dumper($params), 1 );

	# Get an LWP UserAgent.
	$ua = &rest_user_agent() unless defined($ua);

	# Clean up parameters
	my (%tmp_params) = %{$params};
	$tmp_params{'email'} = $email;
	$tmp_params{'title'} = $title;
	foreach my $param_name ( keys(%tmp_params) ) {
		if ( !defined( $tmp_params{$param_name} ) ) {
			delete $tmp_params{$param_name};
		}
	}

	# Submit the job as a POST
	my $url = $baseUrl . '/run';
	my $response = $ua->post( $url, \%tmp_params );
	print_debug_message( 'rest_run', 'HTTP status: ' . $response->code, 11 );
	print_debug_message( 'rest_run',
		'request:' ."\n" . $response->request()->as_string(), 11 );
	print_debug_message( 'rest_run',
		'response: ' . length($response->as_string()) . "\n" . $response->as_string(), 11 );

	# Check for an error.
	&rest_error($response);

	# The job id is returned
	my $job_id = $response->content();
	print_debug_message( 'rest_run', 'End', 1 );
	return $job_id;
}

=head2 rest_get_status()

Check the status of a job.

  my $status = &rest_get_status($job_id);

=cut

sub rest_get_status {
	print_debug_message( 'rest_get_status', 'Begin', 1 );
	my $job_id = shift;
	print_debug_message( 'rest_get_status', 'jobid: ' . $job_id, 2 );
	my $status_str = 'UNKNOWN';
	my $url        = $baseUrl . '/status/' . $job_id;
	$status_str = &rest_request($url);
	print_debug_message( 'rest_get_status', 'status_str: ' . $status_str, 2 );
	print_debug_message( 'rest_get_status', 'End', 1 );
	return $status_str;
}

=head2 rest_get_result_types()

Get list of result types for finished job.

  my (@result_types) = &rest_get_result_types($job_id);

=cut

sub rest_get_result_types {
	print_debug_message( 'rest_get_result_types', 'Begin', 1 );
	my $job_id = shift;
	print_debug_message( 'rest_get_result_types', 'jobid: ' . $job_id, 2 );
	my (@resultTypes);
	my $url                      = $baseUrl . '/resulttypes/' . $job_id;
	my $result_type_list_xml_str = &rest_request($url);
	my $result_type_list_xml     = XMLin($result_type_list_xml_str);
	(@resultTypes) = @{ $result_type_list_xml->{'type'} };
	print_debug_message( 'rest_get_result_types',
		scalar(@resultTypes) . ' result types', 2 );
	print_debug_message( 'rest_get_result_types', 'End', 1 );
	return (@resultTypes);
}

=head2 rest_get_result()

Get result data of a specified type for a finished job.

  my $result = rest_get_result($job_id, $result_type);

=cut

sub rest_get_result {
	print_debug_message( 'rest_get_result', 'Begin', 1 );
	my $job_id = shift;
	my $type   = shift;
	print_debug_message( 'rest_get_result', 'jobid: ' . $job_id, 1 );
	print_debug_message( 'rest_get_result', 'type: ' . $type,    1 );
	my $url    = $baseUrl . '/result/' . $job_id . '/' . $type;
	my $result = &rest_request($url);
	print_debug_message( 'rest_get_result', length($result) . ' characters',
		1 );
	print_debug_message( 'rest_get_result', 'End', 1 );
	return $result;
}


=head2 print_debug_message()

Print debug message at specified debug level.

  &print_debug_message($method_name, $message, $level);

=cut

sub print_debug_message {
	my $function_name = shift;
	my $message       = shift;
	my $level         = shift;
	if ( $level <= $params{'debugLevel'} ) {
		print STDERR '[', $function_name, '()] ', $message, "\n";
	}
}

=head2 print_tool_params()

Print list of tool parameters.

  &print_tool_params();

=cut

sub print_tool_params {
	print_debug_message( 'print_tool_params', 'Begin', 1 );
	my (@param_list) = &rest_get_parameters();
	foreach my $param ( sort(@param_list) ) {
		print $param, "\n";
	}
	print_debug_message( 'print_tool_params', 'End', 1 );
}

=head2 print_param_details()

Print details of a tool parameter.

  &print_param_details($param_name);

=cut

sub print_param_details {
	print_debug_message( 'print_param_details', 'Begin', 1 );
	my $paramName = shift;
	print_debug_message( 'print_param_details', 'paramName: ' . $paramName, 2 );
	my $paramDetail = &rest_get_parameter_details($paramName);
	print $paramDetail->{'name'}, "\t", $paramDetail->{'type'}, "\n";
	print $paramDetail->{'description'}, "\n";
	if(defined($paramDetail->{'values'}->{'value'})) {
		if(ref($paramDetail->{'values'}->{'value'}) eq 'ARRAY') {
			foreach my $value ( @{ $paramDetail->{'values'}->{'value'} } ) {
				&print_param_value($value);
			}
		}
		else {
				&print_param_value($paramDetail->{'values'}->{'value'});
		}
	}
	print_debug_message( 'print_param_details', 'End', 1 );
}

=head2 print_param_value()

Print details of a tool parameter value.

  &print_param_details($param_value);

Used by print_param_details() to handle both singluar and array values.

=cut

sub print_param_value {
	my $value = shift;
	print $value->{'value'};
	if ( $value->{'defaultValue'} eq 'true' ) {
		print "\t", 'default';
	}
	print "\n";
	print "\t", $value->{'label'}, "\n";
	if ( defined( $value->{'properties'} ) ) {
		foreach
		  my $key ( sort( keys( %{ $value->{'properties'}{'property'} } ) ) )
		{
			if ( ref( $value->{'properties'}{'property'}{$key} ) eq 'HASH'
				&& defined( $value->{'properties'}{'property'}{$key}{'value'} )
			  )
			{
				print "\t", $key, "\t",
				  $value->{'properties'}{'property'}{$key}{'value'}, "\n";
			}
			else {
				print "\t", $value->{'properties'}{'property'}{'key'},
				  "\t", $value->{'properties'}{'property'}{'value'}, "\n";
				last;
			}
		}
	}
}

=head2 print_job_status()

Print status of a job.

  &print_job_status($job_id);

=cut

sub print_job_status {
	print_debug_message( 'print_job_status', 'Begin', 1 );
	my $jobid = shift;
	print_debug_message( 'print_job_status', 'jobid: ' . $jobid, 1 );
	if ( $outputLevel > 0 ) {
		print STDERR 'Getting status for job ', $jobid, "\n";
	}
	my $result = &rest_get_status($jobid);
	print "$result\n";
	if ( $result eq 'FINISHED' && $outputLevel > 0 ) {
		print STDERR "To get results: $scriptName --polljob --jobid " . $jobid
		  . "\n";
	}
	print_debug_message( 'print_job_status', 'End', 1 );
}

=head2 print_result_types()

Print available result types for a job.

  &print_result_types($job_id);

=cut

sub print_result_types {
	print_debug_message( 'result_types', 'Begin', 1 );
	my $jobid = shift;
	print_debug_message( 'result_types', 'jobid: ' . $jobid, 1 );
	if ( $outputLevel > 0 ) {
		print STDERR 'Getting result types for job ', $jobid, "\n";
	}
	my $status = &rest_get_status($jobid);
	if ( $status eq 'PENDING' || $status eq 'RUNNING' ) {
		print STDERR 'Error: Job status is ', $status,
		  '. To get result types the job must be finished.', "\n";
	}
	else {
		my (@resultTypes) = &rest_get_result_types($jobid);
		if ( $outputLevel > 0 ) {
			print STDOUT 'Available result types:', "\n";
		}
		foreach my $resultType (@resultTypes) {
			print STDOUT $resultType->{'identifier'}, "\n";
			if ( defined( $resultType->{'label'} ) ) {
				print STDOUT "\t", $resultType->{'label'}, "\n";
			}
			if ( defined( $resultType->{'description'} ) ) {
				print STDOUT "\t", $resultType->{'description'}, "\n";
			}
			if ( defined( $resultType->{'mediaType'} ) ) {
				print STDOUT "\t", $resultType->{'mediaType'}, "\n";
			}
			if ( defined( $resultType->{'fileSuffix'} ) ) {
				print STDOUT "\t", $resultType->{'fileSuffix'}, "\n";
			}
		}
		if ( $status eq 'FINISHED' && $outputLevel > 0 ) {
			print STDERR "\n", 'To get results:', "\n",
			  "  $scriptName --polljob --jobid " . $params{'jobid'} . "\n",
			  "  $scriptName --polljob --outformat <type> --jobid "
			  . $params{'jobid'} . "\n";
		}
	}
	print_debug_message( 'result_types', 'End', 1 );
}

=head2 submit_job()

Submit a job to the service.

  &submit_job($seq);

=cut

sub submit_job {
	print_debug_message( 'submit_job', 'Begin', 1 );

	# Set input sequence
	$tool_params{'sequence'} = shift;

	# Load parameters
	&load_params();

	# Submit the job
	my $jobid = &rest_run( $params{'email'}, $params{'title'}, \%tool_params );

	# Simulate sync/async mode
	if ( defined( $params{'async'} ) ) {
		print STDOUT $jobid, "\n";
		if ( $outputLevel > 0 ) {
			print STDERR
			  "To check status: $scriptName --status --jobid $jobid\n";
		}
	}
	else {
		if ( $outputLevel > 0 ) {
			print STDERR "JobId: $jobid\n";
		}
		sleep 1;
		&get_results($jobid);
	}
	print_debug_message( 'submit_job', 'End', 1 );
}

=head2 multi_submit_job()

Submit multiple jobs assuming input is a collection of fasta formatted sequences.

  &multi_submit_job();

=cut

sub multi_submit_job {
	print_debug_message( 'multi_submit_job', 'Begin', 1 );
	my $jobIdForFilename = 1;
	$jobIdForFilename = 0 if ( defined( $params{'outfile'} ) );
	my (@filename_list) = ();

	# Query sequence
	if ( defined( $ARGV[0] ) ) {    # Bare option
		if ( -f $ARGV[0] || $ARGV[0] eq '-' ) {    # File
			push( @filename_list, $ARGV[0] );
		}
		else {
			warn 'Warning: Input file "' . $ARGV[0] . '" does not exist'
		}
	}
	if ( $params{'sequence'} ) {                   # Via --sequence
		if ( -f $params{'sequence'} || $params{'sequence'} eq '-' ) {    # File
			push( @filename_list, $params{'sequence'} );
		}
		else {
			warn 'Warning: Input file "' . $params{'sequence'} . '" does not exist'
		}
	}

	$/ = '>';
	foreach my $filename (@filename_list) {
		my $INFILE;
		if($filename eq '-') { # STDIN.
			open( $INFILE, '<-' )
			  or die 'Error: unable to STDIN (' . $! . ')';
		} else { # File.
			open( $INFILE, '<', $filename )
			  or die 'Error: unable to open file ' . $filename . ' (' . $! . ')';
		}
		while (<$INFILE>) {
			my $seq = $_;
			$seq =~ s/>$//;
			if ( $seq =~ m/(\S+)/ ) {
				print STDERR "Submitting job for: $1\n"
				  if ( $outputLevel > 0 );
				$seq = '>' . $seq;
				&print_debug_message( 'multi_submit_job', $seq, 11 );
				&submit_job($seq);
				$params{'outfile'} = undef if ( $jobIdForFilename == 1 );
			}
		}
		close $INFILE;
	}
	print_debug_message( 'multi_submit_job', 'End', 1 );
}

=head2 list_file_submit_job()

Submit multiple jobs using a file containing a list of entry identifiers as 
input.

  &list_file_submit_job($list_filename)

=cut

sub list_file_submit_job {
	my $filename         = shift;
	my $jobIdForFilename = 1;
	$jobIdForFilename = 0 if ( defined( $params{'outfile'} ) );

	# Iterate over identifiers, submitting each job
	my $LISTFILE;
	if($filename eq '-') { # STDIN.
		open( $LISTFILE, '<-' )
		  or die 'Error: unable to STDIN (' . $! . ')';
	} else { # File.
		open( $LISTFILE, '<', $filename )
		  or die 'Error: unable to open file ' . $filename . ' (' . $! . ')';
	}
	while (<$LISTFILE>) {
		my $line = $_;
		chomp($line);
		if ( $line ne '' ) {
			&print_debug_message( 'list_file_submit_job', 'line: ' . $line, 2 );
			if ( $line =~ m/\w:\w/ ) {    # Check this is an identifier
				print STDERR "Submitting job for: $line\n"
				  if ( $outputLevel > 0 );
				&submit_job($line);
			}
			else {
				print STDERR
"Warning: line \"$line\" is not recognised as an identifier\n";
			}
		}
		$params{'outfile'} = undef if ( $jobIdForFilename == 1 );
	}
	close $LISTFILE;
}

=head2 load_data()

Load sequence data from file or option specified on the command-line.

  &load_data();

=cut

sub load_data {
	print_debug_message( 'load_data', 'Begin', 1 );
	my $retSeq;

	# Query sequence
	if ( defined( $ARGV[0] ) ) {    # Bare option
		if ( -f $ARGV[0] || $ARGV[0] eq '-' ) {    # File
			$retSeq = &read_file( $ARGV[0] );
		}
		else {                                     # DB:ID or sequence
			$retSeq = $ARGV[0];
		}
	}
	if ( $params{'sequence'} ) {                   # Via --sequence
		if ( -f $params{'sequence'} || $params{'sequence'} eq '-' ) {    # File
			$retSeq = &read_file( $params{'sequence'} );
		}
		else {    # DB:ID or sequence
			$retSeq = $params{'sequence'};
		}
	}
	print_debug_message( 'load_data', 'End', 1 );
	return $retSeq;
}

=head2 load_params()

Load job parameters from command-line options.

  &load_params();

=cut

sub load_params {
	print_debug_message( 'load_params', 'Begin', 1 );

	# Database(s) to search
	my (@dbList) = split /[ ,]/, $params{'database'};
	$tool_params{'database'} = \@dbList;

	# Match/missmatch
	if ( $params{'match'} && $params{'missmatch'} ) {
		$tool_params{'match_scores'} =
		  $params{'match'} . ',' . $params{'missmatch'};
	}
	
	# Compatability options, old command-line
	if(!$tool_params{'alignments'} && $params{'numal'}) {
		$tool_params{'alignments'} = $params{'numal'};
	}
	if(!$tool_params{'gapopen'} && $params{'opengap'}) {
		$tool_params{'gapopen'} = $params{'opengap'};
	}
	if(!$tool_params{'gapext'} && $params{'extendgap'}) {
		$tool_params{'gapext'} = $params{'extendgap'};
	}

	print_debug_message( 'load_params', 'End', 1 );
}

=head2 client_poll()

Client-side job polling.

  &client_poll($job_id);

=cut

sub client_poll {
	print_debug_message( 'client_poll', 'Begin', 1 );
	my $jobid  = shift;
	my $status = 'PENDING';

	my $errorCount = 0;
	while ($status eq 'RUNNING'
		|| $status eq 'PENDING'
		|| ( $status eq 'ERROR' && $errorCount < 2 ) )
	{
		$status = rest_get_status($jobid);
		print STDERR "$status\n" if ( $outputLevel > 0 );
		if ( $status eq 'ERROR' ) {
			$errorCount++;
		}
		elsif ( $errorCount > 0 ) {
			$errorCount--;
		}
		if (   $status eq 'RUNNING'
			|| $status eq 'PENDING'
			|| $status eq 'ERROR' )
		{

			# Wait before polling again.
			sleep $checkInterval;
		}
	}
	print_debug_message( 'client_poll', 'End', 1 );
	return $status;
}

=head2 get_results()

Get the results for a job identifier.

  &get_results($job_id);

=cut

sub get_results {
	print_debug_message( 'get_results', 'Begin', 1 );
	my $jobid = shift;
	print_debug_message( 'get_results', 'jobid: ' . $jobid, 1 );

	# Verbose
	if ( $outputLevel > 1 ) {
		print 'Getting results for job ', $jobid, "\n";
	}

	# Check status, and wait if not finished
	client_poll($jobid);

	# Use JobId if output file name is not defined
	unless ( defined( $params{'outfile'} ) ) {
		$params{'outfile'} = $jobid;
	}

	# Get list of data types
	my (@resultTypes) = rest_get_result_types($jobid);

	# Get the data and write it to a file
	if ( defined( $params{'outformat'} ) ) {    # Specified data type
		my $selResultType;
		foreach my $resultType (@resultTypes) {
			if ( $resultType->{'identifier'} eq $params{'outformat'} ) {
				$selResultType = $resultType;
			}
		}
		if ( defined($selResultType) ) {
			my $result =
			  rest_get_result( $jobid, $selResultType->{'identifier'} );
			if ( $params{'outfile'} eq '-' ) {
				write_file( $params{'outfile'}, $result );
			}
			else {
				write_file(
					$params{'outfile'} . '.'
					  . $selResultType->{'identifier'} . '.'
					  . $selResultType->{'fileSuffix'},
					$result
				);
			}
		}
		else {
			die 'Error: unknown result format "' . $params{'outformat'} . '"';
		}
	}
	else {    # Data types available
		      # Write a file for each output type
		for my $resultType (@resultTypes) {
			if ( $outputLevel > 1 ) {
				print STDERR 'Getting ', $resultType->{'identifier'}, "\n";
			}
			my $result = rest_get_result( $jobid, $resultType->{'identifier'} );
			if ( $params{'outfile'} eq '-' ) {
				write_file( $params{'outfile'}, $result );
			}
			else {
				write_file(
					$params{'outfile'} . '.'
					  . $resultType->{'identifier'} . '.'
					  . $resultType->{'fileSuffix'},
					$result
				);
			}
		}
	}
	print_debug_message( 'get_results', 'End', 1 );
}

=head2 read_file()

Read a file into a scalar. The special filename '-' can be used to read from 
standard input (STDIN).

  my $data = &read_file($filename);

=cut

sub read_file {
	print_debug_message( 'read_file', 'Begin', 1 );
	my $filename = shift;
	print_debug_message( 'read_file', 'filename: ' . $filename, 2 );
	my ( $content, $buffer );
	if ( $filename eq '-' ) {
		while ( sysread( STDIN, $buffer, 1024 ) ) {
			$content .= $buffer;
		}
	}
	else {    # File
		open( my $FILE, '<', $filename )
		  or die "Error: unable to open input file $filename ($!)";
		while ( sysread( $FILE, $buffer, 1024 ) ) {
			$content .= $buffer;
		}
		close($FILE);
	}
	print_debug_message( 'read_file', 'End', 1 );
	return $content;
}

=head2 write_file()

Write data to a file. The special filename '-' can be used to write to 
standard output (STDOUT).

  &write_file($filename, $data);

=cut

sub write_file {
	print_debug_message( 'write_file', 'Begin', 1 );
	my ( $filename, $data ) = @_;
	print_debug_message( 'write_file', 'filename: ' . $filename, 2 );
	if ( $outputLevel > 0 ) {
		print STDERR 'Creating result file: ' . $filename . "\n";
	}
	if ( $filename eq '-' ) {
		print STDOUT $data;
	}
	else {
		open( my $FILE, '>', $filename )
		  or die "Error: unable to open output file $filename ($!)";
		syswrite( $FILE, $data );
		close($FILE);
	}
	print_debug_message( 'write_file', 'End', 1 );
}

=head2 usage()

Print program usage message.

  &usage();

=cut

sub usage {
	print STDERR <<EOF
NCBI BLAST
==========
   
Rapid sequence database search programs utilizing the BLAST algorithm
    
[Required]

  -p, --program      : str  : BLAST program to use, see --paramDetail program
  -D, --database     : str  : database(s) to search, space separated. See
                              --paramDetail database
      --stype        : str  : query sequence type, see --paramDetail stype
  seqFile            : file : query sequence ("-" for STDIN, \@filename for
                              identifier list file)

[Optional]

  -m, --matrix       : str  : scoring matrix, see --paramDetail matrix
  -e, --exp          : real : 0<E<= 1000. Statistical significance threshold 
                              for reporting database sequence matches.
  -f, --filter       :      : filter the query sequence for low complexity 
                              regions, see --paramDetail filter
  -A, --align        : int  : pairwise alignment format, see --paramDetail align
  -s, --scores       : int  : number of scores to be reported
  -n, --alignments   : int  : number of alignments to report
  -u, --match        : int  : Match score (BLASTN only)
  -v, --mismatch     : int  : Mismatch score (BLASTN only)
  -o, --gapopen      : int  : Gap open penalty
  -x, --gapext       : int  : Gap extension penalty
  -d, --dropoff      : int  : Drop-off
  -g, --gapalign     :      : Optimise gapped alignments
      --seqrange     : str  : region within input to use as query
      --multifasta   :      : treat input as a set of fasta formatted sequences

[General]

  -h, --help         :      : prints this help text
      --async        :      : forces to make an asynchronous query
      --email        : str  : e-mail address
      --title        : str  : title for job
      --status       :      : get job status
      --resultTypes  :      : get available result types for job
      --polljob      :      : poll for the status of a job
      --jobid        : str  : jobid that was returned when an asynchronous job 
                              was submitted.
      --outfile      : str  : file name for results (default is jobid;
                              "-" for STDOUT)
      --outformat    : str  : result format to retrieve
      --params       :      : list input parameters
      --paramDetail  : str  : display details for input parameter
      --quiet        :      : decrease output
      --verbose      :      : increase output
   
Synchronous job:

  The results/errors are returned as soon as the job is finished.
  Usage: $scriptName --email <your\@email> [options...] seqFile
  Returns: results as an attachment

Asynchronous job:

  Use this if you want to retrieve the results at a later time. The results 
  are stored for up to 24 hours. 	
  Usage: $scriptName --async --email <your\@email> [options...] seqFile
  Returns: jobid

  Use the jobid to query for the status of the job. If the job is finished, 
  it also returns the results/errors.
  Usage: $scriptName --polljob --jobid <jobId> [--outfile string]
  Returns: string indicating the status of the job and if applicable, results 
  as an attachment.

Further information:

  http://www.ebi.ac.uk/Tools/webservices/services/sss/ncbi_blast_rest
  http://www.ebi.ac.uk/Tools/webservices/tutorials/perl

Support/Feedback:

  http://www.ebi.ac.uk/support/
EOF
}

=head1 FEEDBACK/SUPPORT

Please contact us at L<http://www.ebi.ac.uk/support/> if you have any 
feedback, suggestions or issues with the service or this client.

=cut

</content>
</file>
<file>
<stream>output</stream>
<name>wublast_lwp.pl</name>
<content>#!/usr/bin/env perl

=head1 NAME

wublast_lwp.pl

=head1 DESCRIPTION

WU-BLAST (REST) web service Perl client using L<LWP>.

Tested with:

=over

=item *
L<LWP> 5.79, L<XML::Simple> 2.12 and Perl 5.8.3

=item *
L<LWP> 5.808, L<XML::Simple> 2.18 and Perl 5.8.8 (Ubuntu 8.04 LTS)

=item *
L<LWP> 5.834, L<XML::Simple> 2.18 and Perl 5.10.1 (Ubuntu 10.04 LTS)

=item *
L<LWP> 6.03, L<XML::Simple> 2.18 and Perl 5.14.2 (Ubuntu 12.04 LTS)

=back

For further information see:

=over

=item *
L<http://www.ebi.ac.uk/Tools/webservices/services/sss/wu_blast_rest>

=item *
L<http://www.ebi.ac.uk/Tools/webservices/tutorials/perl>

=back

=head1 LICENSE

Copyright 2012-2013 EMBL - European Bioinformatics Institute

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

=head1 VERSION

$Id: wublast_lwp.pl 2560 2013-03-20 12:56:31Z hpm $

=cut

use strict;
use warnings;

use English;
use LWP;
use XML::Simple;
use Getopt::Long qw(:config no_ignore_case bundling);
use File::Basename;
use Data::Dumper;

my $baseUrl = 'http://www.ebi.ac.uk/Tools/services/rest/wublast';

my $checkInterval = 3;

my $outputLevel = 1;

my $numOpts = scalar(@ARGV);
my %params = ( 'debugLevel' => 0 );

my %tool_params = ();
GetOptions(

	# Tool specific options
	'program|p=s'     => \$tool_params{'program'},      # BLAST program
	'database|D=s'    => \$params{'database'},     # Search database
	'matrix|m=s'      => \$tool_params{'matrix'},       # Scoring matrix
	'exp|E=f'         => \$tool_params{'exp'},          # E-value threshold
	'viewfilter|e'    => \$tool_params{'viewfilter'},   # Display filtered sequence
	'filter|f=s'      => \$tool_params{'filter'},       # Low complexity filter name
	'alignments|n=i'  => \$tool_params{'alignments'},   # Number of alignments
	'scores|s=i'      => \$tool_params{'scores'},       # Number of scores
	'sensitivity|S=s' => \$tool_params{'sensitivity'},  # Search sensitivity
	'sort|t=s'        => \$tool_params{'sort'},         # Sort hits by...
	'stats|T=s'       => \$tool_params{'stats'},        # Scoring statistic to use
	'strand|d=s'      => \$tool_params{'strand'},       # Strand to use
	'topcombon|c=i'   => \$tool_params{'topcombon'},    # Consistent sets of HSPs
	'align|A=i'       => \$tool_params{'align'},   # Pairwise alignment format
	'stype=s' => \$tool_params{'stype'},    # Sequence type 'protein' or 'dna'
	'sequence=s' => \$params{'sequence'},         # Query sequence file or DB:ID
	'multifasta' => \$params{'multifasta'},       # Multiple fasta input

	# Compatability options, old command-line.
	'echofilter|e'    => \$params{'echofilter'},   # Display filtered sequence
	'b=i'  => \$params{'numal'},        # Number of alignments
	'appxml=s'        => \$params{'appxml'},       # Application XML

	# Generic options
	'email=s'       => \$params{'email'},          # User e-mail address
	'title=s'       => \$params{'title'},          # Job title
	'outfile=s'     => \$params{'outfile'},        # Output file name
	'outformat=s'   => \$params{'outformat'},      # Output file type
	'jobid=s'       => \$params{'jobid'},          # JobId
	'help|h'        => \$params{'help'},           # Usage help
	'async'         => \$params{'async'},          # Asynchronous submission
	'polljob'       => \$params{'polljob'},        # Get results
	'resultTypes'   => \$params{'resultTypes'},    # Get result types
	'status'        => \$params{'status'},         # Get status
	'params'        => \$params{'params'},         # List input parameters
	'paramDetail=s' => \$params{'paramDetail'},    # Get details for parameter
	'quiet'         => \$params{'quiet'},          # Decrease output level
	'verbose'       => \$params{'verbose'},        # Increase output level
	'debugLevel=i'  => \$params{'debugLevel'},     # Debug output level
	'baseUrl=s'     => \$baseUrl,                  # Base URL for service.
);
if ( $params{'verbose'} ) { $outputLevel++ }
if ( $params{'quiet'} )  { $outputLevel-- }

&print_debug_message( 'MAIN', 'LWP::VERSION: ' . $LWP::VERSION,
	1 );

&print_debug_message( 'MAIN', "params:\n" . Dumper( \%params ),           11 );
&print_debug_message( 'MAIN', "tool_params:\n" . Dumper( \%tool_params ), 11 );

my $ua;

my $scriptName = basename( $0, () );

if ( $params{'help'} || $numOpts == 0 ) {
	&usage();
	exit(0);
}

&print_debug_message( 'MAIN', 'baseUrl: ' . $baseUrl, 1 );

if (
	!(
		   $params{'polljob'}
		|| $params{'resultTypes'}
		|| $params{'status'}
		|| $params{'params'}
		|| $params{'paramDetail'}
	)
	&& !( defined( $ARGV[0] ) || defined( $params{'sequence'} ) )
  )
{

	# Bad argument combination, so print error message and usage
	print STDERR 'Error: bad option combination', "\n";
	&usage();
	exit(1);
}

elsif ( $params{'params'} ) {
	&print_tool_params();
}

elsif ( $params{'paramDetail'} ) {
	&print_param_details( $params{'paramDetail'} );
}

elsif ( $params{'status'} && defined( $params{'jobid'} ) ) {
	&print_job_status( $params{'jobid'} );
}

elsif ( $params{'resultTypes'} && defined( $params{'jobid'} ) ) {
	&print_result_types( $params{'jobid'} );
}

elsif ( $params{'polljob'} && defined( $params{'jobid'} ) ) {
	&get_results( $params{'jobid'} );
}

else {

	# Multiple input sequence mode, assume fasta format.
	if ( $params{'multifasta'} ) {
		&multi_submit_job();
	}

	# Entry identifier list file.
	elsif (( defined( $params{'sequence'} ) && $params{'sequence'} =~ m/^\@/ )
		|| ( defined( $ARGV[0] ) && $ARGV[0] =~ m/^\@/ ) )
	{
		my $list_filename = $params{'sequence'} || $ARGV[0];
		$list_filename =~ s/^\@//;
		&list_file_submit_job($list_filename);
	}

	# Default: single sequence/identifier.
	else {

		# Load the sequence data and submit.
		&submit_job( &load_data() );
	}
}

=head1 FUNCTIONS

=cut


=head2 rest_user_agent()

Get a LWP UserAgent to use to perform REST requests.

  my $ua = &rest_user_agent();

=cut

sub rest_user_agent() {
	print_debug_message( 'rest_user_agent', 'Begin', 21 );
	# Create an LWP UserAgent for making HTTP calls.
	my $ua = LWP::UserAgent->new();
	# Set 'User-Agent' HTTP header to identifiy the client.
	'$Revision: 2560 $' =~ m/(\d+)/;
	$ua->agent("EBI-Sample-Client/$1 ($scriptName; $OSNAME) " . $ua->agent());
	# Configure HTTP proxy support from environment.
	$ua->env_proxy;
	print_debug_message( 'rest_user_agent', 'End', 21 );
	return $ua;
}

=head2 rest_error()

Check a REST response for an error condition. An error is mapped to a die.

  &rest_error($response, $content_data);

=cut

sub rest_error() {
	print_debug_message( 'rest_error', 'Begin', 21 );
	my $response = shift;
	my $contentdata;
	if(scalar(@_) > 0) {
		$contentdata = shift;
	}
	if(!defined($contentdata) || $contentdata eq '') {
		$contentdata = $response->content();
	}
	# Check for HTTP error codes
	if ( $response->is_error ) {
		my $error_message = '';
		# HTML response.
		if(	$contentdata =~ m/<h1>([^<]+)<\/h1>/ ) {
			$error_message = $1;
		}
		#  XML response.
		elsif($contentdata =~ m/<description>([^<]+)<\/description>/) {
			$error_message = $1;
		}
		die 'http status: ' . $response->code . ' ' . $response->message . '  ' . $error_message;
	}
	print_debug_message( 'rest_error', 'End', 21 );
}

=head2 rest_request()

Perform a REST request (HTTP GET).

  my $response_str = &rest_request($url);

=cut

sub rest_request {
	print_debug_message( 'rest_request', 'Begin', 11 );
	my $requestUrl = shift;
	print_debug_message( 'rest_request', 'URL: ' . $requestUrl, 11 );

	# Get an LWP UserAgent.
	$ua = &rest_user_agent() unless defined($ua);
	# Available HTTP compression methods.
	my $can_accept;
	eval {
	    $can_accept = HTTP::Message::decodable();
	};
	$can_accept = '' unless defined($can_accept);
	# Perform the request
	my $response = $ua->get($requestUrl,
		'Accept-Encoding' => $can_accept, # HTTP compression.
	);
	print_debug_message( 'rest_request', 'HTTP status: ' . $response->code,
		11 );
	print_debug_message( 'rest_request',
		'response length: ' . length($response->content()), 11 );
	print_debug_message( 'rest_request',
		'request:' ."\n" . $response->request()->as_string(), 32 );
	print_debug_message( 'rest_request',
		'response: ' . "\n" . $response->as_string(), 32 );
	# Unpack possibly compressed response.
	my $retVal;
	if ( defined($can_accept) && $can_accept ne '') {
	    $retVal = $response->decoded_content();
	}
	# If unable to decode use orginal content.
	$retVal = $response->content() unless defined($retVal);
	# Check for an error.
	&rest_error($response, $retVal);
	print_debug_message( 'rest_request', 'retVal: ' . $retVal, 12 );
	print_debug_message( 'rest_request', 'End', 11 );

	# Return the response data
	return $retVal;
}

=head2 rest_get_parameters()

Get list of tool parameter names.

  my (@param_list) = &rest_get_parameters();

=cut

sub rest_get_parameters {
	print_debug_message( 'rest_get_parameters', 'Begin', 1 );
	my $url                = $baseUrl . '/parameters/';
	my $param_list_xml_str = rest_request($url);
	my $param_list_xml     = XMLin($param_list_xml_str);
	my (@param_list)       = @{ $param_list_xml->{'id'} };
	print_debug_message( 'rest_get_parameters', 'End', 1 );
	return (@param_list);
}

=head2 rest_get_parameter_details()

Get details of a tool parameter.

  my $paramDetail = &rest_get_parameter_details($param_name);

=cut

sub rest_get_parameter_details {
	print_debug_message( 'rest_get_parameter_details', 'Begin', 1 );
	my $parameterId = shift;
	print_debug_message( 'rest_get_parameter_details',
		'parameterId: ' . $parameterId, 1 );
	my $url                  = $baseUrl . '/parameterdetails/' . $parameterId;
	my $param_detail_xml_str = rest_request($url);
	my $param_detail_xml     = XMLin($param_detail_xml_str);
	print_debug_message( 'rest_get_parameter_details', 'End', 1 );
	return ($param_detail_xml);
}

=head2 rest_run()

Submit a job.

  my $job_id = &rest_run($email, $title, \%params );

=cut

sub rest_run {
	print_debug_message( 'rest_run', 'Begin', 1 );
	my $email  = shift;
	my $title  = shift;
	my $params = shift;
	print_debug_message( 'rest_run', 'email: ' . $email, 1 );
	if ( defined($title) ) {
		print_debug_message( 'rest_run', 'title: ' . $title, 1 );
	}
	print_debug_message( 'rest_run', 'params: ' . Dumper($params), 1 );

	# Get an LWP UserAgent.
	$ua = &rest_user_agent() unless defined($ua);

	# Clean up parameters
	my (%tmp_params) = %{$params};
	$tmp_params{'email'} = $email;
	$tmp_params{'title'} = $title;
	foreach my $param_name ( keys(%tmp_params) ) {
		if ( !defined( $tmp_params{$param_name} ) ) {
			delete $tmp_params{$param_name};
		}
	}

	# Submit the job as a POST
	my $url = $baseUrl . '/run';
	my $response = $ua->post( $url, \%tmp_params );
	print_debug_message( 'rest_run', 'HTTP status: ' . $response->code, 11 );
	print_debug_message( 'rest_run',
		'request:' ."\n" . $response->request()->as_string(), 11 );
	print_debug_message( 'rest_run',
		'response: ' . length($response->as_string()) . "\n" . $response->as_string(), 11 );

	# Check for an error.
	&rest_error($response);

	# The job id is returned
	my $job_id = $response->content();
	print_debug_message( 'rest_run', 'End', 1 );
	return $job_id;
}

=head2 rest_get_status()

Check the status of a job.

  my $status = &rest_get_status($job_id);

=cut

sub rest_get_status {
	print_debug_message( 'rest_get_status', 'Begin', 1 );
	my $job_id = shift;
	print_debug_message( 'rest_get_status', 'jobid: ' . $job_id, 2 );
	my $status_str = 'UNKNOWN';
	my $url        = $baseUrl . '/status/' . $job_id;
	$status_str = &rest_request($url);
	print_debug_message( 'rest_get_status', 'status_str: ' . $status_str, 2 );
	print_debug_message( 'rest_get_status', 'End', 1 );
	return $status_str;
}

=head2 rest_get_result_types()

Get list of result types for finished job.

  my (@result_types) = &rest_get_result_types($job_id);

=cut

sub rest_get_result_types {
	print_debug_message( 'rest_get_result_types', 'Begin', 1 );
	my $job_id = shift;
	print_debug_message( 'rest_get_result_types', 'jobid: ' . $job_id, 2 );
	my (@resultTypes);
	my $url                      = $baseUrl . '/resulttypes/' . $job_id;
	my $result_type_list_xml_str = &rest_request($url);
	my $result_type_list_xml     = XMLin($result_type_list_xml_str);
	(@resultTypes) = @{ $result_type_list_xml->{'type'} };
	print_debug_message( 'rest_get_result_types',
		scalar(@resultTypes) . ' result types', 2 );
	print_debug_message( 'rest_get_result_types', 'End', 1 );
	return (@resultTypes);
}

=head2 rest_get_result()

Get result data of a specified type for a finished job.

  my $result = rest_get_result($job_id, $result_type);

=cut

sub rest_get_result {
	print_debug_message( 'rest_get_result', 'Begin', 1 );
	my $job_id = shift;
	my $type   = shift;
	print_debug_message( 'rest_get_result', 'jobid: ' . $job_id, 1 );
	print_debug_message( 'rest_get_result', 'type: ' . $type,    1 );
	my $url    = $baseUrl . '/result/' . $job_id . '/' . $type;
	my $result = &rest_request($url);
	print_debug_message( 'rest_get_result', length($result) . ' characters',
		1 );
	print_debug_message( 'rest_get_result', 'End', 1 );
	return $result;
}


=head2 print_debug_message()

Print debug message at specified debug level.

  &print_debug_message($method_name, $message, $level);

=cut

sub print_debug_message {
	my $function_name = shift;
	my $message       = shift;
	my $level         = shift;
	if ( $level <= $params{'debugLevel'} ) {
		print STDERR '[', $function_name, '()] ', $message, "\n";
	}
}

=head2 print_tool_params()

Print list of tool parameters.

  &print_tool_params();

=cut

sub print_tool_params {
	print_debug_message( 'print_tool_params', 'Begin', 1 );
	my (@param_list) = &rest_get_parameters();
	foreach my $param ( sort(@param_list) ) {
		print $param, "\n";
	}
	print_debug_message( 'print_tool_params', 'End', 1 );
}

=head2 print_param_details()

Print details of a tool parameter.

  &print_param_details($param_name);

=cut

sub print_param_details {
	print_debug_message( 'print_param_details', 'Begin', 1 );
	my $paramName = shift;
	print_debug_message( 'print_param_details', 'paramName: ' . $paramName, 2 );
	my $paramDetail = &rest_get_parameter_details($paramName);
	print $paramDetail->{'name'}, "\t", $paramDetail->{'type'}, "\n";
	print $paramDetail->{'description'}, "\n";
	if(defined($paramDetail->{'values'}->{'value'})) {
		if(ref($paramDetail->{'values'}->{'value'}) eq 'ARRAY') {
			foreach my $value ( @{ $paramDetail->{'values'}->{'value'} } ) {
				&print_param_value($value);
			}
		}
		else {
				&print_param_value($paramDetail->{'values'}->{'value'});
		}
	}
	print_debug_message( 'print_param_details', 'End', 1 );
}

=head2 print_param_value()

Print details of a tool parameter value.

  &print_param_details($param_value);

Used by print_param_details() to handle both singluar and array values.

=cut

sub print_param_value {
	my $value = shift;
	print $value->{'value'};
	if ( $value->{'defaultValue'} eq 'true' ) {
		print "\t", 'default';
	}
	print "\n";
	print "\t", $value->{'label'}, "\n";
	if ( defined( $value->{'properties'} ) ) {
		foreach
		  my $key ( sort( keys( %{ $value->{'properties'}{'property'} } ) ) )
		{
			if ( ref( $value->{'properties'}{'property'}{$key} ) eq 'HASH'
				&& defined( $value->{'properties'}{'property'}{$key}{'value'} )
			  )
			{
				print "\t", $key, "\t",
				  $value->{'properties'}{'property'}{$key}{'value'}, "\n";
			}
			else {
				print "\t", $value->{'properties'}{'property'}{'key'},
				  "\t", $value->{'properties'}{'property'}{'value'}, "\n";
				last;
			}
		}
	}
}

=head2 print_job_status()

Print status of a job.

  &print_job_status($job_id);

=cut

sub print_job_status {
	print_debug_message( 'print_job_status', 'Begin', 1 );
	my $jobid = shift;
	print_debug_message( 'print_job_status', 'jobid: ' . $jobid, 1 );
	if ( $outputLevel > 0 ) {
		print STDERR 'Getting status for job ', $jobid, "\n";
	}
	my $result = &rest_get_status($jobid);
	print "$result\n";
	if ( $result eq 'FINISHED' && $outputLevel > 0 ) {
		print STDERR "To get results: $scriptName --polljob --jobid " . $jobid
		  . "\n";
	}
	print_debug_message( 'print_job_status', 'End', 1 );
}

=head2 print_result_types()

Print available result types for a job.

  &print_result_types($job_id);

=cut

sub print_result_types {
	print_debug_message( 'result_types', 'Begin', 1 );
	my $jobid = shift;
	print_debug_message( 'result_types', 'jobid: ' . $jobid, 1 );
	if ( $outputLevel > 0 ) {
		print STDERR 'Getting result types for job ', $jobid, "\n";
	}
	my $status = &rest_get_status($jobid);
	if ( $status eq 'PENDING' || $status eq 'RUNNING' ) {
		print STDERR 'Error: Job status is ', $status,
		  '. To get result types the job must be finished.', "\n";
	}
	else {
		my (@resultTypes) = &rest_get_result_types($jobid);
		if ( $outputLevel > 0 ) {
			print STDOUT 'Available result types:', "\n";
		}
		foreach my $resultType (@resultTypes) {
			print STDOUT $resultType->{'identifier'}, "\n";
			if ( defined( $resultType->{'label'} ) ) {
				print STDOUT "\t", $resultType->{'label'}, "\n";
			}
			if ( defined( $resultType->{'description'} ) ) {
				print STDOUT "\t", $resultType->{'description'}, "\n";
			}
			if ( defined( $resultType->{'mediaType'} ) ) {
				print STDOUT "\t", $resultType->{'mediaType'}, "\n";
			}
			if ( defined( $resultType->{'fileSuffix'} ) ) {
				print STDOUT "\t", $resultType->{'fileSuffix'}, "\n";
			}
		}
		if ( $status eq 'FINISHED' && $outputLevel > 0 ) {
			print STDERR "\n", 'To get results:', "\n",
			  "  $scriptName --polljob --jobid " . $params{'jobid'} . "\n",
			  "  $scriptName --polljob --outformat <type> --jobid "
			  . $params{'jobid'} . "\n";
		}
	}
	print_debug_message( 'result_types', 'End', 1 );
}

=head2 submit_job()

Submit a job to the service.

  &submit_job($seq);

=cut

sub submit_job {
	print_debug_message( 'submit_job', 'Begin', 1 );

	# Set input sequence
	$tool_params{'sequence'} = shift;

	# Load parameters
	&load_params();

	# Submit the job
	my $jobid = &rest_run( $params{'email'}, $params{'title'}, \%tool_params );

	# Simulate sync/async mode
	if ( defined( $params{'async'} ) ) {
		print STDOUT $jobid, "\n";
		if ( $outputLevel > 0 ) {
			print STDERR
			  "To check status: $scriptName --status --jobid $jobid\n";
		}
	}
	else {
		if ( $outputLevel > 0 ) {
			print STDERR "JobId: $jobid\n";
		}
		sleep 1;
		&get_results($jobid);
	}
	print_debug_message( 'submit_job', 'End', 1 );
}

=head2 multi_submit_job()

Submit multiple jobs assuming input is a collection of fasta formatted sequences.

  &multi_submit_job();

=cut

sub multi_submit_job {
	print_debug_message( 'multi_submit_job', 'Begin', 1 );
	my $jobIdForFilename = 1;
	$jobIdForFilename = 0 if ( defined( $params{'outfile'} ) );
	my (@filename_list) = ();

	# Query sequence
	if ( defined( $ARGV[0] ) ) {    # Bare option
		if ( -f $ARGV[0] || $ARGV[0] eq '-' ) {    # File
			push( @filename_list, $ARGV[0] );
		}
		else {
			warn 'Warning: Input file "' . $ARGV[0] . '" does not exist'
		}
	}
	if ( $params{'sequence'} ) {                   # Via --sequence
		if ( -f $params{'sequence'} || $params{'sequence'} eq '-' ) {    # File
			push( @filename_list, $params{'sequence'} );
		}
		else {
			warn 'Warning: Input file "' . $params{'sequence'} . '" does not exist'
		}
	}

	$/ = '>';
	foreach my $filename (@filename_list) {
		my $INFILE;
		if($filename eq '-') { # STDIN.
			open( $INFILE, '<-' )
			  or die 'Error: unable to STDIN (' . $! . ')';
		} else { # File.
			open( $INFILE, '<', $filename )
			  or die 'Error: unable to open file ' . $filename . ' (' . $! . ')';
		}
		while (<$INFILE>) {
			my $seq = $_;
			$seq =~ s/>$//;
			if ( $seq =~ m/(\S+)/ ) {
				print STDERR "Submitting job for: $1\n"
				  if ( $outputLevel > 0 );
				$seq = '>' . $seq;
				&print_debug_message( 'multi_submit_job', $seq, 11 );
				&submit_job($seq);
				$params{'outfile'} = undef if ( $jobIdForFilename == 1 );
			}
		}
		close $INFILE;
	}
	print_debug_message( 'multi_submit_job', 'End', 1 );
}

=head2 list_file_submit_job()

Submit multiple jobs using a file containing a list of entry identifiers as 
input.

  &list_file_submit_job($list_filename)

=cut

sub list_file_submit_job {
	print_debug_message( 'list_file_submit_job', 'Begin', 11 );
	my $filename         = shift;
	my $jobIdForFilename = 1;
	$jobIdForFilename = 0 if ( defined( $params{'outfile'} ) );

	# Iterate over identifiers, submitting each job
	my $LISTFILE;
	if($filename eq '-') { # STDIN.
		open( $LISTFILE, '<-' )
		  or die 'Error: unable to STDIN (' . $! . ')';
	} else { # File.
		open( $LISTFILE, '<', $filename )
		  or die 'Error: unable to open file ' . $filename . ' (' . $! . ')';
	}
	while (<$LISTFILE>) {
		my $line = $_;
		chomp($line);
		if ( $line ne '' ) {
			&print_debug_message( 'list_file_submit_job', 'line: ' . $line, 2 );
			if ( $line =~ m/\w:\w/ ) {    # Check this is an identifier
				print STDERR "Submitting job for: $line\n"
				  if ( $outputLevel > 0 );
				&submit_job($line);
			}
			else {
				print STDERR
"Warning: line \"$line\" is not recognised as an identifier\n";
			}
		}
		$params{'outfile'} = undef if ( $jobIdForFilename == 1 );
	}
	close $LISTFILE;
	print_debug_message( 'list_file_submit_job', 'End', 11 );
}

=head2 load_data()

Load sequence data from file or option specified on the command-line.

  &load_data();

=cut

sub load_data {
	print_debug_message( 'load_data', 'Begin', 1 );
	my $retSeq;

	# Query sequence
	if ( defined( $ARGV[0] ) ) {    # Bare option
		if ( -f $ARGV[0] || $ARGV[0] eq '-' ) {    # File
			$retSeq = &read_file( $ARGV[0] );
		}
		else {                                     # DB:ID or sequence
			$retSeq = $ARGV[0];
		}
	}
	if ( $params{'sequence'} ) {                   # Via --sequence
		if ( -f $params{'sequence'} || $params{'sequence'} eq '-' ) {    # File
			$retSeq = &read_file( $params{'sequence'} );
		}
		else {    # DB:ID or sequence
			$retSeq = $params{'sequence'};
		}
	}
	print_debug_message( 'load_data', 'End', 1 );
	return $retSeq;
}

=head2 load_params()

Load job parameters from command-line options.

  &load_params();

=cut

sub load_params {
	print_debug_message( 'load_params', 'Begin', 1 );

	# Database(s) to search
	my (@dbList) = split /[ ,]/, $params{'database'};
	$tool_params{'database'} = \@dbList;

	# Compatability options, old command-line.
	if(!$tool_params{'viewfilter'} && $params{'echofilter'}) {
		$tool_params{'viewfilter'} = 'true';
	}
	if(!$tool_params{'alignments'} && $params{'numal'}) {
		$tool_params{'alignments'} = $params{'numal'};
	}
	# TODO: set alignment format option to get NCBI BLAST XML.
	if($params{'appxml'}) {
		$tool_params{'align'} = '';
	}

	print_debug_message( 'load_params', 'End', 1 );
}

=head2 client_poll()

Client-side job polling.

  &client_poll($job_id);

=cut

sub client_poll {
	print_debug_message( 'client_poll', 'Begin', 1 );
	my $jobid  = shift;
	my $status = 'PENDING';

	my $errorCount = 0;
	while ($status eq 'RUNNING'
		|| $status eq 'PENDING'
		|| ( $status eq 'ERROR' && $errorCount < 2 ) )
	{
		$status = rest_get_status($jobid);
		print STDERR "$status\n" if ( $outputLevel > 0 );
		if ( $status eq 'ERROR' ) {
			$errorCount++;
		}
		elsif ( $errorCount > 0 ) {
			$errorCount--;
		}
		if (   $status eq 'RUNNING'
			|| $status eq 'PENDING'
			|| $status eq 'ERROR' )
		{

			# Wait before polling again.
			sleep $checkInterval;
		}
	}
	print_debug_message( 'client_poll', 'End', 1 );
	return $status;
}

=head2 get_results()

Get the results for a job identifier.

  &get_results($job_id);

=cut

sub get_results {
	print_debug_message( 'get_results', 'Begin', 1 );
	my $jobid = shift;
	print_debug_message( 'get_results', 'jobid: ' . $jobid, 1 );

	# Verbose
	if ( $outputLevel > 1 ) {
		print 'Getting results for job ', $jobid, "\n";
	}

	# Check status, and wait if not finished
	client_poll($jobid);

	# Use JobId if output file name is not defined
	unless ( defined( $params{'outfile'} ) ) {
		$params{'outfile'} = $jobid;
	}

	# Get list of data types
	my (@resultTypes) = rest_get_result_types($jobid);

	# Get the data and write it to a file
	if ( defined( $params{'outformat'} ) ) {    # Specified data type
		my $selResultType;
		foreach my $resultType (@resultTypes) {
			if ( $resultType->{'identifier'} eq $params{'outformat'} ) {
				$selResultType = $resultType;
			}
		}
		if ( defined($selResultType) ) {
			my $result =
			  rest_get_result( $jobid, $selResultType->{'identifier'} );
			if ( $params{'outfile'} eq '-' ) {
				write_file( $params{'outfile'}, $result );
			}
			else {
				write_file(
					$params{'outfile'} . '.'
					  . $selResultType->{'identifier'} . '.'
					  . $selResultType->{'fileSuffix'},
					$result
				);
			}
		}
		else {
			die 'Error: unknown result format "' . $params{'outformat'} . '"';
		}
	}
	else {    # Data types available
		      # Write a file for each output type
		for my $resultType (@resultTypes) {
			if ( $outputLevel > 1 ) {
				print STDERR 'Getting ', $resultType->{'identifier'}, "\n";
			}
			my $result = rest_get_result( $jobid, $resultType->{'identifier'} );
			if ( $params{'outfile'} eq '-' ) {
				write_file( $params{'outfile'}, $result );
			}
			else {
				write_file(
					$params{'outfile'} . '.'
					  . $resultType->{'identifier'} . '.'
					  . $resultType->{'fileSuffix'},
					$result
				);
			}
		}
	}
	print_debug_message( 'get_results', 'End', 1 );
}

=head2 read_file()

Read a file into a scalar. The special filename '-' can be used to read from 
standard input (STDIN).

  my $data = &read_file($filename);

=cut

sub read_file {
	print_debug_message( 'read_file', 'Begin', 1 );
	my $filename = shift;
	print_debug_message( 'read_file', 'filename: ' . $filename, 2 );
	my ( $content, $buffer );
	if ( $filename eq '-' ) {
		while ( sysread( STDIN, $buffer, 1024 ) ) {
			$content .= $buffer;
		}
	}
	else {    # File
		open( my $FILE, '<', $filename )
		  or die "Error: unable to open input file $filename ($!)";
		while ( sysread( $FILE, $buffer, 1024 ) ) {
			$content .= $buffer;
		}
		close($FILE);
	}
	print_debug_message( 'read_file', 'End', 1 );
	return $content;
}

=head2 write_file()

Write data to a file. The special filename '-' can be used to write to 
standard output (STDOUT).

  &write_file($filename, $data);

=cut

sub write_file {
	print_debug_message( 'write_file', 'Begin', 1 );
	my ( $filename, $data ) = @_;
	print_debug_message( 'write_file', 'filename: ' . $filename, 2 );
	if ( $outputLevel > 0 ) {
		print STDERR 'Creating result file: ' . $filename . "\n";
	}
	if ( $filename eq '-' ) {
		print STDOUT $data;
	}
	else {
		open( my $FILE, '>', $filename )
		  or die "Error: unable to open output file $filename ($!)";
		syswrite( $FILE, $data );
		close($FILE);
	}
	print_debug_message( 'write_file', 'End', 1 );
}

=head2 usage()

Print program usage message.

  &usage();

=cut

sub usage {
	print STDERR <<EOF
WU-BLAST
========
   
Rapid sequence database search programs utilizing the BLAST algorithm
    
[Required]

  -p, --program      : str  : BLAST program to use, see --paramDetail program
  -D, --database     : str  : database(s) to search, space separated. See
                              --paramDetail database
      --stype        : str  : query sequence type, see --paramDetail stype
  seqFile            : file : query sequence ("-" for STDIN, \@filename for
                              identifier list file)

[Optional]

  -m, --matrix       : str  : scoring matrix, see --paramDetail matrix
  -e, --exp          : real : 0<E<= 1000. Statistical significance threshold 
                              for reporting database sequence matches.
  -e, --viewfilter   :      : display the filtered query sequence
  -f, --filter       : str  : filter the query sequence for low complexity 
                              regions, see --paramDetail filter
  -A, --align        : int  : pairwise alignment format, see --paramDetail align
  -s, --scores       : int  : number of scores to be reported
  -b, --alignments   : int  : number of alignments to report
  -S, --sensitivity  : str  : sensitivity of the search, 
                              see --paramDetail sensitivity
  -t, --sort	     : str  : sort order for hits, see --paramDetail sort
  -T, --stats        : str  : statistical model, see --paramDetail stats
  -d, --strand       : str  : DNA strand to search with,
                              see --paramDetail strand
  -c, --topcombon    : str  : consistent sets of HSPs
      --multifasta   :      : treat input as a set of fasta formatted sequences

[General]

  -h, --help         :      : prints this help text
      --async        :      : forces to make an asynchronous query
      --email        : str  : e-mail address
      --title        : str  : title for job
      --status       :      : get job status
      --resultTypes  :      : get available result types for job
      --polljob      :      : poll for the status of a job
      --jobid        : str  : jobid that was returned when an asynchronous job 
                              was submitted.
      --outfile      : str  : file name for results (default is jobid;
                              "-" for STDOUT)
      --outformat    : str  : result format to retrieve
      --params       :      : list input parameters
      --paramDetail  : str  : display details for input parameter
      --quiet        :      : decrease output
      --verbose      :      : increase output
   
Synchronous job:

  The results/errors are returned as soon as the job is finished.
  Usage: $scriptName --email <your\@email> [options...] seqFile
  Returns: results as an attachment

Asynchronous job:

  Use this if you want to retrieve the results at a later time. The results 
  are stored for up to 24 hours. 	
  Usage: $scriptName --async --email <your\@email> [options...] seqFile
  Returns: jobid

  Use the jobid to query for the status of the job. If the job is finished, 
  it also returns the results/errors.
  Usage: $scriptName --polljob --jobid <jobId> [--outfile string]
  Returns: string indicating the status of the job and if applicable, results 
  as an attachment.

Further information:

  http://www.ebi.ac.uk/Tools/webservices/services/sss/wu_blast_rest
  http://www.ebi.ac.uk/Tools/webservices/tutorials/perl

Support/Feedback:

  http://www.ebi.ac.uk/support/
EOF
}

=head1 FEEDBACK/SUPPORT

Please contact us at L<http://www.ebi.ac.uk/support/> if you have any 
feedback, suggestions or issues with the service or this client.

=cut

</content>
</file>
<file>
<stream>output</stream>
<name>RNAplfold2tclib.pl</name>
<content>#!/usr/bin/env perl



my $PROBTRESH = 0.3;# base pairs below this prob threshold will be ignored
my $WEIGHT = 100.0; # float!!
my $NUCALPH = "ACGTUNRYMKSWHBVD";
use vars qw($NUCALPH $WEIGHT);

my $myname = basename($0);

use strict;
use warnings;

use File::Basename;
use Getopt::Long;
use File::Glob ':glob';
use File::Spec;
use File::Temp qw/ tempfile tempdir /;




sub tcoffeelib_header($;$)
{
    my ($nseq, $fd) = @_;
    if (! defined($fd)) {
        $fd = *STDOUT;
    }
    printf $fd "! TC_LIB_FORMAT_01\n";
    printf $fd "%d\n", $nseq;
}


sub tcoffeelib_header_addseq($$;$)
{
    my ($id, $seq, $fd) = @_;
    if (! defined($fd)) {
        $fd = *STDOUT;
    }
    printf $fd "%s %d %s\n", $id, length($seq), $seq;
}


sub tcoffeelib_comment($;$)
{
    my ($comment, $fd) = @_;
    if (! defined($fd)) {
        $fd = *STDOUT;
    }
    printf $fd "!" . $comment . "\n";
}


sub tcoffeelib_struct($$$;$)
{
    my ($nseq, $len, $bpm, $fd) = @_;

    if (! defined($fd)) {
        $fd = *STDOUT;
    }

    # output basepair indices with fixed weight
    printf $fd "#%d %d\n", $nseq, $nseq;
    # output basepairs (only once) and with unit-offset
    for (my $i=0; $i<$len; $i++) {
        for (my $j=$i+1; $j<$len; $j++) {
            if (! defined($bpm->[$i][$j])) {
                print STDERR "ERROR: \$bpm->[$i][$j] undefined\n";
            }
            if ($bpm->[$i][$j]>0) {
                print $fd $i+1;
                print $fd " ";
                print $fd $j+1;
                print $fd " " . $bpm->[$i][$j] . "\n";
            }
        }
    }
}


sub tcoffeelib_footer(;$)
{
    my ($fd) = @_;
    if (! defined($fd)) {
        $fd = *STDOUT;
    }
    print $fd "! SEQ_1_TO_N\n";
}


    
sub plfold($$$)
{    
    my ($id, $seq, $probtresh) = @_;
    my (@struct);# return
    my ($templ, $fhtmp, $fnametmp, $cmd, $ctr, $window_size);
    our $ntemp++;
    
    $templ = $myname . ".pid-" . $$ .$ntemp .".XXXXXX";
    ($fhtmp, $fnametmp) = tempfile($templ, UNLINK => 1); 
    print $fhtmp ">$id\n$seq\n";

    # --- init basepair array
    #
    for (my $i=0; $i<length($seq); $i++) {
        for (my $j=$i+1; $j<length($seq); $j++) {
            $struct[$i][$j]=0;
        }
    }


    # --- call rnaplfold and drop a readme
    #
    $window_size=(length($seq)<70)?length($seq):70;
    $cmd = "RNAplfold -W $window_size < $fnametmp >/dev/null";
    system($cmd);
    
    if ($? != 0) {
        printf STDERR "ERROR: RNAplfold ($cmd) exited with error status %d\n", $? >> 8;
        return;
    }
    #unlink($fnametmp);
    my $fps = sprintf("%s_dp.ps", $id); # check long name
    
    if (! -s $fps) {
      {

	$fps = sprintf("%s_dp.ps", substr($id,0,12)); # check short name
 	if (! -s $fps)
	  {
	    die("couldn't find expected file $fps\n");
	    return;
	  }
      }
    }

    
    # --- read base pairs from created postscript
    #
    open(FH, $fps);
    while (my $line = <FH>) {
        my ($nti, $ntj, $prob);
        chomp($line);        
        # line: bp bp sqrt-prob ubox
        my @match = ($line =~ m/^([0-9]+) +([0-9]+) +([0-9\.]+) +ubox$/);
        if (scalar(@match)) {
            $nti=$1;
            $ntj=$2;
            $prob=$3*$3;# prob stored as square root

            if ($prob>$probtresh) {
                #printf STDERR "\$struct[$nti][$ntj] sqrtprob=$3 prob=$prob > $probtresh\n";
                $struct[$nti-1][$ntj-1] = $WEIGHT
            }
            # store with zero-offset
        }
    }
    close(FH);

    # remove or gzi postscript
    #
    unlink($fps);
    #
    # or gzip
    #$cmd = "gzip -qf $fps";
    #system($cmd);
    #if ($? != 0) {
    #    printf STDERR "ERROR: gzip ($cmd) exited with error status %d\n", $? >> 8;
    #}

    return \@struct;
}





sub rnaseqfmt($)
{
    my ($seq) = @_;
    # remove gaps
    $seq =~ s/-//g;
    # uppercase RNA
    $seq = uc($seq);
    # T -> U
    $seq =~ s/T/U/g;
    # check for invalid charaters
    $_ = $seq;
    s/[^$NUCALPH]//g;
    return $_;
}




sub usage(;$)
{    
    my ($errmsg) = @_;
    if ($errmsg) {
        print STDERR "ERROR: $errmsg\n";
    }
    print STDERR << "EOF";
$myname:
 Creates a T-Coffee RNA structure library from RNAplfold prediction.
 See FIXME:citation
Usage:
 $myname -in seq_file -out tcoffee_lib
EOF
    exit(1);
}

sub read_fasta_seq 
  {
    my $f=$_[0];
    my %hseq;
    my (@seq, @com, @name);
    my ($a, $s,$nseq);

    open (F, $f);
    while (<F>)
      {
	$s.=$_;
      }
    close (F);

    
    @name=($s=~/>(\S*).*\n[^>]*/g);
    
    @seq =($s=~/>.*.*\n([^>]*)/g);
    @com =($s=~/>(\S*)(.*)\n([^>]*)/g);


    $nseq=$#name+1;
  
    for ($a=0; $a<$nseq; $a++)
      {
	my $n=$name[$a];
	my $s;
	$hseq{$n}{name}=$n;
	$s=$seq[$a];$s=~s/\s//g;
	
	$hseq{$n}{seq}=$s;
	$hseq{$n}{com}=$com[$a];
      }
    return %hseq;
  }







my $fmsq = "";
my $flib = "";
my %OPTS;
my %seq;
my ($id, $nseq, $i);
my @nl;

GetOptions("in=s" => \$fmsq, "out=s" => \$flib);

if (! -s $fmsq) {
    usage("empty or non-existant file \"$fmsq\"")
}
if (length($flib)==0) {
    usage("empty out-filename")
}






%seq=read_fasta_seq($fmsq);


@nl=keys(%seq);

$nseq=$#nl+1;
open FD_LIB, ">$flib" or die "can't open $flib!";
tcoffeelib_header($nseq, *FD_LIB);
foreach $id (keys (%seq))
  {
    my ($seq, $fmtseq);
    
    $seq = $seq{$id}{seq};
    
    $fmtseq = rnaseqfmt($seq);# check here, formatting for folding important later
    if (length($seq)!=length($fmtseq)) {
        print STDERR "ERROR: invalid sequence $id is not an RNA sequence. read seq is: $seq\n";
        exit
      }
   
    tcoffeelib_header_addseq($id, uc($seq), *FD_LIB);
  }
tcoffeelib_comment("generated by $myname on " . localtime(), *FD_LIB);



$i=0;
foreach $id (keys (%seq))
  {
    my ($cleanid, $seq, $bpm);
    $seq=$seq{$id}{seq};
    $cleanid = $id;
    $cleanid =~ s,[/ ],_,g;# needed for rnaplfold
    $seq = rnaseqfmt($seq);
    
    $bpm = plfold($cleanid, rnaseqfmt($seq), $PROBTRESH);       
    
    tcoffeelib_struct($i+1, length($seq), $bpm, *FD_LIB);
    $i++;
}


tcoffeelib_footer(*FD_LIB);
close FD_LIB;
exit (0);


</content>
</file>
<file>
<stream>output</stream>
<name>fasta_seq2RNAplfold_templatefile.pl</name>
<content>#!/usr/bin/env perl





$cmd=join ' ', @ARGV;
if ($cmd=~/-infile=(\S+)/){ $seqfile=$1;}
if ($cmd=~/-outfile=(\S+)/){ $libfile=$1;}



%s=read_fasta_seq ($seqfile);

open (F, ">$libfile");
foreach $name (keys (%s))
  {
    my $tclib="$name.RNAplfold_tclib";
    print (F ">$name _F_ $tclib\n");
    seq2RNAplfold2tclib ($name, $s{$name}{seq}, $tclib);
  }
close (F);
exit (EXIT_SUCCESS);

sub seq2RNAplfold2tclib
  {
    my ($name, $seq, $tclib)=@_;
    my ($tmp);
    $n++;
    $tmp="tmp4seq2RNAplfold_tclib.$$.$n.pep";
    open (RF, ">$tmp");
    print (RF ">$name\n$seq\n");
    close (RF);
    
    system "t_coffee -other_pg RNAplfold2tclib.pl -in=$tmp -out=$tclib";
    
    unlink ($tmp);
    return $tclib;
  }
    
    
sub read_fasta_seq 
  {
    my $f=@_[0];
    my %hseq;
    my (@seq, @com, @name);
    my ($a, $s,$nseq);

    open (F, $f);
    while (<F>)
      {
	$s.=$_;
      }
    close (F);

    
    @name=($s=~/>(\S*).*\n[^>]*/g);
    
    @seq =($s=~/>.*.*\n([^>]*)/g);
    @com =($s=~/>\S*(.*)\n([^>]*)/g);

    
    $nseq=$#name+1;
    
    for ($a=0; $a<$nseq; $a++)
      {
	my $n=$name[$a];
	$hseq{$n}{name}=$n;
	$hseq{$n}{seq}=$seq[$a];
	$hseq{$n}{com}=$com[$a];
      }
    return %hseq;
  }

</content>
</file>
<file>
<stream>output</stream>
<name>fasta_seq2hmmtop_fasta.pl</name>
<content>#!/usr/bin/env perl
use Getopt::Long;
use File::Path;
use Env;
use FileHandle;
use Cwd;
use Sys::Hostname;
our $PIDCHILD;
our $ERROR_DONE;
our @TMPFILE_LIST;
our $EXIT_FAILURE=1;
our $EXIT_SUCCESS=0;

our $REFDIR=getcwd;
our $EXIT_SUCCESS=0;
our $EXIT_FAILURE=1;

our $PROGRAM="tc_generic_method.pl";
our $CL=$PROGRAM;

our $CLEAN_EXIT_STARTED;
our $debug_lock=$ENV{"DEBUG_LOCK"};
our $LOCKDIR=$ENV{"LOCKDIR_4_TCOFFEE"};
if (!$LOCKDIR){$LOCKDIR=getcwd();}
our $ERRORDIR=$ENV{"ERRORDIR_4_TCOFFEE"};
our $ERRORFILE=$ENV{"ERRORFILE_4_TCOFFEE"};
&set_lock ($$);
if (isshellpid(getppid())){lock4tc(getppid(), "LLOCK", "LSET", "$$\n");}
      
our $print;
my ($fmsq1, $fmsq2, $output, $outfile, $arch, $psv, $hmmtop_home, $trim, $cov, $sample, $mode, $gor_home, $gor_seq, $gor_obs);

GetOptions("-in=s" => \$fmsq1,"-output=s" =>\$output ,"-out=s" => \$outfile, "-arch=s" => \$arch,"-psv=s" => \$psv, "-hmmtop_home=s", \$hmmtop_home,"-trim=s" =>\$trim ,"-print=s" =>\$print,"-cov=s" =>\$cov , "-sample=s" =>\$sample, "-mode=s" =>\$mode, "-gor_home=s"=>\$gor_home, "-gor_seq=s"=>\$gor_seq,"-gor_obs=s"=>\$gor_obs);


if (!$mode){$mode = "hmmtop"}
elsif ($mode eq "hmmtop"){;}
elsif ($mode eq "gor"){;}
else {myexit(flush_error ("-mode=$mode is unknown"));}


our $HOME=$ENV{"HOME"};
our $MCOFFEE=($ENV{"MCOFFEE_4_TCOFFEE"})?$ENV{"MCOFFEE_4_TCOFFEE"}:"$HOME/.t_coffee/mcoffee";

if ($mode eq "hmmtop")
  {
    
    check_configuration ("hmmtop");
    if (-e $arch){$ENV{'HMMTOP_ARCH'}=$arch;}
    elsif (-e $ENV{HMMTOP_ARCH}){$arch=$ENV{HMMTOP_ARCH};}
    elsif (-e "$MCOFFEE/hmmtop.arch"){$arch=$ENV{'HMMTOP_ARCH'}="$MCOFFEE/hmmtop.arch";}
    elsif (-e "$hmmtop_home/hmmtop.arch"){$arch=$ENV{'HMMTOP_ARCH'}="$hmmtop_home/hmmtop.arch";}
    else {myexit(flush_error ( "Could not find ARCH file for hmmtop"));}
    
    
    if (-e $psv){$ENV{'HMMTOP_PSV'}=$psv;}
    elsif (-e $ENV{HMMTOP_PSV}){$psv=$ENV{HMMTOP_PSV};}
    elsif (-e "$MCOFFEE/hmmtop.psv"){$psv=$ENV{'HMMTOP_PSV'}="$MCOFFEE/hmmtop.psv";}
    elsif (-e "$hmmtop_home/hmmtop.psv"){$psv=$ENV{'HMMTOP_PSV'}="$hmmtop_home/hmmtop.psv";}
    else {myexit(flush_error ( "Could not find PSV file for hmmtop"));}

  }
elsif ($mode eq "gor")
  {
    our $GOR_SEQ;
    our $GOR_OBS;
    
    check_configuration ("gorIV");
    if (-e $gor_seq){$GOR_SEQ=$gor_seq;}
    elsif (-e $ENV{GOR_SEQ}){$GOR_SEQ=$ENV{GOR_SEQ};}
    elsif (-e "$MCOFFEE/New_KS.267.seq"){$GOR_SEQ="$MCOFFEE/New_KS.267.seq";}
    elsif (-e "$gor_home/New_KS.267.seq"){$GOR_SEQ="$gor_home/New_KS.267.seq";}
    else {myexit(flush_error ( "Could not find SEQ file for gor"));}

    if (-e $gor_obs){$GOR_OBS=$gor_obs;}
    elsif (-e $ENV{GOR_OBS}){$GOR_OBS=$ENV{GOR_OBS};}
    elsif (-e "$MCOFFEE/New_KS.267.obs"){$GOR_OBS="$MCOFFEE/New_KS.267.obs";}
    elsif (-e "$gor_home/New_KS.267.obs"){$GOR_OBS="$gor_home/New_KS.267.obs";}
    else {myexit(flush_error ( "Could not find OBS file for gor"));}
  }


if ( ! -e $fmsq1){myexit(flush_error ("Could Not Read Input file $fmsq1"));}


my $fmsq2=vtmpnam();
my $fmsq3=vtmpnam();
my $tmpfile=vtmpnam();
my $predfile=vtmpnam();

if ($trim){$trim_action=" +trim _aln_%%$trim\_K1 ";}
if ($cov) {$cov_action= " +sim_filter _aln_c$cov ";}
&safe_system("t_coffee -other_pg seq_reformat -in $fmsq1 -action +convert 'BOUJXZ-' $cov_action $trim_action -output fasta_aln -out $fmsq2");
my (%pred, %seq, %predA);


%seq=read_fasta_seq($fmsq2);
%seq=fasta2sample(\%seq, $sample);

if (1==2 &&$mode eq "hmmtop" && $output eq "cons")
  {
    fasta2hmmtop_cons($outfile,\%seq);
  }
else
  {
   
    %pred=fasta2pred(\%seq, $mode);
    %predA=pred2aln (\%pred, \%seq);
    
    
    if (!$output || $output eq "prediction"){output_fasta_seq (\%predA, $outfile);}
    elsif ($output eq "color_html"){pred2color (\%pred,\%seq, $outfile);}
    elsif ($output eq "cons"){pred2cons($outfile,\%predA);}
    else {flush_error ("$output is an unknown output mode");}
  }

sub fasta2sample
  {
    my $SR=shift;
    my $it=shift;
    my %S=%$SR;
    
    my $seq=index2seq_name (\%S, 1);
    my $l=length($S{$seq}{seq});
    my @sl=keys(%S);
    my $nseq=$#sl+1;
    my $index=$nseq;
  
    if (!$sample) {return %S;}
    for (my $a=0; $a<$it; $a++)
      {
	my $newseq="";
	my $nname="$seq\_sampled_$index";
	for (my $p=0; $p<$l; $p++)
	  {
	    my $i=int(rand($nseq));
	    
	    my $name = $sl[$i];
	    my $seq=$S{$name}{seq};
	    my $r=substr ($seq, $p, 1);
	    $newseq.=$r;
	  }
	$S{$nname}{name}=$nname;
	$S{$nname}{seq}=$newseq;
	$S{$nname}{com}="sampled";
	$S{$nname}{index}=++$index;
      }
    return %S;
  }
	      
sub fasta2pred
  {
    my $s=shift;
    my $mode=shift;

    if ( $mode eq "hmmtop"){return fasta2hmmtop_pred($s);}
    elsif ($mode eq "gor"){return fasta2gor_pred ($s);}
  }
sub fasta2hmmtop_cons
  {
    my $outfile=shift;
    my $SR=shift;
    
    my $o = new FileHandle;
    my $i = new FileHandle;
    my $tmp_in =vtmpnam();
    my $tmp_out=vtmpnam();
    my %seq=%$SR;
    my %pred;
    my $N=keys(%seq);
    
    output_fasta_seq (\%seq,$tmp_in, "seq");
    `hmmtop -pi=mpred -if=$tmp_in -sf=FAS -pl 2>/dev/null >$tmp_out`;
    open ($o, ">$outfile");
    open ($i, "$tmp_out");
    while (<$i>)
      {
	my $l=$_;
	if (($l=~/>HP\:\s+(\d+)\s+(.*)/)){my $line=">$2 NSEQ: $N\n";print $o "$line";}
	elsif ( ($l=~/.*pred(.*)/))  {my $line="$1\n";print $o "$line";}
      }
    close ($o);
    close ($i);
    return read_fasta_seq($tmp);
  }
sub fasta2hmmtop_pred
  {
    my $SR=shift;
    my $o = new FileHandle;
    my $i = new FileHandle;
    my $tmp    =vtmpnam();
    my $tmp_in =vtmpnam();
    my $tmp_out=vtmpnam();
    my %seq=%$SR;
    my %pred;
    

    output_fasta_seq (\%seq,$tmp_in, "seq");

    
    `hmmtop -if=$tmp_in -sf=FAS -pl 2>/dev/null >$tmp_out`;
    

    
    
    open ($o, ">$tmp");
    open ($i, "$tmp_out");
    while (<$i>)
      {
	my $l=$_;
	if (($l=~/>HP\:\s+(\d+)\s+(.*)/)){my $line=">$2\n";print $o "$line";}
	elsif ( ($l=~/.*pred(.*)/))  {my $line="$1\n";print $o "$line";}
      }
    close ($o);
    close ($i);
    return read_fasta_seq($tmp);
  }
    
	
	
	    
	
	

	
sub fasta2gor_pred
  {
    my $SR=shift;
    my $o = new FileHandle;
    my $i = new FileHandle;
    my $tmp    =vtmpnam();
    my $tmp_in =vtmpnam();
    my $tmp_out=vtmpnam();
    my %seq=%$SR;
    my %pred;
    

    output_fasta_seq (\%seq,$tmp_in, "seq");
    `gorIV -prd $tmp_in -seq $GOR_SEQ -obs $GOR_OBS >$tmp_out`;
    open ($o, ">$tmp");
    open ($i, "$tmp_out");
    while (<$i>)
      {
	my $l=$_;

	
	if ( $l=~/>/){print $o "$l";}
	elsif ( $l=~/Predicted Sec. Struct./){$l=~s/Predicted Sec. Struct\.//;print $o "$l";}
      }
    close ($o);
    close ($i);
    return read_fasta_seq($tmp);
  }
			
			     
sub index2seq_name
  {
    
    my $SR=shift;
    my $index=shift;
    
    
    my %S=%$SR;
    
    foreach my $s (%S)
      {
	if ( $S{$s}{index}==$index){return $s;}
      }
    return "";
  }

sub pred2cons
  {
    my $outfile=shift;
    my $predR=shift;
    my $seq=shift;
    my %P=%$predR;
    my %C;
    my ($s,@r,$nseq);
    my $f= new FileHandle;

    open ($f, ">$outfile");

    if (!$seq){$seq=index2seq_name(\%P,1);}
    foreach my $s (keys(%P))
      {
	$nseq++;
	$string= $P{$s}{seq};
	$string = uc $string;
	my @r=split (//,$string);
	for (my $a=0; $a<=$#r; $a++)
	  {
	    if (($r[$a]=~/[OHICE]/)){$C{$a}{$r[$a]}++;}
	  }
      }
    @l=keys(%C);
    
    
    $s=$P{$seq}{seq};
    print $f ">$seq pred based on $nseq\n";
    @r=split (//,$s);
    
    for (my $x=0; $x<=$#r; $x++)
      {
	if ($r[$x] ne "-")
	  {
	    my $h=$C{$x}{H};
	    my $i=$C{$x}{I};
	    my $o=$C{$x}{O};
	    my $c=$C{$x}{C};
	    my $e=$C{$x}{E};
	    my $l=$i+$o;
	    
	    if ($h>=$i && $h>=$o && $h>=$c && $h>=$e){$r[$x]='H';}
	    elsif ($i>=$o && $i>=$c && $i>=$e){$r[$x]='I';}
	    elsif ($o>=$c && $o>=$e){$r[$x]='O';}
	    elsif ($c>=$e){$r[$x]='C';}
	    else {$r[$x]='E';}
	  }
      }
    $j=join ('', @r);
    print $f "$j\n";
    close ($f);
    return $j;
  }

sub pred2aln
  {
    my $PR=shift;
    my $AR=shift;
    
    my $f=new FileHandle;
    my %P=%$PR;
    my %A=%$AR;
    my %PA;
    my $tmp=vtmpnam();
    my $f= new FileHandle;
    
    open ($f, ">$tmp");
    foreach my $s (sort{$A{$a}{index}<=>$A{$b}{index}}(keys (%A)))
      {
	my (@list, $seq, @plist, @pseq, $L, $PL, $c, $w);
	my $seq;
	my $seq=$A{$s}{seq};
	my $pred=$P{$s}{seq};
	$seq=pred2alnS($P{$s}{seq},$A{$s}{seq});
	print $f ">$s\n$seq\n";
      }
    close ($f);
    return read_fasta_seq ($tmp);
  }
sub pred2alnS
  {
    my $pred=shift;
    my $aln= shift;
    my ($j,$a,$b);
    my @P=split (//, $pred);
    my @A=split (//, $aln);
    for ($a=$b=0;$a<=$#A; $a++)
      {
	if ($A[$a] ne "-"){$A[$a]=$P[$b++];}
      }
    if ($b!= ($#P+1)){add_warning ("Could not thread sequence: $b $#P");}
    
    $j= join ('', @A);
    return $j;
  }
sub pred2color
  {
    my $predP=shift;
    my $alnP=shift;
    my $out=shift;
    my $F=new FileHandle;
    my $struc=vtmpnam();
    my $aln=vtmpnam();
    

    output_fasta_seq ($alnP, $aln);
    my %p=%$predP;
    
    open ($F, ">$struc");
    
    
    foreach my $s (keys(%p))
      {
	
	print $F ">$s\n";
	my $s=uc($p{$s}{seq});
	
	$s=~s/[Oo]/0/g;
	$s=~s/[Ee]/0/g;
	
	$s=~s/[Ii]/5/g;
	$s=~s/[Cc]/5/g;
	
	$s=~s/[Hh]/9/g;
	
	print $F "$s\n";
      }
    close ($F);
    
    
    
    safe_system ( "t_coffee -other_pg seq_reformat -in $aln -struc_in $struc -struc_in_f number_fasta -output color_html -out $out");
    return;
  }
	  
    
sub display_fasta_seq
  {
    my $SR=shift;
    my %S=%$SR;
    
    foreach my $s (sort{$S{$a}{index}<=>$S{$b}{index}}(keys (%S)))
      {
	print STDERR ">$s\n$S{$s}{seq}\n";
      }
    close ($f);
  }
sub output_fasta_seq
  {
    my $SR=shift;
    my $outfile=shift;
    my $mode =shift;
    my $f= new FileHandle;
    my %S=%$SR;
    
    
    open ($f, ">$outfile");
    foreach my $s (sort{$S{$a}{index}<=>$S{$b}{index}}(keys (%S)))
      {
	my $seq=$S{$s}{seq};
	if ( $mode eq "seq"){$seq=~s/\-//g;}
	print $f ">$s\n$seq\n";
      }
    close ($f);
  }
      
sub read_fasta_seq 
  {
    my $f=$_[0];
    my %hseq;
    my (@seq, @com, @name);
    my ($a, $s,$nseq);
    my $index;
    open (F, $f);
    while (<F>)
      {
	$s.=$_;
      }
    close (F);

    
    @name=($s=~/>(\S*).*\n[^>]*/g);
    
    @seq =($s=~/>.*.*\n([^>]*)/g);
    @com =($s=~/>.*(.*)\n([^>]*)/g);


    $nseq=$#name+1;
    
  
    for ($a=0; $a<$nseq; $a++)
      {
	my $n=$name[$a];
	my $s;
	$hseq{$n}{name}=$n;
	$s=$seq[$a];$s=~s/\s//g;
	$hseq{$n}{index}=++$index;
	$hseq{$n}{seq}=$s;
	$hseq{$n}{com}=$com[$a];
      }
    return %hseq;
  }


sub file2head
      {
	my $file = shift;
	my $size = shift;
	my $f= new FileHandle;
	my $line;
	open ($f,$file);
	read ($f,$line, $size);
	close ($f);
	return $line;
      }
sub file2tail
      {
	my $file = shift;
	my $size = shift;
	my $f= new FileHandle;
	my $line;
	
	open ($f,$file);
	seek ($f,$size*-1, 2);
	read ($f,$line, $size);
	close ($f);
	return $line;
      }


sub vtmpnam
      {
	my $r=rand(100000);
	my $f="file.$r.$$";
	while (-e $f)
	  {
	    $f=vtmpnam();
	  }
	push (@TMPFILE_LIST, $f);
	return $f;
      }

sub myexit
  {
    my $code=@_[0];
    if ($CLEAN_EXIT_STARTED==1){return;}
    else {$CLEAN_EXIT_STARTED=1;}
    ### ONLY BARE EXIT
    exit ($code);
  }
sub set_error_lock
    {
      my $name = shift;
      my $pid=$$;

      
      &lock4tc ($$,"LERROR", "LSET", "$$ -- ERROR: $name $PROGRAM\n");
      return;
    }
sub set_lock
  {
    my $pid=shift;
    my $msg= shift;
    my $p=getppid();
    &lock4tc ($pid,"LLOCK","LRESET","$p$msg\n");
  }
sub unset_lock
   {
     
    my $pid=shift;
    &lock4tc ($pid,"LLOCK","LRELEASE","");
  }
sub shift_lock
  {
    my $from=shift;
    my $to=shift;
    my $from_type=shift;
    my $to_type=shift;
    my $action=shift;
    my $msg;
    
    if (!&lock4tc($from, $from_type, "LCHECK", "")){return 0;}
    $msg=&lock4tc ($from, $from_type, "LREAD", "");
    &lock4tc ($from, $from_type,"LRELEASE", $msg);
    &lock4tc ($to, $to_type, $action, $msg);
    return;
  }
sub isshellpid
  {
    my $p=shift;
    if (!lock4tc ($p, "LLOCK", "LCHECK")){return 0;}
    else
      {
	my $c=lock4tc($p, "LLOCK", "LREAD");
	if ( $c=~/-SHELL-/){return 1;}
      }
    return 0;
  }
sub isrootpid
  {
    if(lock4tc (getppid(), "LLOCK", "LCHECK")){return 0;}
    else {return 1;}
  }
sub lock4tc
	{
	  my ($pid,$type,$action,$value)=@_;
	  my $fname;
	  my $host=hostname;
	  
	  if ($type eq "LLOCK"){$fname="$LOCKDIR/.$pid.$host.lock4tcoffee";}
	  elsif ( $type eq "LERROR"){ $fname="$LOCKDIR/.$pid.$host.error4tcoffee";}
	  elsif ( $type eq "LWARNING"){ $fname="$LOCKDIR/.$pid.$host.warning4tcoffee";}
	  
	  if ($debug_lock)
	    {
	      print STDERR "\n\t---lock4tc(tcg): $action => $fname =>$value (RD: $LOCKDIR)\n";
	    }

	  if    ($action eq "LCHECK") {return -e $fname;}
	  elsif ($action eq "LREAD"){return file2string($fname);}
	  elsif ($action eq "LSET") {return string2file ($value, $fname, ">>");}
	  elsif ($action eq "LRESET") {return string2file ($value, $fname, ">");}
	  elsif ($action eq "LRELEASE") 
	    {
	      if ( $debug_lock)
		{
		  my $g=new FileHandle;
		  open ($g, ">>$fname");
		  print $g "\nDestroyed by $$\n";
		  close ($g);
		  safe_system ("mv $fname $fname.old");
		}
	      else
		{
		  unlink ($fname);
		}
	    }
	  return "";
	}
	
sub file2string
	{
	  my $file=@_[0];
	  my $f=new FileHandle;
	  my $r;
	  open ($f, "$file");
	  while (<$f>){$r.=$_;}
	  close ($f);
	  return $r;
	}
sub string2file 
    {
    my ($s,$file,$mode)=@_;
    my $f=new FileHandle;
    
    open ($f, "$mode$file");
    print $f  "$s";
    close ($f);
  }

BEGIN
    {
      srand;
    
      $SIG{'SIGUP'}='signal_cleanup';
      $SIG{'SIGINT'}='signal_cleanup';
      $SIG{'SIGQUIT'}='signal_cleanup';
      $SIG{'SIGILL'}='signal_cleanup';
      $SIG{'SIGTRAP'}='signal_cleanup';
      $SIG{'SIGABRT'}='signal_cleanup';
      $SIG{'SIGEMT'}='signal_cleanup';
      $SIG{'SIGFPE'}='signal_cleanup';
      
      $SIG{'SIGKILL'}='signal_cleanup';
      $SIG{'SIGPIPE'}='signal_cleanup';
      $SIG{'SIGSTOP'}='signal_cleanup';
      $SIG{'SIGTTIN'}='signal_cleanup';
      $SIG{'SIGXFSZ'}='signal_cleanup';
      $SIG{'SIGINFO'}='signal_cleanup';
      
      $SIG{'SIGBUS'}='signal_cleanup';
      $SIG{'SIGALRM'}='signal_cleanup';
      $SIG{'SIGTSTP'}='signal_cleanup';
      $SIG{'SIGTTOU'}='signal_cleanup';
      $SIG{'SIGVTALRM'}='signal_cleanup';
      $SIG{'SIGUSR1'}='signal_cleanup';


      $SIG{'SIGSEGV'}='signal_cleanup';
      $SIG{'SIGTERM'}='signal_cleanup';
      $SIG{'SIGCONT'}='signal_cleanup';
      $SIG{'SIGIO'}='signal_cleanup';
      $SIG{'SIGPROF'}='signal_cleanup';
      $SIG{'SIGUSR2'}='signal_cleanup';

      $SIG{'SIGSYS'}='signal_cleanup';
      $SIG{'SIGURG'}='signal_cleanup';
      $SIG{'SIGCHLD'}='signal_cleanup';
      $SIG{'SIGXCPU'}='signal_cleanup';
      $SIG{'SIGWINCH'}='signal_cleanup';
      
      $SIG{'INT'}='signal_cleanup';
      $SIG{'TERM'}='signal_cleanup';
      $SIG{'KILL'}='signal_cleanup';
      $SIG{'QUIT'}='signal_cleanup';
      
      our $debug_lock=$ENV{"DEBUG_LOCK"};
      
      
      
      
      foreach my $a (@ARGV){$CL.=" $a";}
      if ( $debug_lock ){print STDERR "\n\n\n********** START PG: $PROGRAM *************\n";}
      if ( $debug_lock ){print STDERR "\n\n\n**********(tcg) LOCKDIR: $LOCKDIR $$ *************\n";}
      if ( $debug_lock ){print STDERR "\n --- $$ -- $CL\n";}
      
	     
      
      
    }
sub flush_error
  {
    my $msg=shift;
    return add_error ($EXIT_FAILURE,$$, $$,getppid(), $msg, $CL);
  }
sub add_error 
  {
    my $code=shift;
    my $rpid=shift;
    my $pid=shift;
    my $ppid=shift;
    my $type=shift;
    my $com=shift;
    
    $ERROR_DONE=1;
    lock4tc ($rpid, "LERROR","LSET","$pid -- ERROR: $type\n");
    lock4tc ($$, "LERROR","LSET", "$pid -- COM: $com\n");
    lock4tc ($$, "LERROR","LSET", "$pid -- STACK: $ppid -> $pid\n");
   
    return $code;
  }
sub add_warning 
  {
    my $rpid=shift;
    my $pid =shift;
    my $command=shift;
    my $msg="$$ -- WARNING: $command\n";
    print STDERR "$msg";
    lock4tc ($$, "LWARNING", "LSET", $msg);
  }

sub signal_cleanup
  {
    print dtderr "\n**** $$ (tcg) was killed\n";
    &cleanup;
    exit ($EXIT_FAILURE);
  }
sub clean_dir
  {
    my $dir=@_[0];
    if ( !-d $dir){return ;}
    elsif (!($dir=~/tmp/)){return ;}#safety check 1
    elsif (($dir=~/\*/)){return ;}#safety check 2
    else
      {
	`rm -rf $dir`;
      }
    return;
  }
sub cleanup
  {
    #print stderr "\n----tc: $$ Kills $PIDCHILD\n";
    #kill (SIGTERM,$PIDCHILD);
    my $p=getppid();
    $CLEAN_EXIT_STARTED=1;
    
    
    
    if (&lock4tc($$,"LERROR", "LCHECK", ""))
      {
	my $ppid=getppid();
	if (!$ERROR_DONE) 
	  {
	    &lock4tc($$,"LERROR", "LSET", "$$ -- STACK: $p -> $$\n");
	    &lock4tc($$,"LERROR", "LSET", "$$ -- COM: $CL\n");
	  }
      }
    my $warning=&lock4tc($$, "LWARNING", "LREAD", "");
    my $error=&lock4tc($$,  "LERROR", "LREAD", "");
    #release error and warning lock if root
    
    if (isrootpid() && ($warning || $error) )
      {
	
	print STDERR "**************** Summary *************\n$error\n$warning\n";

	&lock4tc($$,"LERROR","RELEASE","");
	&lock4tc($$,"LWARNING","RELEASE","");
      } 
    
    
    foreach my $f (@TMPFILE_LIST)
      {
	if (-e $f){unlink ($f);} 
      }
    foreach my $d (@TMPDIR_LIST)
      {
	clean_dir ($d);
      }
    #No More Lock Release
    #&lock4tc($$,"LLOCK","LRELEASE",""); #release lock 

    if ( $debug_lock ){print STDERR "\n\n\n********** END PG: $PROGRAM ($$) *************\n";}
    if ( $debug_lock ){print STDERR "\n\n\n**********(tcg) LOCKDIR: $LOCKDIR $$ *************\n";}
  }
END 
  {
    
    &cleanup();
  }
   

sub safe_system 
{
  my $com=shift;
  my $ntry=shift;
  my $ctry=shift;
  my $pid;
  my $status;
  my $ppid=getppid();
  if ($com eq ""){return 1;}
  
  

  if (($pid = fork ()) < 0){return (-1);}
  if ($pid == 0)
    {
      set_lock($$, " -SHELL- $com (tcg)");
      exec ($com);
    }
  else
    {
      lock4tc ($$, "LLOCK", "LSET", "$pid\n");#update parent
      $PIDCHILD=$pid;
    }
  if ($debug_lock){printf STDERR "\n\t .... safe_system (fasta_seq2hmm)  p: $$ c: $pid COM: $com\n";}

  waitpid ($pid,WTERMSIG);

  shift_lock ($pid,$$, "LWARNING","LWARNING", "LSET");

  if ($? == $EXIT_FAILURE || lock4tc($pid, "LERROR", "LCHECK", ""))
    {
      if ($ntry && $ctry <$ntry)
	{
	  add_warning ($$,$$,"$com failed [retry: $ctry]");
	  lock4tc ($pid, "LRELEASE", "LERROR", "");
	  return safe_system ($com, $ntry, ++$ctry);
	}
      elsif ($ntry == -1)
	{
	  if (!shift_lock ($pid, $$, "LERROR", "LWARNING", "LSET"))
	    {
	      add_warning ($$,$$,"$com failed");
	    }
	  else
	    {
	      lock4tc ($pid, "LRELEASE", "LERROR", "");
	    }
	  return $?;}
      else
	{
	  if (!shift_lock ($pid,$$, "LERROR","LERROR", "LSET"))
	    {
	      myexit(add_error ($EXIT_FAILURE,$$,$pid,getppid(), "UNSPECIFIED system", $com));
	    }
	}
    }
  return $?;
}

sub check_configuration 
    {
      my @l=@_;
      my $v;
      foreach my $p (@l)
	{
	  
	  if   ( $p eq "EMAIL")
	    { 
	      if ( !($EMAIL=~/@/))
		{
		add_warning($$,$$,"Could Not Use EMAIL");
		myexit(add_error ($EXIT_FAILURE,$$,$$,getppid(),"EMAIL","$CL"));
	      }
	    }
	  elsif( $p eq "INTERNET")
	    {
	      if ( !&check_internet_connection())
		{
		  myexit(add_error ($EXIT_FAILURE,$$,$$,getppid(),"INTERNET","$CL"));
		}
	    }
	  elsif( $p eq "wget")
	    {
	      if (!&pg_is_installed ("wget") && !&pg_is_installed ("curl"))
		{
		  myexit(add_error ($EXIT_FAILURE,$$,$$,getppid(),"PG_NOT_INSTALLED:wget","$CL"));
		}
	    }
	  elsif( !(&pg_is_installed ($p)))
	    {
	      myexit(add_error ($EXIT_FAILURE,$$,$$,getppid(),"PG_NOT_INSTALLED:$p","$CL"));
	    }
	}
      return 1;
    }
sub pg_is_installed
  {
    my @ml=@_;
    my $r, $p, $m;
    my $supported=0;
    
    my $p=shift (@ml);
    if ($p=~/::/)
      {
	if (safe_system ("perl -M$p -e 1")==$EXIT_SUCCESS){return 1;}
	else {return 0;}
      }
    else
      {
	$r=`which $p 2>/dev/null`;
	if ($r eq ""){return 0;}
	else {return 1;}
      }
  }



sub check_internet_connection
  {
    my $internet;
    my $tmp;
    &check_configuration ( "wget"); 
    
    $tmp=&vtmpnam ();
    
    if     (&pg_is_installed    ("wget")){`wget www.google.com -O$tmp >/dev/null 2>/dev/null`;}
    elsif  (&pg_is_installed    ("curl")){`curl www.google.com -o$tmp >/dev/null 2>/dev/null`;}
    
    if ( !-e $tmp || -s $tmp < 10){$internet=0;}
    else {$internet=1;}
    if (-e $tmp){unlink $tmp;}

    return $internet;
  }
sub check_pg_is_installed
  {
    my @ml=@_;
    my $r=&pg_is_installed (@ml);
    if (!$r && $p=~/::/)
      {
	print STDERR "\nYou Must Install the perl package $p on your system.\nRUN:\n\tsudo perl -MCPAN -e 'install $pg'\n";
      }
    elsif (!$r)
      {
	myexit(flush_error("\nProgram $p Supported but Not Installed on your system"));
      }
    else
      {
	return 1;
      }
  }




</content>
</file>
<file>
<stream>output</stream>
<name>fasta_seq2consan_aln.pl</name>
<content>#!/usr/bin/env perl





my $FMODEL =""; 
my $TMPDIR = "/tmp";




my $NUCALPH = "ACGTUNRYMKSWHBVD";
my $PRIMNUCALPH = "ACGTUN";
use vars qw($NUCALPH $PRIMNUCALPH $TMPDIR);


my $errmsg;
use vars qw($errmsg);



use Getopt::Long;
use Cwd;
use File::Basename;
use File::Temp qw/ tempfile tempdir /;
use File::Copy;
use File::Path;



sub usage(;$)
{
    my ($errmsg) = @_;
    my $myname = basename($0);

    if ($errmsg) {
        print STDERR "ERROR: $errmsg\n";
    }

    print STDERR << "EOF";
    
$myname: align two sequences by means of consan\'s sfold
Usage:
 $myname -i file -o file -d path
Options:
 -i|--in : pairwise input sequence file
 -o|--out: output alignment
 -d|--directory containing data

EOF
}

sub read_stk_aln 
  {
    my $f=$_[0];
    my ($seq, $id);
    
    my %hseq;

    open (STK, "$f");
    while (<STK>)
      {
	if ( /^#/ || /^\/\// || /^\s*$/){;}
	else
	  {
	    ($id,$seq)=/(\S+)\s+(\S+)/;
	    $hseq{$id}{'seq'}.=$seq;
	  }
      }
    close (STK);
    return %hseq;
  }
sub read_fasta_seq 
  {
    my $f=$_[0];
    my %hseq;
    my (@seq, @com, @name);
    my ($a, $s,$nseq);

    open (F, $f);
    while (<F>)
      {
	$s.=$_;
      }
    close (F);

    
    @name=($s=~/>(.*).*\n[^>]*/g);
    
    @seq =($s=~/>.*.*\n([^>]*)/g);
    @com =($s=~/>.*(.*)\n([^>]*)/g);

    
    $nseq=$#name+1;
    
    for ($a=0; $a<$nseq; $a++)
      {
	my $n=$name[$a];
	$hseq{$n}{name}=$n;
	$hseq{$n}{seq}=$seq[$a];
	$hseq{$n}{com}=$com[$a];
      }
    return %hseq;
  }



sub sfold_parseoutput($$)
{
    my ($frawout, $foutfa) = @_;
    my %haln;
    my ($fstk, $cmd, $id);
    open FOUTFA, ">$foutfa";
    
    $fstk = $frawout . ".stk";
    
    # first line of raw out contains info
    # remaining stuff is stockholm formatted
    $cmd = "sed -e '1d' $frawout";
    system("$cmd > $fstk");
    if ($? != 0) {
        $errmsg = "command failed with exit status $?.";
        $errmsg .=  "Command was \"$cmd\"";
        return -1;
    }

    # this gives an error message. just ignore it...
    %haln=read_stk_aln ( $fstk);
    foreach $i (keys (%haln))
      {
	my $s;
	$s=$haln{$i}{'seq'};
	$s =~ s/\./-/g;
	print FOUTFA ">$i\n$s\n";
      }
    close FOUTFA;
    return 0;
}




sub sfold_wrapper($$$$)
{
    
    my ($fs1, $fs2, $fmodel, $foutfa) = @_;
    

    my ($cmd, $frawout, $ferrlog, $freadme, $ftimelog, $fstk);

    # add  basename($fmsqin) (unknown here!)
    $frawout = "sfold.log";
    $ferrlog = "sfold.err";
    $ftimelog = "sfold.time";
    $freadme =  "sfold.README";
    $fstk = "sfold.stk";
    
    # prepare execution...
    #
    # ./tmp is essential for dswpalign
    # otherwise you'll get a segfault
    mkdir "./tmp";
    
    $cmd = "sfold -m $fmodel $fs1 $fs2";
    open(FREADME,">$freadme");
    print FREADME "$cmd\n"; 
    close(FREADME);

    # and go
    #
    system("/usr/bin/time -p -o $ftimelog $cmd >$frawout 2>$ferrlog");
    if ($? != 0) {
        $errmsg = "command failed with exit status $?";
        $errmsg .= "command was \"$cmd\". See " . getcwd . "\n";
        return -1;
    }

    return sfold_parseoutput($frawout, $foutfa);
}







my ($help, $fmsqin, $fmsaout);
GetOptions("help"  => \$help,
           "in=s" => \$fmsqin,
           "out=s" => \$fmsaout,
	   "data=s" => \$ref_dir);



if ($help) {
    usage();
    exit(0);
}
if (! defined($fmsqin)) {
    usage('missing input filename');
    exit(1);
}
if (! defined($fmsaout)) {
    usage('missing output filename');
    exit(1);

}
if (scalar(@ARGV)) {
    usage('Unknown remaining args');
    exit(1);
}

$FMODEL = "$ref_dir/mix80.mod";
if (! -e "$FMODEL") {
    die("couldn't find sfold grammar model file. Expected $FMODEL\n");
}


my %hseq=read_fasta_seq ($fmsqin);
my $id;

foreach $id (keys(%hseq))
  {
    push(@seq_array, $hseq{$id});
  }

if ( scalar(@seq_array) != 2 ) {
    die("Need *exactly* two sequences as input (pairwise alignment!).")
}



my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime(time);
my $datei = sprintf("%4d-%02d-%02d", $year+1900, $mon+1, $mday);
my $templ = basename($0) . "." . $datei . ".pid-" . $$ . ".XXXXXX";
my $wd = tempdir ( $templ, DIR => $TMPDIR);

copy($fmsqin, "$wd/" . basename($fmsqin) . ".org"); # for reproduction
copy($FMODEL, "$wd");
my $fmodel = basename($FMODEL);
my $orgwd = getcwd;
chdir $wd;



my @sepseqfiles;
foreach $id (keys(%hseq)) {
    my ($seq, $orgseq, $fname, $sout);
    $seq=$hseq{$id}{'seq'};
    
    $fname = basename($fmsqin) . "_$id.fa";
    # replace funnies in file/id name (e.g. "/" " " etc)
    $fname =~ s,[/ ],_,g;
    open (PF, ">$fname");
    print (PF ">$id\n$seq\n");
    close (PF);

    push(@sepseqfiles, $fname);
}

my ($f1, $f2, $fout);
$f1 = $sepseqfiles[0];
$f2 = $sepseqfiles[1];
$fout = $wd . basename($fmsqin) . ".out.fa";
if (sfold_wrapper($f1, $f2, $fmodel, "$fout") != 0) {
    printf STDERR "ERROR: See logs in $wd\n";
    exit(1);
} else {
    chdir $orgwd;
    copy($fout, $fmsaout);
    rmtree($wd);
   exit(0);
}

</content>
</file>
<file>
<stream>output</stream>
<name>clustalw_aln2fasta_aln.pl</name>
<content>#!/usr/bin/env perl

use Env qw(HOST);
use Env qw(HOME);
use Env qw(USER);


$tmp=clean_cr ($ARGV[0]);
open (F, $tmp);

while ( <F>)
  {
    my $l=$_;
    if ( $l=~/^# STOCKHOLM/){$stockholm=1;}
    elsif ( $stockholm && $l=~/^#/)
      {
	$l=~/^#(\S+)\s+(\S+)\s+(\S*)/g;
	$l="_stockholmhasch_$1\_stockholmspace_$2 $3\n";
      }
    $file.=$l;
  }
close (F);
unlink($tmp);
$file1=$file;

$file=~s/\#/_hash_symbol_/g;
$file=~s/\@/_arobase_symbol_/g;


$file=~s/\n[\.:*\s]+\n/\n\n/g;

$file=~s/\n[ \t\r\f]+(\b)/\n\1/g;


$file=~s/(\n\S+)(\s+)(\S)/\1_blank_\3/g;

$file=~s/[ ]//g;
$file=~s/_blank_/ /g;



$file =~s/\n\s*\n/#/g;

$file.="#";
$file =~s/\n/@/g;




@blocks=split /\#/, $file;
shift (@blocks);
@s=split /\@/, $blocks[0];
$nseq=$#s+1;



$file=join '@', @blocks;
@lines=split /\@/,$file;

$c=0;

foreach $l (@lines)
  {
    if (!($l=~/\S/)){next;}
    elsif ($stockholm && ($l=~/^\/\// || $l=~/STOCKHOLM/)){next;}#get read of STOCHOLM Terminator
   
    $l=~/(\S+)\s+(\S*)/g;
    $n=$1; $s=$2;
    
    $seq[$c].=$s;
    $name[$c]=$n;
    $c++;
    
    if ( $c==$nseq){$c=0;}
    
  } 

if ( $c!=0)
      {
	print STDERR "ERROR: $ARGV[0] is NOT an MSA in Clustalw format: make sure there is no blank line within a block [ERROR]\n";
	exit (EXIT_FAILURE);
      }

for ($a=0; $a< $nseq; $a++)
  {
    $name[$a]=cleanstring ($name[$a]);
    $seq[$a]=cleanstring ($seq[$a]);
    $seq[$a]=breakstring($seq[$a], 60);
    
    $line=">$name[$a]\n$seq[$a]\n";
    
    print "$line";
  }
exit (EXIT_SUCCESS);

sub cleanstring
  {
    my $s=@_[0];
    $s=~s/_hash_symbol_/\#/g;
    $s=~s/_arobase_symbol_/\@/g;
    $s=~s/[ \t]//g;
    return $s;
  }
sub breakstring
  {
    my $s=@_[0];
    my $size=@_[1];
    my @list;
    my $n,$ns, $symbol;
    
    @list=split //,$s;
    $n=0;$ns="";
    foreach $symbol (@list)
      {
	if ( $n==$size)
	  {
	    $ns.="\n";
	    $n=0;
	  }
	$ns.=$symbol;
	$n++;
      }
    return $ns;
    }

sub clean_cr
  {
    my $f=@_[0];
    my $file;
    
    $tmp="f$.$$";
    
    
    open (IN, $f);
    open (OUT, ">$tmp");
    
    while ( <IN>)
      {
	$file=$_;
	$file=~s/\r\n/\n/g;
	$file=~s/\n\r/\n/g;
	$file=~s/\r\r/\n/g;
	$file=~s/\r/\n/g;
	print OUT "$file";
      }
    
    close (IN);
    close (OUT);
    return $tmp;
  }

</content>
</file>
<file>
<stream>output</stream>
<name>seq2name_seq.pl</name>
<content>#!/usr/bin/env perl
use strict;
use FileHandle;
use Env qw(HOST);
use Env qw(HOME);
use Env qw(USER);

my $format=file2format ($ARGV[0]);
if    ($format eq "clustalw"){clustalw2name_seq($ARGV[0]);}
elsif ($format eq "fasta")   {fasta2name_seq($ARGV[0]);}
elsif ($format eq "msf")   {msf2name_seq($ARGV[0]);}
elsif ($format eq "phylip")   {phylip2name_seq($ARGV[0]);}
elsif ($format eq "nameseq") {display_file ($ARGV[0]);}
 
exit (0);

sub file2format
  {
    my $f=shift;
    
    my $l=file2n_lines($f,2);
    
    if ( $l=~/^CLUSTAL/){return "clustalw";}
    elsif ($l=~/^SAGA/){return "clustalw";}
    elsif ($l=~/^>/){return "fasta";}
    elsif ($l=~/^PileUp/){return "msf";}
    elsif ($l=~/\s+\d+\s+\d+\s/){return "phylip";}
    elsif ($l=~/\#NAMESEQ_01/){return "nameseq";}
    else 
      {
	print STDERR "ERROR: $f FILE is NOT a supported format [ERROR]\n";
	exit (1);
      }
  }
sub display_file
    {
       my $file=shift;
       my $F= new FileHandle;
       open ($F, $file);
       while (<$F>){print "$_";}
       close ($F);
     }
sub phylip2name_seq
    {
      my $file=shift;
      my $F= new FileHandle;
      my ($seq, $name,$seq);
      my $query_start=-1;
      my $query_end=-1;
      my $in_aln=0;
      my %list;
      my ($first,$seq,$name, $cn, $nseq, $l,%len);
      
      open ($F, $file);
      <$F>;
      $l=$_;
      $l=~/\s*(\d+)\s*(\d+)/;
      $first=1;
      $cn=0;
      while (<$F>)
	{
	  my $l=$_;
	  if (!($l=~/\S/))
	    {
	      $cn=0;
	      $first=0;
	    }
	  elsif ($first==1)
	    {
	      $l=~/\s*(\S+)(.*)/;
	      my $name=$1;
	      my $seq=$2;
	      chomp ($seq);
	      $seq=~s/\s//g;
	      $list{$cn}{'name'}=$name;
	      $list{$cn}{'seq'}.=$seq;
	      $cn++;
	      $nseq++;
	    }
	  else
	    {
	      chomp ($l);
	      $l=~s/\s//g;
	      $list{$cn}{'seq'}.=$l;
	      $cn++;
	    }
	}
      close ($F);
      
      print "#NAMESEQ_01\n";
      print "# $nseq\n";
      for (my $a=0; $a<$nseq; $a++)
	{
	  my $nl=length ($list{$a}{'name'});
	  my $sl=length ($list{$a}{'seq'});
	  print ">$nl $sl $list{$a}{'name'} $list{$a}{'seq'}\n";
	}
    }
      
sub msf2name_seq
    {
      my $file=shift;
      my $F= new FileHandle;
      my ($seq, $name,$seq);
      my $query_start=-1;
      my $query_end=-1;
      my $in_aln=0;
      my %list;
      my ($seq,$name, $n, $nseq, $l,%len);
      
      open ($F, $file);
      while (<$F>)
	{
	  if ( /\/\//){$in_aln=1;}
	  elsif ( $in_aln && /(\S+)\s+(.*)/)
	    {
	      $name=$1;
	      $seq=$2;
	      $seq=~s/\s//g;
	      $seq=~s/\~/\-/g;
	      $seq=~s/\./\-/g;
	      if ( $list{$n}{'name'} && $list{$n}{'name'} ne $name)
		{
		  print "$list{$n}{'name'} Vs $name";
		  
		  exit (1);
		}
	      else
		{
		  $list{$n}{'name'}= $name;
		}
	      
	      $list{$n}{'seq'}=$list{$n}{'seq'}.$seq;
	      
	      $nseq=++$n;
	      
	    }
	  else
	    {$n=0;}
	}
      close ($F);
      print "#NAMESEQ_01\n";
      print "# $nseq\n";
      for (my $a=0; $a<$nseq; $a++)
	{
	  my $nl=length ($list{$a}{'name'});
	  my $sl=length ($list{$a}{'seq'});
	  print ">$nl $sl $list{$a}{'name'} $list{$a}{'seq'}\n";
	}
    }
    
sub fasta2name_seq
    {
      my $file=shift;
      my $F= new FileHandle;
      my ($seq, $name,$n,$l,%len);
      
      open ($F, $file);
      while (<$F>)
	{
	  if ( /^>(\S+)/){$n++;$seq="";$name=$1;}
	  else
	    {
	      $l=$_;
	      chomp ($l);
	      $seq.=$l;
	      $len{$name}=length($seq);
	    }
	}
      close ($F);
      print "#NAMESEQ_01\n";
      print "# $n";
      
      open ($F, $file);
      while (<$F>)
	{
	  if ( /^>(\S+)(.*)\n/)
	    {
	      my $name=$1;
	      my $comment=$2;
	      my $nl=length ($name);
	      my $sl=$len{$name};
	      if ($comment)
		{
		  $comment=~s/^\s+//g;
		  my $cl=length ($comment);
		  print "\n#$cl $comment\n";
		}
	      print "\n>$nl $sl $name ";
	    }
	  else
	    {
	      $l=$_;
	      chomp ($l);
	      print "$l";
	    }
	}
      print "\n";
      close ($F);
    }
sub clustalw2name_seq
  {
    my $fname=shift;
    my ($file1, $file);
    my (@blocks, @lines,@s, $n,$nseq, $c);
    my (@name, @seq);
    my $F= new FileHandle;
    my $stockholm;
    
    open ($F, $fname);
    
    while ( <$F>)
      {
	my $l=$_;
	$l=clean_cr($l);
	if ( $l=~/^# STOCKHOLM/){$stockholm=1;}
	elsif ( $stockholm && $l=~/^#/)
	  {
	    $l=~/^#(\S+)\s+(\S+)\s+(\S*)/g;
	    $l="_stockholmhasch_$1\_stockholmspace_$2 $3\n";
	  }
	$file.=$l;
      }
    close ($F);
        
    #Protect # and @
    $file=~s/\#/_hash_symbol_/g;
    $file=~s/\@/_arobase_symbol_/g;
    
    
    #Remove annotation
    $file=~s/\n[\.:*\s]+\n/\n\n/g;
    
    #Remove White spaces before the sequence name
    $file=~s/\n[ \t\r\f]+(\b)/\n\1/g;
    
    
    #Remove Internal Blanks
    $file=~s/(\n\S+)(\s+)(\S)/\1_blank_\3/g;
    
    $file=~s/[ ]//g;
    $file=~s/_blank_/ /g;
    
    
    #Identify Double Blank lines
    
    $file =~s/\n\s*\n/#/g;
    
    $file.="#";
    $file =~s/\n/@/g;
    
    
    
    
    #count nseq
    @blocks=split /\#/, $file;
    shift (@blocks);
    @s=split /\@/, $blocks[0];
    $nseq=$#s+1;
    
    #Merge all the sequences and split every Nseq
    
    
    $file=join '@', @blocks;
    @lines=split /\@/,$file;
    
    $c=0;
    
    foreach my $l (@lines)
      {
	my ($n, $s);
	
	if (!($l=~/\S/)){next;}
	elsif ($stockholm && ($l=~/^\/\// || $l=~/STOCKHOLM/)){next;}#get read of STOCHOLM Terminator
	
	$l=~/(\S+)\s+(\S*)/g;
	$n=$1; $s=$2;
	
	$seq[$c].=$s;
	$name[$c]=$n;
	$c++;
	
	if ( $c==$nseq){$c=0;}
	
      } 
    
    if ( $c!=0)
      {
	print STDERR "ERROR: $fname is NOT an MSA in Clustalw format: make sure there is no blank line within a block [ERROR]\n";
	exit (1);
      }
    print "#NAMESEQ_01\n";
    print "# $nseq\n";
    for (my $a=0; $a< $nseq; $a++)
      {
	$name[$a]=cleanstring ($name[$a]);
	$seq[$a]=cleanstring ($seq[$a]);
	my $ln=length ($name[$a]);
	my $ls=length ($seq[$a]);
	print ">$ln $ls $name[$a] $seq[$a]\n";
      }
  }
sub cleanstring
    {
      my $s=@_[0];
      $s=~s/_hash_symbol_/\#/g;
      $s=~s/_arobase_symbol_/\@/g;
      $s=~s/[ \t]//g;
      return $s;
    }

sub clean_cr
  {
    my $f=shift;
    $f=~s/\r\n/\n/g;
    $f=~s/\n\r/\n/g;
    $f=~s/\r\r/\n/g;
    $f=~s/\r/\n/g;
    return $f;
  }

sub file2n_lines
    {
      my $file=shift;
      my $nl=shift;
      my $ret;
      my $F=new FileHandle;
      my $n=0;
      open ($F, $file);

      while (<$F>)
	{
	  $ret.=$_;
	  $n++;
	  
	  if ($n>=$n){close ($F); return $ret;}
	}
      close ($F);
      return $ret;
    }

</content>
</file>
<file>
<stream>output</stream>
<name>seq2intersection.pl</name>
<content>#!/usr/bin/env perl
use strict;
use FileHandle;
use Env qw(HOST);
use Env qw(HOME);
use Env qw(USER);
my %name;
my $nseq;
my $fasta;
if ($ARGV[2] eq "-fasta"){$fasta=1;}
my $F= new FileHandle;

open ($F, $ARGV[1]);
while(<$F>)
  {
    my $l=$_;
    if ($l=~/^#/){;}
    elsif (($l=~/\d+\s+\d+\s+(\S+)\s+(\S+)/))
      {
	my $n=$1;
	$name{$1}++;
      }
  }
close ($F);

open ($F, $ARGV[0]);
while(<$F>)
  {
    my $l=$_;
    if ($l=~/^#/){;}
    elsif ($l=~/\d+\s+\d+\s+(\S+)\s+(\S+)/)
      {
	my $n=$1;
	$name{$n}++;
	if ($name{$n}==2){$nseq++;}
      }
  }
close ($F);

if (!$fasta && $nseq>0)
  {
    print "#NAMESEQ_01\n";
    print "# $nseq\n";
  }
open ($F, $ARGV[0]);
while(<$F>)
  {
    my $l=$_;
    if ($l=~/^#/){;}
    elsif ($l=~/.\d+\s+\d+\s+(\S+)\s+(\S+)/)
      {
	my $n=$1;
	my $s=$2;
	if ($name{$n}==2)
	  {
	    if ($fasta)
	      {
		print ">$n\n$s\n";
	      }
	    else
	      {
		print "$l";
	      }
	  }
      }
  }
close ($F);
exit (0);



</content>
</file>
<file>
<stream>output</stream>
<name>msf_aln2fasta_aln.pl</name>
<content>#!/usr/bin/env perl
use Env qw(HOST);
use Env qw(HOME);
use Env qw(USER);


$query_start=-1;
$query_end=-1;

while (<>)
  {
    if ( /\/\//){$in_aln=1;}
    elsif ( $in_aln && /(\S+)\s+(.*)/)
      {


	$name=$1;
	

	$seq=$2;
	$seq=~s/\s//g;
        $seq=~s/\~/\-/g;
	$seq=~s/\./\-/g;
	if ( $list{$n}{'name'} && $list{$n}{'name'} ne $name)
	  {
	    print "$list{$n}{'name'} Vs $name";
	    
	    exit (EXIT_FAILURE);
	  }
	else
	  {
	    $list{$n}{'name'}= $name;
	  }

	$list{$n}{'seq'}=$list{$n}{'seq'}.$seq;
	
	$nseq=++$n;
	
      }
    else
      {$n=0;}
  }


for ($a=0; $a<$nseq; $a++)
  {
    print ">$list{$a}{'name'}\n$list{$a}{'seq'}\n";
  }
      

</content>
</file>
<file>
<stream>output</stream>
<name>msa.pl</name>
<content>#!/usr/bin/env perl
$run_anyway=2;
my $msaf="msa.in.tmp.$$";
my $msaoutf="msa.out.tmp.$$";
my $err="msa.out.err.$$";
open  (F, $ARGV[0]);
open  (OUT, ">$msaf");
$nseq=0;
while (<F>)
  {
    $l=$_;
    if ( $l=~/^>(\S+)/)
      {
	$s=$seqname{$nseq++}=$1;
	print OUT "$l";
	
      }
    else 
      {
	$l=uc($l);
	print OUT "$l";
      }
  }

close (F);
close(OUT);

system ("msa $msaf > $msaoutf 2>$err");
open (F, "$msaoutf");
$read=0;
$cn=0;
while (<F>)
  {
    $l=$_;
    if ($read)
      {
	if ($l=~/End gaps not penalized/){$read=0;}
	elsif (!($l=~/\S/))
	  {
	    $cn=0;
	  }
	else
	  {
	    
	    chomp ($l);
	    $seqal{$cn++}.=$l;
	    $tot++;
	  }
      }
    elsif ($l=~/Optimal Multiple Alignment/)
      {
	$read=1;
      }
  }
close (F);

if ($tot<1 && $run_anyway==1)
  {
    print STDERR "\nWarning: MSA returned a NULL file -- Use T-Coffee instead\n";
    open (F,$err);
    while (<F>){print "$_";}
      
    system ("t_coffee -seq $msaf -outfile $ARGV[1]  -quiet");
  }
elsif ($tot<1 && $run_anyway==2)
  {
    
    
    $nseq/=2;
    $nseq=int ($nseq);
    if ($nseq<2){$nseq=2;}
    print "RUN MSA with NSeq=$nseq\n";
    #print ("t_coffee -dpa -dpa_nseq $nseq -seq $ARGV[0] -dpa_tree codnd -outfile $ARGV[1] -dpa_method msa_msa");
    system ("t_coffee -dpa -dpa_nseq $nseq -seq $ARGV[0] -dpa_tree codnd -outfile $ARGV[1] -dpa_method msa_msa>/dev/null");

  }
elsif ($tot<1)
  {
    exit (EXIT_FAILURE);
  }
else
  {
    open (OUT, ">$ARGV[1]");
    for ($a=0; $a<$nseq;$a++)
      {
	print OUT ">$seqname{$a}\n$seqal{$a}\n";
      }
    close (OUT);
  }



unlink ($msaf);
unlink ($msaoutf);
unlink ($err);

</content>
</file>
<file>
<stream>output</stream>
<name>upp.pl</name>
<content>#!/usr/bin/env perl
use strict;
use Cwd;
use File::Basename;
my $test=0;

my $tmpdir="/tmp/tco/aligners/upp/";
mymkdir ($tmpdir);



if ($ARGV[0] eq "one")
  {
    seq2msa ($ARGV[1], $ARGV[2]);
  }
elsif ($ARGV[0] eq "all")
  {
    listseq2listmsa ($ARGV[1]);
  }

sub listseq2listmsa
  {
    my $list=shift;
    my $cdir = getcwd;
    my $dir=random_string(10);
    $dir="$tmpdir/$dir/";
    my %h;
    my $n;
    mkdir  ($dir);

    open (F, $list);
    while (<F>)
      {
        my $l=$_;

        chomp($l);
        my @f=split (/\s+/, $l);
	if ( -e $f[0])
          {
            $h{$n}{in}=$f[0];
            ($h{$n}{name},$h{$n}{path})=fileparse ($f[0]);
            $h{$n}{NFin}= "$dir/$h{$n}{name}.seq";
	    
            $h{$n}{NFout}="$dir/$h{$n}{name}.aln";

            $h{$n}{out}=$f[1];

            fasta2fastaupp ($h{$n}{in}, $h{$n}{NFin});
            $n++;
          }
      }
    close (F);
    chdir ($dir);
    
    if (!$test)
      {
	system ("fbname=\$(basename `ls *.seq` .seq); \
             run_upp.py -s \${fbname}.seq -m amino --cpu 1 -d outdir -o \${fbname}.aln; \
             mv outdir/\${fbname}.aln_alignment.fasta \${fbname}.aln;");
      }
    
    foreach my $n (keys (%h))
      {
	if ($test)
	  {
	    system ("cp $h{$n}{NFin} $h{$n}{NFout}");
	    print "$h{$n}{NFin} $h{$n}{NFout} $h{$n}{out}\n";
	  }
        fastaupp2fasta ($h{$n}{NFout},$h{$n}{out});
      }
    chdir ($cdir);
  }

sub seq2msa
    {
      my ($in, $out)=@_;
      my $cdir=getcwd;
      
      
      if (!($in=~/\//)){$in=$cdir."/".$in;}
      if (!($out=~/\//)){$out=$cdir."/".$out;}
      
      my $file=random_string(10);
      $file="$tmpdir/$file";
      open (F, ">$file");
      print F "$in $out\n";
      close (F);
      
      return listseq2listmsa ($file);
    }
	
sub fasta2fastaupp
  {
    my ($in, $out)=@_;
    my ($name, $seq, $n);
    
    if (!-e $in){return;}
    
    open (IN, "$in");
    open (OUT, ">$out");
    local $/ = "\n>";  # read by FASTA record
    
    while (<IN>)
      {
	my $l=$_;
	$l=~s/>//g;
	$l=">".$l;
	
	$l=~/^>(.*)/;
	$name=$1;
	
	$l=~s/^>*.+\n//;
	$l=~s/\n//g;
	$seq=$l;
	
	$seq=~s/u/x/g;
	$seq=~s/U/X/g;
	print OUT ">$name\n$seq\n";
	$n++;
      }
    if ($n==2)
      {
	print OUT ">fake_seq4upp\n$seq\n";
      }
    close (IN);
    close (OUT);
    local $/="\n";
  }

sub fastaupp2fasta
  {
    my ($in, $out)=@_;
    my ($name, $seq, $n);
    
    if (!-e $in){return;}
    
    open (IN, "$in");
    open (OUT, ">$out");
    local $/ = "\n>";  # read by FASTA record
    
    while (<IN>)
      {
	my $l=$_;
	$l=~s/>//g;
	$l=">".$l;
	
	$l=~/^>(.*)/;
	$name=$1;
	
	$l=~s/^>*.+\n//;
	$l=~s/\n//g;
	$seq=$l;
	
	$seq=~s/x/u/g;
	$seq=~s/X/U/g;
	
	if (!($name=~/fake_seq4upp/))
	  {
	    print OUT ">$name\n$seq\n";
	  }
      }
    close (IN);
    close (OUT);
    local $/="\n";
  }

sub random_string
    {
      my $len=shift;
      my @chars = ("A".."Z", "a".."z");
      my $string;
      $string .= $chars[rand @chars] for 1..$len;
      return $string;
    }

sub mymkdir
      {
	my $d=shift;
	my $cd='/';
	
	foreach my $e (split (/\//, $d))
	  {
	    $cd.="$e/";
	    if ( !-d $cd){mkdir ($cd);}
	  }
	return;
      }
      
			  
      

</content>
</file>
<file>
<stream>output</stream>
<name>clustalo.pl</name>
<content>#!/usr/bin/env perl
use strict;
use Cwd;
use File::Basename;


my $tmpdir="/tmp/tco/aligners/clustalo/";
mymkdir ($tmpdir);



if ($ARGV[0] eq "one")
  {
    seq2msa ($ARGV[1], $ARGV[2]);
  }
elsif ($ARGV[0] eq "all")
  {
    listseq2listmsa ($ARGV[1]);
  }



sub listseq2listmsa
  {
    my $list=shift;
    my $cdir = getcwd;
    my $dir=random_string(10);
    $dir="$tmpdir/$dir/";
    my %h;
    my $n;
    mkdir  ($dir);
    
    open (F, $list);
    while (<F>)
      {
	my $l=$_;

	chomp($l);
	my @f=split (/\s+/, $l);
	#print "$l: 0:$f[0], 1:$f[1]\n";
	if ( -e $f[0])
	  {
	    $h{$n}{in}=$f[0];
	    ($h{$n}{name},$h{$n}{path})=fileparse ($f[0]);
	    $h{$n}{NFin}= "$dir/$h{$n}{name}.seq4nf";
	    $h{$n}{NFout}="$dir/$h{$n}{name}.aln";
	    
	    $h{$n}{out}=$f[1];
	    
	    translate_fasta_seq ("uU", "X",$h{$n}{in}, $h{$n}{NFin});
	    $n++;
	  }
      }
    close (F);
    
    
    chdir ($dir);
    dump_nf ("nf");
    dump_config ();
   
    #system ("nextflow run nf  --name \'*.seq4nf\' >/dev/null 2>/dev/null");
    system ("nextflow run nf  --name \'*.seq4nf\'");
    foreach my $n (keys (%h))
      {
	translate_fasta_seq ("uU", "X",$h{$n}{NFout},$h{$n}{out});
      }
    chdir ($cdir);
  }
sub seq2msa
    {
      my ($in, $out)=@_;
      my $cdir=getcwd;
      
      
      if (!($in=~/\//)){$in=$cdir."/".$in;}
      if (!($out=~/\//)){$out=$cdir."/".$out;}
      
      my $file=random_string(10);
      $file="$tmpdir/$file";
      open (F, ">$file");
      print F "$in $out\n";
      close (F);
      
      return listseq2listmsa ($file);
    }
	
sub seq2msa_old
  {
    my ($in, $out)=@_;
    my $cdir = getcwd;
    my $dir=random_string(10);
    $dir="/tmp/upp.nf4tcoffee/$dir";
    my $seq=random_string(10);
    $seq.=".fa";
    my $aln=$seq;
    $aln.=".aln";
    
    mkdir ($dir);
    translate_fasta_seq ("uU", "X",$in, "$dir/$seq");
    chdir ($dir);
    
    dump_nf ("nf");
    dump_config ();
    print "IN: $in OUT: $cdir/$out\nDIR: $dir\nnextflow run nf  --name \'*.fa\' \n";
    system ("nextflow run nf  --name \'*.fa\' ");
    print "$dir/$aln $cdir/$out\n";
    translate_fasta_seq ("xX", "U",$aln, "$cdir/$out");
    chdir ($cdir);
   } 
sub translate_fasta_seq
  {
    my ($from, $to, $in, $out)=@_;
    my $n;
    my $skip;
    my $l;
    my $cseq;
    if (!-e $in){return;}
    
    open (IN, "$in");
    open (OUT, ">$out");
   
    while (<IN>)
      {
	$l=$_;
	if ($l=~">"){$n++;$cseq="";}
	else { $l=~s/[$from]/$to/;$cseq.=$l;}

	if ($skip){$skip=0;}
	elsif ($l=~/>fake_seq/){$skip=1;}
	else
	  {
	    print OUT "$l";
	  }
      }
    if ($n==2 && $from eq "uU")
      {
	print OUT ">fake_seq\n$cseq\n";
      }
    close (IN);
    close (OUT);
  }

sub dump_config
    {
      open (F, ">nextflow.config");

      print F "docker.enabled = true\n";
      print F "process.container = \'cbcrg/benchfam_large_scale\'\n";
      close (F);
    }

sub dump_nf
  {
    my $nff=shift;
    open (F,">$nff");
    print F "#!/usr/bin/env nextflow\n";
    print F "params.base_dir=\"./\"\n";
    print F "params.out_dir=\"./\"\n";
    print F "Channel.fromPath(params.name)\n";
    print F "\t.map{ tuple(it.baseName, it) }\n";
    
    print F "\t.set{ file_names_1 }\n";
    print F "process clustalo_align{\n";
    print F "\tpublishDir params.out_dir, mode: \"copy\"\n";
    print F "tag \"\${name}\"";
    print F "\n";
    print F "\tinput:\n";
    print F "\tset name, file(seq_file) from file_names_1\n";
    print F "\toutput:\n";
    print F "\tfile \"\${name}.aln\"\n";
    print F "\n";
    print F " \"\"\"\n";
    print F " clustalo -i \$seq_file -o \${name}.aln\n";
    print F "\"\"\"\n\n";
    print F "}\n";
    close (F);
  }

sub random_string
    {
      my $len=shift;
      my @chars = ("A".."Z", "a".."z");
      my $string;
      $string .= $chars[rand @chars] for 1..$len;
      return $string;
    }

sub mymkdir
      {
	my $d=shift;
	my $cd='/';
	
	foreach my $e (split (/\//, $d))
	  {
	    $cd.="$e/";
	    if ( !-d $cd){mkdir ($cd);}
	  }
	return;
      }
      
			  
      

</content>
</file>
<file>
<stream>output</stream>
<name>dca.pl</name>
<content>#!/usr/bin/env perl

my $msaf="msa.in.tmp.$$";
my $msaoutf="msa.out.tmp.$$";
my $cost="blosum62.tmp.$$";

open  (F, $ARGV[0]);
open  (OUT, ">$msaf");
$nseq=0;
while (<F>)
  {
    $l=$_;
    if ( $l=~/^>(\S+)/)
      {
	my $simple="Seq$nseq";
	$s=$seqname{$nseq++}=$1;
	$translate{$simple}=$s;
	
	print OUT ">$simple\n";
	
      }
    else
      {
	$l=uc($l);
	print OUT "$l";
      }
  }
close (F);
close(OUT);

dump_blosum ($cost);
system ("dca -c $cost -q $msaf> $msaoutf 2>/dev/null");
open (F, "$msaoutf");
open (OUT, ">$ARGV[1]");

$read=0;
while (<F>)
  {
    $l=$_;
    if ($l=~/^>(\S+)/)
      {
	$read=1;
	$name=$translate{$1};
	print OUT ">$name\n";
      }
    elsif ($read && ($l=~/\S/))
      {
	print OUT "$l";
      }
    else
      {
	$read=0;
      }
  }
close (F);

unlink ($cost);
unlink ($msaf);
unlink ($msaoutf);

sub dump_blosum
  {
    my $f=shift;
    open (F, ">$f");

    print F "6\n";
    print F "- -   0\n";
    print F "W W   0\n";
    print F "Y Y   4\n";
    print F "F F   5\n";
    print F "V V   7\n";
    print F "L L   7\n";
    print F "I I   7\n";
    print F "M M   6\n";
    print F "K K   6\n";
print F "R R   6\n";
    print F "H H   3\n";
    print F "Q Q   6\n";
    print F "E E   6\n";
    print F "D D   5\n";
    print F "N N   5\n";
    print F "G G   5\n";
    print F "A A   7\n";
    print F "P P   4\n";
    print F "T T   6\n";
    print F "S S   7\n";
    print F "C C   2\n";
    print F "- C  10 \n";
    print F "- S  10\n";
    print F "- T  10 \n";
    print F "- P  10\n";
    print F "- A  10 \n";
    print F "- G  10\n";
    print F "- N  10 \n";
    print F "- D  10\n";
    print F "- E  10 \n";
    print F "- Q  10\n";
print F "- H  10 \n";
    print F "- R  10\n";
    print F "- K  10 \n";
    print F "- M  10\n";
    print F "- I  10 \n";
    print F "- L  10\n";
    print F "- V  10 \n";
    print F "- F  10\n";
    print F "- Y  10 \n";
    print F "- W  10\n";
    print F "W C  13 \n";
    print F "W S  14\n";
    print F "W T  13 \n";
    print F "W P  15\n";
    print F "W A  14 \n";
    print F "W G  13\n";
    print F "W N  15 \n";
    print F "W D  15\n";
    print F "W E  14 \n";
    print F "W Q  13\n";
    print F "W H  13 \n";
    print F "W R  14\n";
    print F "W K  14 \n";
    print F "W M  12\n";
    print F "W I  14 \n";
    print F "W L  13\n";
    print F "W V  14 \n";
    print F "W F  10\n";
    print F "W Y   9 \n";
    print F "Y C  13\n";
    print F "Y S  13 \n";
    print F "Y T  13\n";
    print F "Y P  14 \n";
    print F "Y A  13\n";
    print F "Y G  14 \n";
    print F "Y N  13\n";
    print F "Y D  14 \n";
    print F "Y E  13\n";
    print F "Y Q  12 \n";
    print F "Y H   9\n";
    print F "Y R  13 \n";
    print F "Y K  13\n";
    print F "Y M  12 \n";
    print F "Y I  12\n";
    print F "Y L  12 \n";
    print F "Y V  12\n";
    print F "Y F   8 \n";
    print F "F C  13\n";
print F "F S  13 \n";
    print F "F T  13\n";
    print F "F P  15 \n";
    print F "F A  13\n";
    print F "F G  14 \n";
    print F "F N  14\n";
    print F "F D  14 \n";
    print F "F E  14\n";
    print F "F Q  14 \n";
    print F "F H  12\n";
    print F "F R  14 \n";
    print F "F K  14\n";
    print F "F M  11 \n";
    print F "F I  11\n";
    print F "F L  11 \n";
    print F "F V  12\n";
    print F "V C  12 \n";
    print F "V S  13\n";
    print F "V T  11 \n";
    print F "V P  13\n";
    print F "V A  11 \n";
    print F "V G  14\n";
    print F "V N  14 \n";
    print F "V D  14\n";
print F "V E  13 \n";
print F "V Q  13\n";
print F "V H  14 \n";
print F "V R  14\n";
print F "V K  13 \n";
print F "V M  10\n";
print F "V I   8 \n";
print F "V L  10\n";
print F "L C  12 \n";
print F "L S  13\n";
print F "L T  12 \n";
print F "L P  14\n";
print F "L A  12 \n";
print F "L G  15\n";
print F "L N  14 \n";
print F "L D  15\n";
print F "L E  14 \n";
print F "L Q  13\n";
print F "L H  14 \n";
print F "L R  13\n";
print F "L K  13 \n";
print F "L M   9\n";
print F "L I   9 \n";
print F "I C  12\n";
print F "I S  13 \n";
print F "I T  12\n";
print F "I P  14 \n";
print F "I A  12\n";
print F "I G  15 \n";
print F "I N  14\n";
print F "I D  14 \n";
print F "I E  14\n";
print F "I Q  14 \n";
print F "I H  14\n";
print F "I R  14 \n";
print F "I K  14\n";
print F "I M  10 \n";
print F "M C  12\n";
print F "M S  12 \n";
print F "M T  12\n";
print F "M P  13 \n";
print F "M A  12\n";
print F "M G  14 \n";
print F "M N  13\n";
print F "M D  14 \n";
print F "M E  13\n";
print F "M Q  11 \n";
print F "M H  13\n";
print F "M R  12 \n";
print F "M K  12\n";
print F "K C  14 \n";
print F "K S  11\n";
print F "K T  12 \n";
print F "K P  12\n";
print F "K A  12 \n";
print F "K G  13\n";
print F "K N  11 \n";
print F "K D  12\n";
print F "K E  10 \n";
print F "K Q  10\n";
print F "K H  12 \n";
print F "K R   9\n";
print F "R C  14 \n";
print F "R S  12\n";
print F "R T  12 \n";
print F "R P  13\n";
print F "R A  12 \n";
print F "R G  13\n";
print F "R N  11 \n";
print F "R D  13\n";
print F "R E  11 \n";
print F "R Q  10\n";
print F "R H  11 \n";
print F "H C  14\n";
print F "H S  12 \n";
print F "H T  13\n";
print F "H P  13 \n";
print F "H A  13\n";
print F "H G  13 \n";
print F "H N  10\n";
print F "H D  12 \n";
print F "H E  11\n";
print F "H Q  11 \n";
print F "Q C  14\n";
print F "Q S  11 \n";
print F "Q T  12\n";
print F "Q P  12 \n";
print F "Q A  12\n";
print F "Q G  13 \n";
print F "Q N  11\n";
print F "Q D  11 \n";
print F "Q E   9\n";
print F "E C  15 \n";
print F "E S  11\n";
print F "E T  12 \n";
print F "E P  12\n";
print F "E A  12 \n";
print F "E G  13\n";
print F "E N  11 \n";
print F "E D   9\n";
print F "D C  14 \n";
print F "D S  11\n";
print F "D T  12 \n";
print F "D P  12\n";
print F "D A  13 \n";
print F "D G  12\n";
print F "D N  10 \n";
print F "N C  14\n";
print F "N S  10 \n";
print F "N T  11\n";
print F "N P  13 \n";
print F "N A  13\n";
print F "N G  11 \n";
print F "G C  14\n";
print F "G S  11 \n";
print F "G T  13\n";
print F "G P  13 \n";
print F "G A  11\n";
print F "A C  11 \n";
print F "A S  10\n";
print F "A T  11 \n";
print F "A P  12\n";
print F "P C  14 \n";
print F "P S  12\n";
print F "P T  12 \n";
print F "T C  12\n";
print F "T S  10 \n";
print F "S C  12\n";
close (F);
    return;
  }
    

</content>
</file>
<file>
<stream>output</stream>
<name>blast_aln2fasta_aln.pl</name>
<content>#!/usr/bin/env perl

use Env qw(HOST);
use Env qw(HOME);
use Env qw(USER);

                                                        
use strict;                                             
use warnings;
use diagnostics;

my $in_hit_list, my $in_aln=0, my(%name_list)=(),my (%list)=(),my $n_seq=0; my $test=0;
my($j)=0, my $n=0, my $nom, my $lg_query, my %vu=();

open (F, ">tmp");

$/="\n";
while (<>)
{
    print F $_;
    if($_ =~ /Query=\s*(.+?)\s/i) { $nom=$1;}

    if ( /Sequences producing significant alignments/){$in_hit_list=1;}
    
    if ($_=~ /^pdb\|/i) { $_=~ s/pdb\|//g; }
    if ($_=~ /^(1_\d+)\s+\d+/) { $_=~ s/$1/QUERY/;}
      
    if ( /^(\S+).+?\s+[\d.]+\s+([\de.-]+)\s+$/ && $in_hit_list)	
    {
	my($id)=$1; # 
	$id=~ s/\|/_/g; #
	if ($id =~ /.+_$/) { chop($id) }; #
	$name_list{$n_seq++}=$id;
	$name_list{$n_seq-1}=~ s/.*\|//g;     
    }
  
    if (/query/i) {$in_aln=1;}
    if ( /^(\S+)\s+(\d+)\s+([a-zA-Z-]+)\s+(\d+)/ || /^(\S+)(\s+)(\-+)(\s+)/ && ($in_aln == 1))
    {
	my $name=$1;
	my $start=$2;
	my $seq=$3;
	my $end=$4;
		
	if ($name =~ /QUERY/i) { $lg_query=length($seq); }

	unless ($test > $n) #m
	{
	    my(@seqq)= split('',$seq);
	    my($gap_missing)= scalar(@seqq);
	    
	    while ($gap_missing != $lg_query)  { unshift (@seqq,"-"); $gap_missing= scalar(@seqq); }
	    $seq=join('',@seqq);  #m
	}
	
	if ($name =~ /QUERY/i)
	{
	    $n=0; %vu=(); $j=0;
	    $list{$n}{'real_name'}="$nom";
	}	
	else
	{
	    unless (exists $vu{$name}) { ++$j;}	
	    $list{$n}{'real_name'}=$name_list{$j-1};
	}
		
	$list{$n}{'name'}=$name;

	$seq=~tr/a-z/A-Z/;
	$list{$n}{'seq'}=$list{$n}{'seq'};
	$list{$n}{'seq'}.=$seq;

	$n++;
	$vu{$name}++;
	$test++;
   } 
    
}

my @numero=();

for (my $a=0; $a<$n; $a++) #m
{
    my $long=length($list{0}{'seq'});  
    my $long1= length($list{$a}{'seq'});
  
    while ($long1 ne $long)
    {
	$list{$a}{'seq'}.="-";
	$long1= length ($list{$a}{'seq'});
    } 
 
    push (@numero,"$list{$a}{'name'} $list{$a}{'real_name'}\n");
}

my %dejavu=();


for (my $i=0; $i<=$#numero; $i++)
{
    my $s=">$list{$i}{'real_name'}\n$list{$i}{'seq'}\n";
    my $k=0;
    
    if (exists $dejavu{$numero[$i]}) {next;}
    else
    {	
	for ($j=0; $j<$n ; $j++)
	{
	    if ("$numero[$i]" eq "$numero[$j]" && $j != $i )
	    {
		++$k;
		$s .=">$list{$j}{'real_name'}\n$list{$j}{'seq'}\n";
	    }
	}	
    }
    
    if ($k>0) 
    {
	my $cons;
	open (SOR,">tempo_aln2cons"); print SOR $s;  close SOR ;
	open (COM,"t_coffee -other_pg seq_reformat -in tempo_aln2cons -action +aln2cons +upper |") ; 
     	while (<COM>)
	{	
	    if (/^>/) { $cons =">$list{$i}{'real_name'}\n"; next;}
	    $_=~ s/\n//g;
	    $cons .=$_;
	}
	close COM; unlink ("tempo_aln2cons");
	print $cons,"\n"; print F $cons,"\n";
    }	
    else  { print $s;  print F $s; }
    
    $dejavu{$numero[$i]}++;
} #m

exit;












</content>
</file>
<file>
<stream>output</stream>
<name>blast_xml2fasta_aln.pl</name>
<content>#!/usr/bin/env perl
use Env;


$tmp_dir="";
$init_dir="";
$program="tc_generic_method.pl";

$blast=@ARGV[0];

$name="query";$seq="";
%p=blast_xml2profile($name,$seq,100, 0, 0, $blast);
&output_profile (%p);


sub output_profile
  {
    my (%profile)=(@_);
    my ($a);
    for ($a=0; $a<$profile{n}; $a++)
      {
	
	print ">$profile{$a}{name} $profile{$a}{comment}\n$profile{$a}{seq}\n";
      }
    return;
  }
sub file_contains 
  {
    my ($file, $tag, $max)=(@_);
    my ($n);
    $n=0;
    
    if ( !-e $file && ($file =~/$tag/)) {return 1;}
    elsif ( !-e $file){return 0;}
    else 
      {
	open (FC, "$file");
	while ( <FC>)
	  {
	    if ( ($_=~/$tag/))
	      {
		close (FC);
		return 1;
	      }
	    elsif ($max && $n>$max)
	      {
		close (FC);
		return 0;
	      }
	    $n++;
	  }
      }
    close (FC);
    return 0;
  }
	    
	  
sub file2string
  {
    my $f=@_[0];
    my $string, $l;
    open (F,"$f");
    while (<F>)
      {

	$l=$_;
	#chomp ($l);
	$string.=$l;
      }
    close (F);
    $string=~s/\r\n//g;
    $string=~s/\n//g;
    return $string;
  }



sub tag2value 
  {
    
    my $tag=(@_[0]);
    my $word=(@_[1]);
    my $return;
    
    $tag=~/$word="([^"]+)"/;
    $return=$1;
    return $return;
  }
      
sub hit_tag2pdbid
  {
    my $tag=(@_[0]);
    my $pdbid;
       
    $tag=~/id="(\S+)"/;
    $pdbid=$1;
    $pdbid=~s/_//;
    return $pdbid;
  }
sub id2pdbid 
  {
    my $id=@_[0];
  
    if ($id =~/pdb/)
      {
	$id=~/pdb(.*)/;
	$id=$1;
      }
    $id=~s/[|_]//g;
    return $id;
  }
sub set_blast_type 
  {
    my $file =@_[0];
    if (&file_contains ($file,"EBIApplicationResult",100)){$BLAST_TYPE="EBI";}
    elsif (&file_contains ($file,"NCBI_BlastOutput",100)) {$BLAST_TYPE="NCBI";}
    else
      {
	$BLAST_TYPE="";
      }
    return $BLAST_TYPE;
  }
sub blast_xml2profile 
  {
    my ($name,$seq,$maxid, $minid, $mincov, $file)=(@_);
    my (%p, $a, $string, $n);
    


    if ($BLAST_TYPE eq "EBI" || &file_contains ($file,"EBIApplicationResult",100)){%p=ebi_blast_xml2profile(@_);}
    elsif ($BLAST_TYPE eq "NCBI" || &file_contains ($file,"NCBI_BlastOutput",100)){%p=ncbi_blast_xml2profile(@_);}
    else 
      {
	print "************ ERROR: Blast Returned an unknown XML Format **********************";
	die;
      }
    for ($a=0; $a<$p{n}; $a++)
      {
	my $name=$p{$a}{name};
	$p{$name}{seq}=$p{$a}{seq};
      }
    return %p;
  }
sub ncbi_blast_xml2profile 
  {
    my ($name,$seq,$maxid, $minid, $mincov, $string)=(@_);
    my ($L,$l, $a,$b,$c,$d,$nhits,@identifyerL);
    
    
    $seq=~s/[^a-zA-Z]//g;
    $L=length ($seq);
    
    %hit=&xml2tag_list ($string, "Hit");
    
    
    for ($nhits=0,$a=0; $a<$hit{n}; $a++)
      {
	my ($ldb,$id, $identity, $expectation, $start, $end, $coverage, $r);
	my (%ID,%DE,%HSP);
	
	$ldb="";

	%ID=&xml2tag_list ($hit{$a}{body}, "Hit_id");
	$identifyer=$ID{0}{body};
	
	%DE=&xml2tag_list ($hit{$a}{body}, "Hit_def");
	$definition=$DE{0}{body};
	
	%HSP=&xml2tag_list ($hit{$a}{body}, "Hsp");
	for ($b=0; $b<$HSP{n}; $b++)
	  {
	    my (%START,%END,%E,%I,%Q,%M);

	 
	    %START=&xml2tag_list ($HSP{$b}{body}, "Hsp_query-from");
	    %HSTART=&xml2tag_list ($HSP{$b}{body}, "Hsp_hit-from");
	    
	    %LEN=  &xml2tag_list ($HSP{$b}{body}, "Hsp_align-len");
	    %END=  &xml2tag_list ($HSP{$b}{body}, "Hsp_query-to");
	    %HEND=  &xml2tag_list ($HSP{$b}{body}, "Hsp_hit-to");
	    %E=&xml2tag_list     ($HSP{$b}{body}, "Hsp_evalue");
	    %I=&xml2tag_list     ($HSP{$b}{body}, "Hsp_identity");
	    %Q=&xml2tag_list     ($HSP{$b}{body}, "Hsp_qseq");
	    %M=&xml2tag_list     ($HSP{$b}{body}, "Hsp_hseq");
	    
	    for ($e=0; $e<$Q{n}; $e++)

	      {
		$qs=$Q{$e}{body};
		$ms=$M{$e}{body};
		if ($seq eq""){$seq=$qs;$L=length($seq);}
		
		$expectation=$E{$e}{body};
		$identity=($LEN{$e}{body}==0)?0:$I{$e}{body}/$LEN{$e}{body}*100;
		$start=$START{$e}{body};
		$end=$END{$e}{body};
		$Hstart=$HSTART{$e}{body};
		$Hend=$HEND{$e}{body};
	
		$coverage=(($end-$start)*100)/$L;

	
		if ($identity>$maxid || $identity<$minid || $coverage<$mincov){next;}
		@lr1=(split (//,$qs));
		@lr2=(split (//,$ms));
		$l=$#lr1+1;
		for ($c=0;$c<$L;$c++){$p[$nhits][$c]="-";}
		for ($d=0,$c=0; $c<$l; $c++)
		  {
		    $r=$lr1[$c];
		    if ( $r=~/[A-Za-z]/)
		      {
			
			$p[$nhits][$d + $start-1]=$lr2[$c];
			$d++;
		      }
		  }
		$Qseq[$nhits]=$qs;
		$Hseq[$nhits]=$ms;
		$QstartL[$nhits]=$start;
		$HstartL[$nhits]=$Hstart;
		$identityL[$nhits]=$identity;
		$endL[$nhits]=$end;
		$definitionL[$nhits]=$definition;
		$identifyerL[$nhits]=$identifyer;
		$comment[$nhits]="$ldb|$identifyer [Eval=$expectation][id=$identity%][start=$Hstart end=$Hend]";
		$nhits++;
	      }
	  }
      }
    
    $profile{n}=0;
    $profile{$profile{n}}{name}=$name;
    $profile{$profile{n}}{seq}=$seq;
    $profile {n}++;
    
    for ($a=0; $a<$nhits; $a++)
      {
	$n=$a+1;
	
	$profile{$n}{name}="$name\_$a";
	$profile{$n}{seq}="";
	$profile{$n}{Qseq}=$Qseq[$a];
	$profile{$n}{Hseq}=$Hseq[$a];
	$profile{$n}{Qstart}=$QstartL[$a];
	$profile{$n}{Hstart}=$HstartL[$a];
	$profile{$n}{identity}=$identityL[$a];
	$profile{$n}{definition}=$definitionL[$a];
	$profile{$n}{identifyer}=$identifyerL[$a];
	$profile{$n}{comment}=$comment[$a];
	for ($b=0; $b<$L; $b++)
	  {
	    if ($p[$a][$b])
	      {
		$profile{$n}{seq}.=$p[$a][$b];
	      }
	    else
	      {
		$profile{$n}{seq}.="-";
	      }
	  }
      }
    
    $profile{n}=$nhits+1;
    return %profile;
  }
sub ebi_blast_xml2profile 
  {
    my ($name,$seq,$maxid, $minid, $mincov, $string)=(@_);
    my ($L,$l, $a,$b,$c,$d,$nhits,@identifyerL,$identifyer);
    

    
    $seq=~s/[^a-zA-Z]//g;
    $L=length ($seq);
    %hit=&xml2tag_list ($string, "hit");
    
    for ($nhits=0,$a=0; $a<$hit{n}; $a++)
      {
	my ($ldb,$id, $identity, $expectation, $start, $end, $coverage, $r);
	my (%Q,%M,%E,%I);
	
	$ldb=&tag2value ($hit{$a}{open}, "database");
	$identifyer=&tag2value ($hit{$a}{open}, "id");

	$description=&tag2value ($hit{$a}{open}, "description");
	
	%Q=&xml2tag_list ($hit{$a}{body}, "querySeq");
	%M=&xml2tag_list ($hit{$a}{body}, "matchSeq");
	%E=&xml2tag_list ($hit{$a}{body}, "expectation");
	%I=&xml2tag_list ($hit{$a}{body}, "identity");
	

	for ($b=0; $b<$Q{n}; $b++)
	  {
	    
	    
	    $qs=$Q{$b}{body};
	    $ms=$M{$b}{body};
	    if ($seq eq""){$seq=$qs;$L=length($seq);}

	    $expectation=$E{$b}{body};
	    $identity=$I{$b}{body};
	    
	    	    
	    $start=&tag2value ($Q{$b}{open}, "start");
	    $end=&tag2value ($Q{$b}{open}, "end");
	    $startM=&tag2value ($M{$b}{open}, "start");
	    $endM=&tag2value ($M{$b}{open}, "end");
	    $coverage=(($end-$start)*100)/$L;
	    
	   # print "$id: ID: $identity COV: $coverage [$start $end]\n";
	    
	    
	    if ($identity>$maxid || $identity<$minid || $coverage<$mincov){next;}
	    # print "KEEP\n";

	    
	    @lr1=(split (//,$qs));
	    @lr2=(split (//,$ms));
	    $l=$#lr1+1;
	    for ($c=0;$c<$L;$c++){$p[$nhits][$c]="-";}
	    for ($d=0,$c=0; $c<$l; $c++)
	      {
		$r=$lr1[$c];
		if ( $r=~/[A-Za-z]/)
		  {
		    
		    $p[$nhits][$d + $start-1]=$lr2[$c];
		    $d++;
		  }
	      }
	  
	    
	    $identifyerL[$nhits]=$identifyer;
	    $comment[$nhits]="$ldb|$identifyer [Eval=$expectation][id=$identity%][start=$startM end=$endM]";
	    $nhits++;
	  }
      }
    
    $profile{n}=0;
    $profile{$profile{n}}{name}=$name;
    $profile{$profile{n}}{seq}=$seq;
    $profile {n}++;
    
    for ($a=0; $a<$nhits; $a++)
      {
	$n=$a+1;
	$profile{$n}{name}="$name\_$a";
	$profile{$n}{seq}="";
	$profile{$n}{identifyer}=$identifyerL[$a];
	
	$profile{$n}{comment}=$comment[$a];
	for ($b=0; $b<$L; $b++)
	  {
	    if ($p[$a][$b])
	      {
		$profile{$n}{seq}.=$p[$a][$b];
	      }
	    else
	      {
		$profile{$n}{seq}.="-";
	      }
	  }
      }
    $profile{n}=$nhits+1;
    
    return %profile;
  }

sub blast_xml2hit_list
  {
    my $string=(@_[0]);
    return &xml2tag_list ($string, "hit");
  }
sub xml2tag_list  
  {
    my ($string_in,$tag)=@_;
    my $tag_in, $tag_out;
    my %tag;
    
    if (-e $string_in)
      {
	$string=&file2string ($string_in);
      }
    else
      {
	$string=$string_in;
      }
    $tag_in1="<$tag ";
    $tag_in2="<$tag>";
    $tag_out="/$tag>";
    $string=~s/>/>##1/g;
    $string=~s/</##2</g;
    $string=~s/##1/<#/g;
    $string=~s/##2/#>/g;
    @l=($string=~/(\<[^>]+\>)/g);
    $tag{n}=0;
    $in=0;$n=-1;
  
 

    foreach $t (@l)
      {

	$t=~s/<#//;
	$t=~s/#>//;
	
	if ( $t=~/$tag_in1/ || $t=~/$tag_in2/)
	  {
	 
	    $in=1;
	    $tag{$tag{n}}{open}=$t;
	    $n++;
	    
	  }
	elsif ($t=~/$tag_out/)
	  {
	    

	    $tag{$tag{n}}{close}=$t;
	    $tag{n}++;
	    $in=0;
	  }
	elsif ($in)
	  {
	   
	    $tag{$tag{n}}{body}.=$t;
	  }
      }
  
    return %tag;
  }





</content>
</file>
<file>
<stream>output</stream>
<name>fasta_aln2fasta_aln_unique_name.pl</name>
<content>#!/usr/bin/env perl
use Env qw(HOST);
use Env qw(HOME);
use Env qw(USER);
while (<>)
  {
    if ( /^>(\S+)/)
      {
	if ($list{$1})
	  {
	    print ">$1_$list{$1}\n";
	    $list{$1}++;
	  }
	else
	  {
	    print $_;
	    $list{$1}=1;
	  }
      }
    else
      {
	print $_;
      }
  }
      

</content>
</file>
<file>
<stream>output</stream>
<name>newick2name_list.pl</name>
<content>#!/usr/bin/env perl



use Env qw(HOST);
use Env qw(HOME);
use Env qw(USER);


open (F,$ARGV[0]);
while ( <>)
  {
    @x=/([^:,;\)\(\s]+):[^:,;\)\(]*/g;
    @list=(@list,@x);
  }
$n=$#list+1;
foreach $n(@list){print ">$n\nsequence\n";}


close (F);

</content>
</file>
<file>
<stream>output</stream>
<name>excel2fasta.pl</name>
<content>#!/usr/bin/env perl

open (F, $ARGV[0]);

while ( <F>)
  {
    @l=($_=~/(\S+)/g);
    
    $name=shift @l;
    
    print STDOUT "\n>$name\n";
    foreach $e (@l){$e=($e eq "0")?"O":"I";print "$e";}
  }
close (F);

		       
    

</content>
</file>
<file>
<stream>output</stream>
<name>nameseq2fasta.pl</name>
<content>#!/usr/bin/env perl
use strict;
use FileHandle;
use Env qw(HOST);
use Env qw(HOME);
use Env qw(USER);
my %name;
my $nseq;
my $F= new FileHandle;
open ($F, $ARGV[0]);
while(<$F>)
  {
    
    my $l=$_;
    if ($l=~/^#/){;}
    elsif (($l=~/\d+\s+\d+\s+(\S+)\s+(\S+)/))
      {
	my $name=$1;
	my $seq=$2;
	print ">$name\n$seq\n";
      }
  }
close ($F);
exit (0);



</content>
</file>
<file>
<stream>output</stream>
<name>any_file2unix_file.pl</name>
<content>#!/usr/bin/env perl
use Env qw(HOST);
use Env qw(HOME);
use Env qw(USER);

$tmp="$ARGV[0].$$";
open (IN, $ARGV[0]);
open (OUT, ">$tmp");

while ( <IN>)
  {
    $file=$_;
    $file=~s/\r\n/\n/g;
    $file=~s/\n\r/\n/g;
    $file=~s/\r\r/\n/g;
    $file=~s/\r/\n/g;
    print OUT "$file";
  }
close (IN);
close (OUT);

open (OUT, ">$ARGV[0]");
open (IN, "$tmp");

while ( <IN>)
{
  print OUT "$_";
}
close (IN);
close (OUT);
unlink ($tmp);


</content>
</file>
<environement>
HOME_4_TCOFFEE=/Users/cnotredame/
MANPATH=/sw/share/man:/usr/share/man:/usr/local/share/man:/opt/X11/share/man:/Library/TeX/texbin/man:/Applications/Xcode.app/Contents/Developer/usr/share/man:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/share/man:/sw/lib/perl5/5.18.2/man
TERM_PROGRAM=Apple_Terminal
MCOFFEE_4_TCOFFEE=/Users/cnotredame//.t_coffee//mcoffee/
ROOT_TMP_4_TCOFFEE=/var/tmp/
SHELL=/bin/bash
TERM=xterm-256color
TMPDIR=/var/folders/42/7kdsjftx00g91b_dwj3f82nw0000gp/T/
CONDA_SHLVL=1
PERL5LIB=/sw/lib/perl5:/sw/lib/perl5/darwin
Apple_PubSub_Socket_Render=/private/tmp/com.apple.launchd.6JzhyrtuKp/Render
CONDA_PROMPT_MODIFIER=(base) 
TERM_PROGRAM_VERSION=388.1.3
OSNAME=macosx
PERL_BIN=/Users/cnotredame/Dropbox/projects/git/tcoffee/lib/perl/lib/algorithms::/Users/cnotredame/Dropbox/projects/git/tcoffee/lib/perl/lib/debug:/Users/cnotredame/Dropbox/projects/git/tcoffee/lib/perl/lib/perl4data_process:/Users/cnotredame/Dropbox/projects/git/tcoffee/lib/perl/lib/filters:/Users/cnotredame/Dropbox/projects/git/tcoffee/lib/perl/lib/perl4makefile:/Users/cnotredame/Dropbox/projects/git/tcoffee/lib/perl/lib/util:/Users/cnotredame/Dropbox/projects/git/tcoffee/lib/perl/lib/benchmark:/Users/cnotredame/Dropbox/projects/git/tcoffee/lib/perl/lib/scripts:/Users/cnotredame/Dropbox/projects/git/tcoffee/lib/perl/lib/stat:/Users/cnotredame/Dropbox/projects/git/tcoffee/lib/perl/lib/droit:/Users/cnotredame/Dropbox/projects/git/tcoffee/lib/perl/lib/phecomp:/Users/cnotredame/Dropbox/projects/git/tcoffee/lib/perl/lib/hmm:/Users/cnotredame/Dropbox/projects/git/tcoffee/lib/perl/lib/webservices
TERM_SESSION_ID=9785BD0D-F6F1-4B59-B0BA-9937FD12A1E7
METHODS_4_TCOFFEE=/Users/cnotredame//.t_coffee//methods/
VERSIONER_PERL_VERSION=5.18
XAPPLRESDIR=/sw/etc/app-defaults/
http_proxy=
HTTP_proxy=
USER=cnotredame
CONDA_EXE=/Users/cnotredame/anaconda3/bin/conda
SSH_AUTH_SOCK=/private/tmp/com.apple.launchd.U5mTe2o7m7/Listeners
__CF_USER_TEXT_ENCODING=0x1F6:0x0:0x0
ENV_4_TCOFFEE=/Users/cnotredame//.t_coffee//.t_coffee_env
_CE_CONDA=
all_proxy=
ALL_PROXY=
HTTP_proxy_4_TCOFFEE=
PATH=/Users/cnotredame/anaconda3/bin:/Users/cnotredame/anaconda3/condabin:/opt/local/bin:/opt/local/sbin:/opt/local/bin:/opt/local/sbin:/Users/cnotredame/.t_coffee/plugins/macosx:/Users/cnotredame/Dropbox/packages/x3dna-v2.1/bin:/Users/cnotredame/bin/macosx://Users/cnotredame/.t_coffee/plugins/macosx:/Users/cnotredame/Dropbox/projects/git/tcoffee/lib/perl/lib/algorithms:.:/Users/cnotredame/Dropbox/projects/git/tcoffee/lib/perl/lib/debug:/Users/cnotredame/Dropbox/projects/git/tcoffee/lib/perl/lib/perl4data_process:/Users/cnotredame/Dropbox/projects/git/tcoffee/lib/perl/lib/filters:/Users/cnotredame/Dropbox/projects/git/tcoffee/lib/perl/lib/perl4makefile:/Users/cnotredame/Dropbox/projects/git/tcoffee/lib/perl/lib/util:/Users/cnotredame/Dropbox/projects/git/tcoffee/lib/perl/lib/benchmark:/Users/cnotredame/Dropbox/projects/git/tcoffee/lib/perl/lib/scripts:/Users/cnotredame/Dropbox/projects/git/tcoffee/lib/perl/lib/stat:/Users/cnotredame/Dropbox/projects/git/tcoffee/lib/perl/lib/droit:/Users/cnotredame/Dropbox/projects/git/tcoffee/lib/perl/lib/phecomp:/Users/cnotredame/Dropbox/projects/git/tcoffee/lib/perl/lib/hmm:/Users/cnotredame/Dropbox/projects/git/tcoffee/lib/perl/lib/webservices:/Users/cnotredame/bin/Scripts:/Users/cnotredame/Library/Haskell/ghc-7.4.2/lib/epub-tools-2.0.0/bin:/sw/bin:/sw/sbin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin:/Library/TeX/texbin
_=/usr/bin/printenv
CONDA_PREFIX=/Users/cnotredame/anaconda3
DIR_4_TCOFFEE=/Users/cnotredame//.t_coffee/
PWD=/private/var/folders/42/7kdsjftx00g91b_dwj3f82nw0000gp/T/RANDOMSTRINGLUDCXA3Yilq06fX88A4u/data
CACHE_4_TCOFFEE=/Users/cnotredame//.t_coffee//cache/
X3DNA=/Users/cnotredame/Dropbox/packages/x3dna-v2.1
DBUS_LAUNCHD_SESSION_BUS_SOCKET=/private/tmp/com.apple.launchd.DfqaaC2z17/unix_domain_listener
XPC_FLAGS=0x0
VERSIONER_PERL_PREFER_32_BIT=no
_CE_M=
XPC_SERVICE_NAME=0
ERRORFILE_4_TCOFFEE=t_coffee.ErrorReport
PLUGINS_4_TCOFFEE=/Users/cnotredame//.t_coffee//plugins/macosx/
SHLVL=3
HOME=/Users/cnotredame
DUMP_4_TCOFFEE=/private/var/folders/42/7kdsjftx00g91b_dwj3f82nw0000gp/T/RANDOMSTRINGLUDCXA3Yilq06fX88A4u/tcoffee_technical_documentation.rst.8.dump
HTTP_PROXY=
MAFFT_BINARIES=
CONDA_PYTHON_EXE=/Users/cnotredame/anaconda3/bin/python
BIN=/Users/cnotredame/bin/macosx
LOGNAME=cnotredame
EMAIL_4_TCOFFEE=cedric.notredame@gmail.com
LC_CTYPE=UTF-8
CONDA_DEFAULT_ENV=base
EMAIL=cedric.notredame@gmail.com
UPDATED_ENV_4_TCOFFEE=1
INFOPATH=/sw/share/info:/sw/info:/usr/share/info
DISPLAY=/private/tmp/com.apple.launchd.vef8UzGxBY/org.macosforge.xquartz:0
TC_MASTER_NODE=1
NUMBER_OF_PROCESSORS=8
ALL_proxy=
LOCKDIR_4_TCOFFEE=/var/tmp/tco/tcoqubs2o4484827//lck/bomnb3hwz3/
TMP_4_TCOFFEE=/var/tmp/tco/tcoqubs2o4484827/
USER_BIN=/Users/cnotredame/bin/macosx
SCRIPT_BIN=/Users/cnotredame/bin/Scripts/
</environement>
<DumpStatus>OK</DumpStatus>
<DumpFile>/private/var/folders/42/7kdsjftx00g91b_dwj3f82nw0000gp/T/RANDOMSTRINGLUDCXA3Yilq06fX88A4u/tcoffee_technical_documentation.rst.8.dump</DumpFile>
<SourceFile>tcoffee_technical_documentation.rst</SourceFile>
<SourceLine>178</SourceLine>
</DumpIO>
